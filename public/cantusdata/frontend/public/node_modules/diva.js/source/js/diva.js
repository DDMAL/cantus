(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["diva"] = factory(require("jquery"));
	else
		root["diva"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(7);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var diva = __webpack_require__(2);
	
	diva.registerPlugin(__webpack_require__(6));
	diva.registerPlugin(__webpack_require__(44));
	diva.registerPlugin(__webpack_require__(45));
	diva.registerPlugin(__webpack_require__(46));
	diva.registerPlugin(__webpack_require__(47));
	diva.registerPlugin(__webpack_require__(48));
	diva.registerPlugin(__webpack_require__(49));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	var Events = __webpack_require__(4);
	var PluginRegistry = __webpack_require__(5);
	
	var diva = module.exports = {
	    Events: new Events(),
	
	    registerPlugin: function (plugin)
	    {
	        PluginRegistry.register(plugin);
	    },
	
	    /**
	     * Create a new Diva instance at the given element
	     *
	     * @param element {Element}
	     * @param options {Object}
	     * @returns {Diva}
	     */
	    create: function (element, options)
	    {
	        if (diva.find(element))
	            throw new Error('Diva is already initialized on ' + reprElem(element));
	
	        var $elem = $(element);
	        $elem.diva(options);
	
	        return $elem.data('diva');
	    },
	
	    /**
	     * Return the Diva instance attached to the
	     * element, if any.
	     *
	     * @param element
	     * @returns {Diva|null}
	     */
	    find: function (element)
	    {
	        return $(element).data('diva') || null;
	    }
	};
	
	function reprElem(elem)
	{
	    var id = elem.id ? '#' + elem.id : elem.id;
	    var classes = elem.className ? '.' + elem.className.split(/\s+/g).join('.') : '';
	
	    return (id ? id : elem.tagName.toLowerCase()) + classes;
	}


/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = Events;
	
	/**
	 *      Events. Pub/Sub system for Loosely Coupled logic.
	 *      Based on Peter Higgins' port from Dojo to jQuery
	 *      https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js
	 *
	 *      Re-adapted to vanilla Javascript
	 *
	 *      @class Events
	 */
	function Events()
	{
	    this._cache = {};
	}
	
	/**
	 *      diva.Events.publish
	 *      e.g.: diva.Events.publish("PageDidLoad", [pageIndex, filename, pageSelector], this);
	 *
	 *      @class Events
	 *      @method publish
	 *      @param topic {String}
	 *      @param args  {Array}
	 *      @param scope {Object=} Optional - Subscribed functions will be executed with the supplied object as `this`.
	 *          It is necessary to supply this argument with the self variable when within a Diva instance.
	 *          The scope argument is matched with the instance ID of subscribers to determine whether they
	 *              should be executed. (See instanceID argument of subscribe.)
	 */
	Events.prototype.publish = function (topic, args, scope)
	{
	    if (this._cache[topic])
	    {
	        var thisTopic = this._cache[topic];
	
	        if (typeof thisTopic.global !== 'undefined')
	        {
	            var thisTopicGlobal = thisTopic.global;
	            var globalCount = thisTopicGlobal.length;
	
	            for (var i=0; i < globalCount; i++)
	            {
	                thisTopicGlobal[i].apply(scope || null, args || []);
	            }
	        }
	
	        if (scope && typeof scope.getInstanceId !== 'undefined')
	        {
	            // get publisher instance ID from scope arg, compare, and execute if match
	            var instanceID = scope.getInstanceId();
	
	            if (this._cache[topic][instanceID])
	            {
	                var thisTopicInstance = this._cache[topic][instanceID];
	                var scopedCount = thisTopicInstance.length;
	
	                for (var j=0; j < scopedCount; j++)
	                {
	                    thisTopicInstance[j].apply(scope, args || []);
	                }
	            }
	        }
	    }
	};
	
	/**
	 *      diva.Events.subscribe
	 *      e.g.: diva.Events.subscribe("PageDidLoad", highlight, settings.ID)
	 *
	 *      @class Events
	 *      @method subscribe
	 *      @param topic {String}
	 *      @param callback {Function}
	 *      @param instanceID {String=} Optional - String representing the ID of a Diva instance; if provided,
	 *                                            callback only fires for events published from that instance.
	 *      @return Event handler {Array}
	 */
	Events.prototype.subscribe = function (topic, callback, instanceID)
	{
	    if (!this._cache[topic])
	    {
	        this._cache[topic] = {};
	    }
	
	    if (typeof instanceID === 'string')
	    {
	        if (!this._cache[topic][instanceID])
	        {
	            this._cache[topic][instanceID] = [];
	        }
	
	        this._cache[topic][instanceID].push(callback);
	    }
	    else
	    {
	        if (!this._cache[topic].global)
	        {
	            this._cache[topic].global = [];
	        }
	
	        this._cache[topic].global.push(callback);
	    }
	
	    var handle = instanceID ? [topic, callback, instanceID] : [topic, callback];
	
	    return handle;
	};
	
	/**
	 *      diva.Events.unsubscribe
	 *      e.g.: var handle = Events.subscribe("PageDidLoad", highlight);
	 *              Events.unsubscribe(handle);
	 *
	 *      @class Events
	 *      @method unsubscribe
	 *      @param handle {Array}
	 *      @param completely {Boolean=} - Unsubscribe all events for a given topic.
	 *      @return success {Boolean}
	 */
	Events.prototype.unsubscribe = function (handle, completely)
	{
	    var t = handle[0];
	
	    if (this._cache[t])
	    {
	        var topicArray;
	        var instanceID = handle.length === 3 ? handle[2] : 'global';
	
	        topicArray = this._cache[t][instanceID];
	
	        if (!topicArray)
	        {
	            return false;
	        }
	
	        if (completely)
	        {
	            delete this._cache[t][instanceID];
	            return topicArray.length > 0;
	        }
	
	        var i = topicArray.length;
	        while (i--)
	        {
	            if (topicArray[i] === handle[1])
	            {
	                this._cache[t][instanceID].splice(i, 1);
	                return true;
	            }
	        }
	    }
	
	    return false;
	};
	
	/**
	 *      diva.Events.unsubscribeAll
	 *      e.g.: diva.Events.unsubscribeAll('global');
	 *
	 *      @class Events
	 *      @param instanceID {String=} Optional - instance ID to remove subscribers from or 'global' (if omitted,
	 *                                   subscribers in all scopes removed)
	 *      @method unsubscribeAll
	 */
	Events.prototype.unsubscribeAll = function (instanceID)
	{
	    if (instanceID)
	    {
	        var topics = Object.keys(this._cache);
	        var i = topics.length;
	        var topic;
	
	        while (i--)
	        {
	            topic = topics[i];
	
	            if (typeof this._cache[topic][instanceID] !== 'undefined')
	            {
	                delete this._cache[topic][instanceID];
	            }
	        }
	    }
	    else
	    {
	        this._cache = {};
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * @module
	 * @private
	 * The global plugin registry.
	 */
	
	var plugins = [];
	
	module.exports = {
	    register: function (plugin)
	    {
	        plugins.push(plugin);
	    },
	    getAll: function ()
	    {
	        return plugins;
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Diva.JS autoscroll plugin
	Author: Andrew Horwitz
	
	Lets Diva scroll in the primary direction (as determined by
	settings.verticallyOriented) automatically at a given/changeable rate.
	
	Relevant settings:
	    -scrollSpeed: pixels per second (defaults to 10)
	    -disableManualScroll: disables manual scroll while automatic scroll is on (defaults to false)
	    -currentlyAutoScrolling: whether or not autoscroll is currently on
	    -autoScrollRefresh: ms between scrolling actions
	    -disableAutoscrollPrefs: disables the autoscroll preferences panel
	
	Relevant methods:
	    -startScrolling, stopScrolling, toggleScrolling
	    -changeRefresh, changeScrollSpeed (setters for respective options)
	    -disableManualScroll, enableManualScroll
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var pixelsPerScroll;
	                var disableManualScroll;
	                var autoScrollRefresh;
	                var defaultAutoRefresh;
	                var scrollSpeed;
	
	                function log10(x)
	                {
	                    return Math.log(x) / Math.log(10);
	                }
	
	                divaInstance.startScrolling = function()
	                {
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        console.warn("You are trying to start autoscrolling, but it is already scrolling.");
	                        return;
	                    }
	
	                    $("#" + divaSettings.ID + "autoscroll-toggle").text("Turn off");
	                    if (disableManualScroll)
	                    {
	                        divaInstance.disableScrollable();
	                    }
	
	                    divaSettings.currentlyAutoScrolling = true;
	                    restartScrollingInterval();
	                };
	
	                var restartScrollingInterval = function()
	                {
	                    clearInterval(divaSettings.autoScrollInterval);
	                    if (divaSettings.verticallyOriented)
	                    {
	                        divaSettings.autoScrollInterval = setInterval(function(){
	                            divaSettings.viewportObject.scrollTop(divaSettings.viewportObject.scrollTop() + pixelsPerScroll);
	                        }, autoScrollRefresh);
	                    }
	                    else
	                    {
	                        divaSettings.autoScrollInterval = setInterval(function(){
	                            divaSettings.viewportObject.scrollLeft(divaSettings.viewportObject.scrollLeft() + pixelsPerScroll);
	                        }, autoScrollRefresh);
	                    }
	                };
	
	                divaInstance.stopScrolling = function()
	                {
	                    if (!divaSettings.currentlyAutoScrolling)
	                    {
	                        console.warn("You are trying to stop autoscrolling, but it is not currently active.");
	                        return;
	                    }
	
	                    $("#" + divaSettings.ID + "autoscroll-toggle").text("Turn on");
	                    if (disableManualScroll)
	                    {
	                        divaInstance.enableScrollable();
	                    }
	
	                    divaSettings.currentlyAutoScrolling = false;
	                    clearInterval(divaSettings.autoScrollInterval);
	                };
	
	                divaInstance.toggleScrolling = function()
	                {
	                    if (divaSettings.currentlyAutoScrolling)
	                        divaInstance.stopScrolling();
	                    else
	                        divaInstance.startScrolling();
	                };
	
	                divaInstance.changeRefresh = function(newRefresh)
	                {
	                    autoScrollRefresh = newRefresh;
	                    updatePixelsPerScroll();
	                };
	
	                divaInstance.changeScrollSpeed = function(newSpeed)
	                {
	                    scrollSpeed = newSpeed;
	                    updatePixelsPerScroll();
	
	                    $("#" + divaSettings.ID + "autoscroll-pps").val(log10(scrollSpeed));
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        restartScrollingInterval();
	                    }
	                };
	
	                var updatePixelsPerScroll = function()
	                {
	                    autoScrollRefresh = defaultAutoRefresh;
	                    pixelsPerScroll = scrollSpeed / (1000 / autoScrollRefresh);
	
	                    //should be minimum of one otherwise it won't change the actual value
	                    //user can change autoscrollrefresh or scrollspeed; this may overwrite autoScrollRefresh
	                    if (pixelsPerScroll < 1)
	                    {
	                        autoScrollRefresh = autoScrollRefresh * (1 / pixelsPerScroll);
	                        pixelsPerScroll = scrollSpeed / (1000 / autoScrollRefresh);
	                    }
	                };
	
	                divaInstance.disableManualScroll = function()
	                {
	                    disableManualScroll = true;
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        divaInstance.disableScrollable();
	                    }
	                };
	
	                divaInstance.enableManualScroll = function()
	                {
	                    disableManualScroll = false;
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        divaInstance.enableScrollable();
	                    }
	                };
	
	                divaSettings.currentlyAutoScrolling = false;
	                divaSettings.autoScrollInterval = "";
	
	                disableManualScroll = divaSettings.disableManualScroll || false;
	                autoScrollRefresh = divaSettings.autoScrollRefresh || 50;
	                defaultAutoRefresh = autoScrollRefresh;
	
	                divaInstance.changeScrollSpeed((divaSettings.scrollSpeed || 10));
	
	                $(window).on('keyup', function(e)
	                {
	                    if (e.shiftKey && e.keyCode === 32)
	                    {
	                        divaInstance.toggleScrolling();
	                    }
	                });
	
	                if (!divaSettings.disableAutoscrollPrefs)
	                {
	                    var setPosition = function(isFullscreen)
	                    {
	                        if (divaSettings.inFullscreen)
	                        {
	                            var fullscreenTools = $(divaSettings.selector + 'tools');
	                            var toolsMargin = fullscreenTools.css('right');
	                            settings.jqObj.css({
	                                'right': toolsMargin,
	                                'margin-right': 0,
	                                'top': fullscreenTools.offset().top + fullscreenTools.outerHeight() + 15
	                            });
	                        }
	                        else
	                        {
	                            settings.jqObj.css({
	                                'right': $(window).width() - (divaSettings.viewportObject.offset().left + divaSettings.viewportObject.outerWidth()) + divaSettings.scrollbarWidth,
	                                'margin-right': '.6em'
	                            });
	                            settings.jqObj.offset({'top': divaSettings.viewportObject.offset().top + 1});
	                        }
	                    };
	
	                    diva.Events.subscribe('ModeDidSwitch', setPosition, divaSettings.ID);
	
	                    diva.Events.subscribe('ViewerDidLoad', function(s)
	                    {
	                        var autoscrollPrefsString =
	                        "<div id='" + divaSettings.ID + "autoscroll-prefs' class='diva-autoscroll-prefs diva-popup'>" +
	                            "<b>Autoscrolling options:</b><br>" +
	                            "<span class='diva-autoscroll-prefs-text'>Speed:</span>" +
	                            "<input type='range' id='" + divaSettings.ID + "autoscroll-pps' class='diva-autoscroll-pps diva-autoscroll-prefs-input' value='" + log10(scrollSpeed) + "' min='0' max='3' step='0.1'><br>" +
	                            "<span class='diva-autoscroll-prefs-text'>Allow manual scroll:</span>" +
	                            "<input type='checkbox' id='" + divaSettings.ID + "autoscroll-manual' class='diva-autoscroll-manual diva-autoscroll-prefs-input' checked='checked'><br>" +
	                            "<button id='" + divaSettings.ID + "autoscroll-toggle' class='diva-autoscroll-prefs-toggle diva-autoscroll-prefs-input'> Turn on </button>" +
	                        "</div>";
	                        $("#" + divaSettings.ID + "page-nav").before("<div id='" + divaSettings.ID + "autoscroll-icon' class='diva-button diva-autoscroll-icon' title='Expand autoscroll options'></div>");
	                        $("body").prepend(autoscrollPrefsString);
	
	                        $("#" + divaSettings.ID + "autoscroll-pps").on('change', function(e)
	                        {
	                            divaInstance.changeScrollSpeed(Math.pow(10, e.target.value));
	                        });
	
	                        $("#" + divaSettings.ID + "autoscroll-manual").on('change', function(e)
	                        {
	                            if (e.target.checked)
	                                divaInstance.enableManualScroll();
	                            else
	                                divaInstance.disableManualScroll();
	                        });
	
	                        $("#" + divaSettings.ID + "autoscroll-toggle").on('click', divaInstance.toggleScrolling);
	
	                        $("#" + divaSettings.ID + "autoscroll-icon").on('click', function(e)
	                        {
	                            settings.jqObj = $("#" + divaSettings.ID + "autoscroll-prefs");
	
	                            if (settings.jqObj.css('display') === 'none')
	                            {
	                                settings.jqObj.css({'display': 'block'});
	
	                                setPosition(divaSettings.inFullscreen);
	
	                            }
	                            else
	                            {
	                                settings.jqObj.css('display', 'none');
	                            }
	                        });
	                    }, divaSettings.ID);
	                }
	            },
	            pluginName: 'autoscroll',
	            titleText: 'Automatically scrolls page along primary axis'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Copyright (C) 2011-2016 by Wendy Liu, Evan Magoni, Andrew Hankinson, Andrew Horwitz, Laurent Pugin
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/
	
	var jQuery = __webpack_require__(3);
	
	var elt = __webpack_require__(8);
	var HashParams = __webpack_require__(9);
	
	var ActiveDivaController = __webpack_require__(10);
	var diva = __webpack_require__(2);
	var ImageManifest = __webpack_require__(11);
	var createToolbar = __webpack_require__(13);
	var ViewerCore = __webpack_require__(14);
	
	// Start the active Diva tracker
	// FIXME(wabain): Could defer this, if the logic isn't just getting removed
	var activeDiva = new ActiveDivaController(); // jshint ignore: line
	
	module.exports = diva;
	
	// this pattern was taken from http://www.virgentech.com/blog/2009/10/building-object-oriented-jquery-plugin.html
	(function ($)
	{
	    var Diva = function (element, options)
	    {
	        // Global instance variables (set way down in `init`)
	        var settings, viewerState, divaState;
	        var self = this;
	
	        // These are elements that can be overridden upon instantiation
	        // See https://github.com/DDMAL/diva.js/wiki/Settings for more details
	        options = $.extend({
	            adaptivePadding: 0.05,      // The ratio of padding to the page dimension
	            arrowScrollAmount: 40,      // The amount (in pixels) to scroll by when using arrow keys
	            blockMobileMove: false,     // Prevent moving or scrolling the page on mobile devices
	            objectData: '',             // A IIIF Manifest or a JSON file generated by process.py that provides the object dimension data, or a URL pointing to such data - *REQUIRED*
	            enableAutoTitle: true,      // Shows the title within a div of id diva-title
	            enableFilename: true,       // Uses filenames and not page numbers for links (i=bm_001.tif, not p=1)
	            enableFullscreen: true,     // Enable or disable fullscreen icon (mode still available)
	            enableGotoPage: true,       // A "go to page" jump box
	            enableGotoSuggestions: true, // Controls whether suggestions are shown under the input field when the user is typing in the 'go to page' form
	            enableGridIcon: true,       // A grid view of all the pages
	            enableGridControls: 'buttons',  // Specify control of pages per grid row in Grid view. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.
	            enableImageTitles: true,    // Adds "Page {n}" title to page images if true
	            enableKeyScroll: true,      // Captures scrolling using the arrow and page up/down keys regardless of page focus. When off, defers to default browser scrolling behavior.
	            enableLinkIcon: true,       // Controls the visibility of the link icon
	            enableNonPagedVisibilityIcon: true, // Controls the visibility of the icon to toggle the visibility of non-paged pages. (Automatically hidden if no 'non-paged' pages).
	            enableSpaceScroll: false,   // Scrolling down by pressing the space key
	            enableToolbar: true,        // Enables the toolbar. Note that disabling this means you have to handle all controls yourself.
	            enableZoomControls: 'buttons', // Specify controls for zooming in and out. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.
	            fillParentHeight: true,     // Use a flexbox layout to allow Diva to fill its parent's height
	            fixedPadding: 10,           // Fallback if adaptive padding is set to 0
	            fixedHeightGrid: true,      // So each page in grid view has the same height (only widths differ)
	            goDirectlyTo: 0,            // Default initial page to show (0-indexed)
	            hashParamSuffix: null,      // Used when there are multiple document viewers on a page
	            iipServerURL: '',           // The URL to the IIPImage installation, including the `?FIF=` - *REQUIRED*, unless using IIIF
	            inFullscreen: false,        // Set to true to load fullscreen mode initially
	            inBookLayout: false,       // Set to true to view the document with facing pages in document mode
	            inGrid: false,              // Set to true to load grid view initially
	            imageDir: '',               // Image directory, either absolute path or relative to IIP's FILESYSTEM_PREFIX - *REQUIRED*, unless using IIIF
	            maxPagesPerRow: 8,          // Maximum number of pages per row in grid view
	            maxZoomLevel: -1,           // Optional; defaults to the max zoom returned in the JSON response
	            minPagesPerRow: 2,          // Minimum pages per row in grid view. Recommended default.
	            minZoomLevel: 0,            // Defaults to 0 (the minimum zoom)
	            onGotoSubmit: null,         // When set to a function that takes a string and returns a page index, this will override the default behaviour of the 'go to page' form submission
	            pageLoadTimeout: 200,       // Number of milliseconds to wait before loading pages
	            pagesPerRow: 5,             // The default number of pages per row in grid view
	            rowLoadTimeout: 50,         // Number of milliseconds to wait before loading a row
	            showNonPagedPages: false,   // Whether pages tagged as 'non-paged' (in IIIF manifests only) should be visible after initial load
	            throbberTimeout: 100,       // Number of milliseconds to wait before showing throbber
	            tileHeight: 256,            // The height of each tile, in pixels; usually 256
	            tileWidth: 256,             // The width of each tile, in pixels; usually 256
	            toolbarParentObject: null,  // The toolbar parent object.
	            verticallyOriented: true,   // Determines vertical vs. horizontal orientation
	            viewportMargin: 200,        // Pretend tiles +/- 200px away from viewport are in
	            zoomLevel: 2                // The initial zoom level (used to store the current zoom level)
	        }, options);
	
	        // Returns the page index associated with the given filename; must called after setting settings.manifest
	        var getPageIndex = function (filename)
	        {
	            return getPageIndexForManifest(settings.manifest, filename);
	        };
	
	        var getPageIndexForManifest = function (manifest, filename)
	        {
	            var i,
	                np = manifest.pages.length;
	
	            for (i = 0; i < np; i++)
	            {
	                if (manifest.pages[i].f === filename)
	                {
	                    return i;
	                }
	            }
	
	            return -1;
	        };
	
	        // Check if a page index is valid
	        var isPageValid = function (pageIndex)
	        {
	            return settings.manifest.isPageValid(pageIndex, settings.showNonPagedPages);
	        };
	
	        var reloadViewer = function (newOptions)
	        {
	            return divaState.viewerCore.reload(newOptions);
	        };
	
	        // Called when the change view icon is clicked
	        var changeView = function (destinationView)
	        {
	            switch (destinationView)
	            {
	                case 'document':
	                    return reloadViewer({
	                        inGrid: false,
	                        inBookLayout: false
	                    });
	
	                case 'book':
	                    return reloadViewer({
	                        inGrid: false,
	                        inBookLayout: true
	                    });
	
	                case 'grid':
	                    return reloadViewer({
	                        inGrid: true
	                    });
	
	                default:
	                    return false;
	            }
	        };
	
	        //toggles between orientations
	        var toggleOrientation = function ()
	        {
	            var verticallyOriented = !settings.verticallyOriented;
	
	            //if in grid, switch out of grid
	            reloadViewer({
	                inGrid: false,
	                verticallyOriented: verticallyOriented,
	                goDirectlyTo: settings.currentPageIndex,
	                verticalOffset: divaState.viewerCore.getYOffset(),
	                horizontalOffset: divaState.viewerCore.getXOffset()
	            });
	
	            return verticallyOriented;
	        };
	
	        // Called when the fullscreen icon is clicked
	        var toggleFullscreen = function ()
	        {
	            reloadViewer({
	                inFullscreen: !settings.inFullscreen
	            });
	        };
	
	        var getState = function ()
	        {
	            var view;
	
	            if (settings.inGrid)
	            {
	                view = 'g';
	            }
	            else if (settings.inBookLayout)
	            {
	                view = 'b';
	            }
	            else
	            {
	                view = 'd';
	            }
	
	            var layout = divaState.viewerCore.getCurrentLayout();
	            var pageOffset = layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	            var state = {
	                'f': settings.inFullscreen,
	                'v': view,
	                'z': settings.zoomLevel,
	                'n': settings.pagesPerRow,
	                'i': settings.enableFilename ? settings.manifest.pages[settings.currentPageIndex].f : false,
	                'p': settings.enableFilename ? false : settings.currentPageIndex + 1,
	                'y': pageOffset ? pageOffset.y : false,
	                'x': pageOffset ? pageOffset.x : false
	            };
	
	            return state;
	        };
	
	        var getLoadOptionsForState = function (state, manifest)
	        {
	            manifest = manifest || settings.manifest;
	
	            var options = ('v' in state) ? getViewState(state.v) : {};
	
	            if ('f' in state)
	                options.inFullscreen = state.f;
	
	            if ('z' in state)
	                options.zoomLevel = state.z;
	
	            if ('n' in state)
	                options.pagesPerRow = state.n;
	
	            // Only change specify the page if state.i or state.p is valid
	            var pageIndex = getPageIndexForManifest(manifest, state.i);
	
	            if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))
	            {
	                pageIndex = state.p - 1;
	
	                // Possibly NaN
	                if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))
	                    pageIndex = null;
	            }
	
	            if (pageIndex !== null)
	            {
	                var horizontalOffset = parseInt(state.x, 10);
	                var verticalOffset = parseInt(state.y, 10);
	
	                options.goDirectlyTo = pageIndex;
	                options.horizontalOffset = horizontalOffset;
	                options.verticalOffset = verticalOffset;
	            }
	
	            return options;
	        };
	
	        var getURLHash = function ()
	        {
	            var hashParams = getState();
	            var hashStringBuilder = [];
	            var param;
	
	            for (param in hashParams)
	            {
	                if (hashParams[param] !== false)
	                    hashStringBuilder.push(param + settings.hashParamSuffix + '=' + encodeURIComponent(hashParams[param]));
	            }
	
	            return hashStringBuilder.join('&');
	        };
	
	        // Returns the URL to the current state of the document viewer (so it should be an exact replica)
	        var getCurrentURL = function ()
	        {
	            return location.protocol + '//' + location.host + location.pathname + location.search + '#' + getURLHash();
	        };
	
	        var getViewState = function(view)
	        {
	            switch (view)
	            {
	                case 'd':
	                    return {
	                        inGrid: false,
	                        inBookLayout: false
	                    };
	
	                case 'b':
	                    return {
	                        inGrid: false,
	                        inBookLayout: true
	                    };
	
	                case 'g':
	                    return {
	                        inGrid: true,
	                        inBookLayout: false
	                    };
	
	                default:
	                    return null;
	            }
	        };
	
	        var showError = function(message)
	        {
	            divaState.viewerCore.showError(message);
	        };
	
	        var ajaxError = function(jqxhr, status, error)
	        {
	            // Show a basic error message within the document viewer pane
	            // FIXME: Make this more end-user friendly. What about 404's etc?
	
	            var errorMessage = ['Invalid objectData setting. Error code: ' + jqxhr.status + ' ' + error];
	
	            // Detect and handle CORS errors
	            var dataHasAbsolutePath = settings.objectData.lastIndexOf('http', 0) === 0;
	
	            if (dataHasAbsolutePath && error === '')
	            {
	                var jsonHost = settings.objectData.replace(/https?:\/\//i, "").split(/[/?#]/)[0];
	
	                if (location.hostname !== jsonHost)
	                {
	                    errorMessage.push(
	                        elt('p', 'Attempted to access cross-origin data without CORS.'),
	                        elt('p',
	                            'You may need to update your server configuration to support CORS. For help, see the ',
	                            elt('a', {
	                                href: 'https://github.com/DDMAL/diva.js/wiki/Installation#a-note-about-cross-site-requests',
	                                target: '_blank'
	                            }, 'cross-site request documentation.')
	                        )
	                    );
	                }
	            }
	
	            showError(errorMessage);
	        };
	
	        var loadObjectData = function (responseData, hashState)
	        {
	            var isIIIF, manifest;
	
	            // parse IIIF manifest if it is an IIIF manifest. TODO improve IIIF detection method
	            if (responseData.hasOwnProperty('@context') && (responseData['@context'].indexOf('iiif') !== -1 ||
	                responseData['@context'].indexOf('shared-canvas') !== -1))
	            {
	                isIIIF = true;
	
	                // trigger ManifestDidLoad event
	                // FIXME: Why is this triggered before the manifest is parsed?
	                diva.Events.publish('ManifestDidLoad', [responseData], self);
	
	                manifest = ImageManifest.fromIIIF(responseData);
	            }
	            else
	            {
	                // IIP support is now deprecated
	                console.warn("Usage of IIP manifests is deprecated. Consider switching to IIIF manifests. Visit http://iiif.io/ for more information.");
	
	                isIIIF = false;
	                manifest = ImageManifest.fromLegacyManifest(responseData, {
	                    iipServerURL: settings.iipServerURL,
	                    imageDir: settings.imageDir
	                });
	            }
	
	            var loadOptions = hashState ? getLoadOptionsForState(hashState, manifest) : {};
	
	            divaState.viewerCore.setManifest(manifest, isIIIF, loadOptions);
	        };
	
	        /** Parse the hash parameters into the format used by getState and setState */
	        var getHashParamState = function ()
	        {
	            var state = {};
	
	            ['f', 'v', 'z', 'n', 'i', 'p', 'y', 'x'].forEach(function (param)
	            {
	                var value = HashParams.get(param + settings.hashParamSuffix);
	
	                // `false` is returned if the value is missing
	                if (value !== false)
	                    state[param] = value;
	            });
	
	            // Do some awkward special-casing, since this format is kind of weird.
	
	            // For inFullscreen (f), true and false strings should be interpreted
	            // as booleans.
	            if (state.f === 'true')
	                state.f = true;
	            else if (state.f === 'false')
	                state.f = false;
	
	            // Convert numerical values to integers, if provided
	            ['z', 'n', 'p', 'x', 'y'].forEach(function (param)
	            {
	                if (param in state)
	                    state[param] = parseInt(state[param], 10);
	            });
	
	            return state;
	        };
	
	        var checkLoaded = function()
	        {
	            if (!viewerState.loaded)
	            {
	                console.warn("The viewer is not completely initialized. This is likely because it is still downloading data. To fix this, only call this function if the isReady() method returns true.");
	                return false;
	            }
	            return true;
	        };
	
	        var init = function ()
	        {
	            // In order to fill the height, use a wrapper div displayed using a flexbox layout
	            var wrapperElement = elt('div', {
	                class: "diva-wrapper" + (options.fillParentHeight ? " diva-wrapper-flexbox" : "")
	            });
	            element.appendChild(wrapperElement);
	            options.toolbarParentObject = options.toolbarParentObject || $(wrapperElement);
	
	            var viewerCore = new ViewerCore(wrapperElement, options, self);
	
	            viewerState = viewerCore.getInternalState();
	            settings = viewerCore.getSettings();
	
	            // Add the ID to the wrapper element now that the ID has been generated by the viewer core
	            wrapperElement.id = settings.ID + 'wrapper';
	
	            divaState = {
	                viewerCore: viewerCore,
	                toolbar: settings.enableToolbar ? createToolbar(self) : null
	            };
	
	            var hashState = getHashParamState();
	
	            if (typeof settings.objectData === 'object')
	            {
	                // Defer execution until initialization has completed
	                setTimeout(function ()
	                {
	                    loadObjectData(settings.objectData, hashState);
	                }, 0);
	            }
	            else
	            {
	                var pendingManifestRequest = $.ajax({
	                    url: settings.objectData,
	                    cache: true,
	                    dataType: 'json',
	                    error: ajaxError,
	                    success: function (responseData)
	                    {
	                        loadObjectData(responseData, hashState);
	                    }
	                });
	
	                // Store the pending request so that it can be cancelled in the event that Diva needs to be destroyed
	                viewerCore.setPendingManifestRequest(pendingManifestRequest);
	            }
	        };
	
	        /* PUBLIC FUNCTIONS
	        ===============================================
	        */
	
	        // Returns the title of the document, based on the directory name
	        this.getItemTitle = function ()
	        {
	            return settings.manifest.itemTitle;
	        };
	
	        // Go to a particular page by its page number (with indexing starting at 1)
	            //xAnchor may either be "left", "right", or default "center"; the (xAnchor) side of the page will be anchored to the (xAnchor) side of the diva-outer element
	            //yAnchor may either be "top", "bottom", or default "center"; same process as xAnchor.
	        // returns True if the page number passed is valid; false if it is not.
	        this.gotoPageByNumber = function (pageNumber, xAnchor, yAnchor)
	        {
	            console.warn("This method is deprecated. Consider using gotoPageByIndex(pageIndex, xAnchor, yAnchor) instead.");
	            var pageIndex = parseInt(pageNumber, 10) - 1;
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        // Go to a particular page (with indexing starting at 0)
	            //xAnchor may either be "left", "right", or default "center"; the (xAnchor) side of the page will be anchored to the (xAnchor) side of the diva-outer element
	            //yAnchor may either be "top", "bottom", or default "center"; same process as xAnchor.
	        // returns True if the page index is valid; false if it is not.
	        this.gotoPageByIndex = function (pageIndex, xAnchor, yAnchor)
	        {
	            pageIndex = parseInt(pageIndex, 10);
	            if (isPageValid(pageIndex))
	            {
	                var xOffset = divaState.viewerCore.getXOffset(pageIndex, xAnchor);
	                var yOffset = divaState.viewerCore.getYOffset(pageIndex, yAnchor);
	
	                viewerState.renderer.goto(pageIndex, yOffset, xOffset);
	                return true;
	            }
	            return false;
	        };
	
	        this.getNumberOfPages = function ()
	        {
	            if (!checkLoaded())
	                return false;
	
	            return settings.numPages;
	        };
	
	        // Get page dimensions in the current view and zoom level
	        this.getPageDimensions = function (pageIndex)
	        {
	            if (!checkLoaded())
	                return null;
	
	            return divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);
	        };
	
	        // Returns the dimensions of a given page index at a given zoom level
	        this.getPageDimensionsAtZoomLevel = function (pageIdx, zoomLevel)
	        {
	            if (!checkLoaded())
	                return false;
	
	            if (zoomLevel > settings.maxZoomLevel)
	                zoomLevel = settings.maxZoomLevel;
	
	            var pg = settings.manifest.pages[parseInt(pageIdx, 10)];
	            var pgAtZoom = pg.d[parseInt(zoomLevel, 10)];
	            return {'width': pgAtZoom.w, 'height': pgAtZoom.h};
	        };
	
	        // Returns the dimensions of a given page at the current zoom level
	        // The current page index will be used if no pageIndex is specified
	        // Also works in Grid view
	        this.getPageDimensionsAtCurrentZoomLevel = function(pageIndex)
	        {
	            pageIndex = isPageValid(pageIndex) ? pageIndex : settings.currentPageIndex;
	
	            if (!isPageValid(pageIndex))
	                throw new Error('Invalid Page Index');
	
	            return divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);
	        };
	
	        // Returns the dimensions of the current page at the current zoom level
	        // Also works in Grid view
	        this.getCurrentPageDimensionsAtCurrentZoomLevel = function ()
	        {
	            return this.getPageDimensionsAtCurrentZoomLevel(settings.currentPageIndex);
	        };
	
	        this.isReady = function ()
	        {
	            return viewerState.loaded;
	        };
	
	        this.getCurrentPageIndex = function ()
	        {
	            return settings.currentPageIndex;
	        };
	
	        this.getCurrentPageFilename = function ()
	        {
	            return settings.manifest.pages[settings.currentPageIndex].f;
	        };
	
	        this.getCurrentPageNumber = function ()
	        {
	            console.warn("This method is deprecated. Consider using getCurrentPageIndex() instead.");
	            return settings.currentPageIndex + 1;
	        };
	
	        // Returns an array of all filenames in the document
	        this.getFilenames = function ()
	        {
	            var filenames = [];
	
	            for (var i = 0; i < settings.numPages; i++)
	            {
	                filenames[i] = settings.manifest.pages[i].f;
	            }
	
	            return filenames;
	        };
	
	        // Returns the current zoom level
	        this.getZoomLevel = function ()
	        {
	            return settings.zoomLevel;
	        };
	
	        // gets the maximum zoom level for the entire document
	        this.getMaxZoomLevel = function ()
	        {
	            return settings.maxZoomLevel;
	        };
	
	        // gets the max zoom level for a given page
	        this.getMaxZoomLevelForPage = function (pageIdx)
	        {
	            if (!checkLoaded)
	                return false;
	
	            return settings.manifest.pages[pageIdx].m;
	        };
	
	        this.getMinZoomLevel = function ()
	        {
	            return settings.minZoomLevel;
	        };
	
	        // Use the provided zoom level (will check for validity first)
	        // Returns false if the zoom level is invalid, true otherwise
	        this.setZoomLevel = function (zoomLevel)
	        {
	            if (settings.inGrid)
	            {
	                reloadViewer({
	                    inGrid: false
	                });
	            }
	
	            return divaState.viewerCore.zoom(zoomLevel);
	        };
	
	        this.getGridPagesPerRow = function ()
	        {
	            // TODO(wabain): Add test case
	            return this.pagesPerRow;
	        };
	
	        this.setGridPagesPerRow = function (newValue)
	        {
	            // TODO(wabain): Add test case
	            if (!divaState.viewerCore.isValidOption('pagesPerRow', newValue))
	                return false;
	
	            return reloadViewer({
	                inGrid: true,
	                pagesPerRow: newValue
	            });
	        };
	
	        // Zoom in. Will return false if it's at the maximum zoom
	        this.zoomIn = function ()
	        {
	            return this.setZoomLevel(settings.zoomLevel + 1);
	        };
	
	        // Zoom out. Will return false if it's at the minimum zoom
	        this.zoomOut = function ()
	        {
	            return this.setZoomLevel(settings.zoomLevel - 1);
	        };
	
	        // Check if something (e.g. a highlight box on a particular page) is visible
	        this.isRegionInViewport = function (pageIndex, leftOffset, topOffset, width, height)
	        {
	            var layout = divaState.viewerCore.getCurrentLayout();
	
	            if (!layout)
	                return false;
	
	            var offset = layout.getPageOffset(pageIndex);
	
	            var top = offset.top + topOffset;
	            var left = offset.left + leftOffset;
	
	            return viewerState.viewport.intersectsRegion({
	                top: top,
	                bottom: top + height,
	                left: left,
	                right: left + width
	            });
	        };
	
	        //Public wrapper for isPageVisible
	        //Determines if a page is currently in the viewport
	        this.isPageInViewport = function (pageIndex)
	        {
	            return viewerState.renderer.isPageVisible(pageIndex);
	        };
	
	        //Public wrapper for isPageLoaded
	        //Determines if a page is currently in the DOM
	        this.isPageLoaded = function (pageIndex)
	        {
	            console.warn("This method is deprecated. Consider using isPageInViewport(pageIndex) instead.");
	            return this.isPageInViewport(pageIndex);
	        };
	
	        // Toggle fullscreen mode
	        this.toggleFullscreenMode = function ()
	        {
	            toggleFullscreen();
	        };
	
	        // Show/Hide non-paged pages
	        this.toggleNonPagedPagesVisibility = function ()
	        {
	            reloadViewer({ showNonPagedPages: !settings.showNonPagedPages });
	        };
	
	        // Show non-paged pages
	        this.showNonPagedPages = function ()
	        {
	            reloadViewer({ showNonPagedPages: true });
	        };
	
	        // Hide non-paged pages
	        this.hideNonPagedPages = function ()
	        {
	            reloadViewer({ showNonPagedPages: false });
	        };
	
	        // Close toolbar popups
	        this.closePopups = function ()
	        {
	            divaState.toolbar.closePopups();
	        };
	
	        // Enter fullscreen mode if currently not in fullscreen mode
	        // Returns false if in fullscreen mode initially, true otherwise
	        // This function will work even if enableFullscreen is set to false
	        this.enterFullscreenMode = function ()
	        {
	            if (!settings.inFullscreen)
	            {
	                toggleFullscreen();
	                return true;
	            }
	
	            return false;
	        };
	
	        // Leave fullscreen mode if currently in fullscreen mode
	        // Returns true if in fullscreen mode intitially, false otherwise
	        this.leaveFullscreenMode = function ()
	        {
	            if (settings.inFullscreen)
	            {
	                toggleFullscreen();
	                return true;
	            }
	
	            return false;
	        };
	
	        // Change views. Takes 'document', 'book', or 'grid' to specify which view to switch into
	        this.changeView = function(destinationView)
	        {
	            return changeView(destinationView);
	        };
	
	        // Enter grid view if currently not in grid view
	        // Returns false if in grid view initially, true otherwise
	        this.enterGridView = function ()
	        {
	            if (!settings.inGrid)
	            {
	                changeView('grid');
	                return true;
	            }
	
	            return false;
	        };
	
	        // Leave grid view if currently in grid view
	        // Returns true if in grid view initially, false otherwise
	        this.leaveGridView = function ()
	        {
	            if (settings.inGrid)
	            {
	                reloadViewer({ inGrid: false });
	                return true;
	            }
	
	            return false;
	        };
	
	        // Jump to a page based on its filename
	        // Returns true if successful and false if the filename is invalid
	        this.gotoPageByName = function (filename, xAnchor, yAnchor)
	        {
	            var pageIndex = getPageIndex(filename);
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        this.gotoPageByLabel = function (label, xAnchor, yAnchor)
	        {
	            var pages = settings.manifest.pages;
	            for (var i = 0, len = pages.length; i < len; i++)
	            {
	                if (pages[i].l.toLowerCase().indexOf(label.toLowerCase()) > -1)
	                    return this.gotoPageByIndex(i, xAnchor, yAnchor);
	            }
	
	            // If no label was found, try to parse a page number
	            var pageIndex = parseInt(label, 10) - 1;
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        // Get the page index (0-based) corresponding to a given filename
	        // If the page index doesn't exist, this will return -1
	        this.getPageIndex = function (filename)
	        {
	            return getPageIndex(filename);
	        };
	
	        // Get the current URL (exposes the private method)
	        this.getCurrentURL = function ()
	        {
	            return getCurrentURL();
	        };
	
	        // Check if a page index is within the range of the document
	        this.isPageIndexValid = function (pageIndex)
	        {
	            return isPageValid(pageIndex);
	        };
	
	        // Get the hash part only of the current URL (without the leading #)
	        this.getURLHash = function ()
	        {
	            return getURLHash();
	        };
	
	        // Get an object representing the state of this diva instance (for setState)
	        this.getState = function ()
	        {
	            return getState();
	        };
	
	        // Align this diva instance with a state object (as returned by getState)
	        this.setState = function (state)
	        {
	            reloadViewer(getLoadOptionsForState(state));
	        };
	
	        // Get the instance selector for this instance, since it's auto-generated.
	        this.getInstanceSelector = function ()
	        {
	            return settings.selector;
	        };
	
	        // Get the instance ID -- essentially the selector without the leading '#'.
	        this.getInstanceId = function ()
	        {
	            return settings.ID;
	        };
	
	        this.getSettings = function ()
	        {
	            return settings;
	        };
	
	        /*
	            Translates a measurement from the zoom level on the largest size
	            to one on the current zoom level.
	
	            For example, a point 1000 on an image that is on zoom level 2 of 5
	            translates to a position of 111.111... (1000 / (5 - 2)^2).
	
	            Works for a single pixel co-ordinate or a dimension (e.g., translates a box
	            that is 1000 pixels wide on the original to one that is 111.111 pixels wide
	            on the current zoom level).
	        */
	        this.translateFromMaxZoomLevel = function (position)
	        {
	            var zoomDifference = settings.maxZoomLevel - settings.zoomLevel;
	            return position / Math.pow(2, zoomDifference);
	        };
	
	        /*
	            Translates a measurement from the current zoom level to the position on the
	            largest zoom level.
	
	            Works for a single pixel co-ordinate or a dimension (e.g., translates a box
	            that is 111.111 pixels wide on the current image to one that is 1000 pixels wide
	            on the current zoom level).
	        */
	        this.translateToMaxZoomLevel = function (position)
	        {
	            var zoomDifference = settings.maxZoomLevel - settings.zoomLevel;
	
	            // if there is no difference, it's a box on the max zoom level and
	            // we can just return the position.
	            if (zoomDifference === 0)
	                return position;
	
	            return position * Math.pow(2, zoomDifference);
	        };
	
	        // Re-enables document dragging, scrolling (by keyboard if set), and zooming by double-clicking
	        this.enableScrollable = function()
	        {
	            divaState.viewerCore.enableScrollable();
	        };
	
	        // Disables document dragging, scrolling (by keyboard if set), and zooming by double-clicking
	        this.disableScrollable = function ()
	        {
	            divaState.viewerCore.disableScrollable();
	        };
	
	        //Changes between horizontal layout and vertical layout. Returns true if document is now vertically oriented, false otherwise.
	        this.toggleOrientation = function ()
	        {
	            return toggleOrientation();
	        };
	
	        //Returns distance between the northwest corners of diva-inner and page index
	        this.getPageOffset = function(pageIndex, options)
	        {
	            var region = divaState.viewerCore.getPageRegion(pageIndex, options);
	
	            return {
	                top: region.top,
	                left: region.left
	            };
	        };
	
	        //shortcut to getPageOffset for current page
	        this.getCurrentPageOffset = function()
	        {
	            return this.getPageOffset(settings.currentPageIndex);
	        };
	
	        //Returns the page dimensions of given page at the current zoom level
	        this.getPageDimensionsAtCurrentGridLevel = function(pageIndex)
	        {
	            console.warn("This method is deprecated. Consider using getPageDimensionsAtCurrentZoomLevel(pageIndex) instead.");
	            return this.getPageDimensionsAtCurrentZoomLevel(pageIndex);
	        };
	
	        /*
	            Given a pageX and pageY value (as could be retreived from a jQuery event object),
	                returns either the page visible at that (x,y) position or -1 if no page is.
	        */
	        this.getPageIndexForPageXYValues = function(pageX, pageY)
	        {
	            //get the four edges of the outer element
	            var outerOffset = viewerState.outerElement.getBoundingClientRect();
	            var outerTop = outerOffset.top;
	            var outerLeft = outerOffset.left;
	            var outerBottom = outerOffset.bottom;
	            var outerRight = outerOffset.right;
	
	            //if the clicked position was outside the diva-outer object, it was not on a visible portion of a page
	            if (pageX < outerLeft || pageX > outerRight)
	                return -1;
	
	            if (pageY < outerTop || pageY > outerBottom)
	                return -1;
	
	            //navigate through all diva page objects
	            var pages = document.getElementsByClassName('diva-page');
	            var curPageIdx = pages.length;
	            while (curPageIdx--)
	            {
	                //get the offset for each page
	                var curPage = pages[curPageIdx];
	                var curOffset = curPage.getBoundingClientRect();
	
	                //if this point is outside the horizontal boundaries of the page, continue
	                if (pageX < curOffset.left || pageX > curOffset.right)
	                    continue;
	
	                //same with vertical boundaries
	                if (pageY < curOffset.top || pageY > curOffset.bottom)
	                    continue;
	
	                //if we made it through the above two, we found the page we're looking for
	                return curPage.getAttribute('data-index');
	            }
	
	            //if we made it through that entire while loop, we didn't click on a page
	            return -1;
	        };
	
	        /**
	         * Returns a URL for the image of the page at the given index. The
	         * optional size parameter supports setting the image width or height
	         * (default is full-sized).
	         */
	        this.getPageImageURL = function (pageIndex, size)
	        {
	            return settings.manifest.getPageImageURL(pageIndex, size);
	        };
	
	        //Pretty self-explanatory.
	        this.isVerticallyOriented = function()
	        {
	            return settings.verticallyOriented;
	        };
	
	        this.changeObject = function(objectData)
	        {
	            viewerState.loaded = false;
	            divaState.viewerCore.clear();
	
	            if (viewerState.renderer)
	                viewerState.renderer.destroy();
	
	            viewerState.options.objectData = objectData;
	
	            if (typeof objectData === 'object')
	            {
	                setTimeout(function ()
	                {
	                    loadObjectData(objectData);
	                });
	
	                return;
	            }
	
	            viewerState.throbberTimeoutID = setTimeout(function ()
	            {
	                $(settings.selector + 'throbber').show();
	            }, settings.throbberTimeout);
	
	            $.ajax({
	                url: settings.objectData,
	                cache: true,
	                dataType: 'json',
	                error: ajaxError,
	                success: function (responseData)
	                {
	                    loadObjectData(responseData);
	                }
	            });
	        };
	
	        this.activate = function ()
	        {
	            viewerState.isActiveDiva = true;
	        };
	
	        this.deactivate = function ()
	        {
	            viewerState.isActiveDiva = false;
	        };
	
	        // Destroys this instance, tells plugins to do the same (for testing)
	        this.destroy = function ()
	        {
	            divaState.viewerCore.destroy();
	        };
	
	        // "Secretly" expose the page overlay API for the highlight plugin
	        this.__addPageOverlay = function (overlay)
	        {
	            divaState.viewerCore.addPageOverlay(overlay);
	        };
	
	        this.__removePageOverlay = function (overlay)
	        {
	            divaState.viewerCore.removePageOverlay(overlay);
	        };
	
	        // Call the init function when this object is created.
	        init();
	    };
	
	    $.fn.diva = function (options)
	    {
	        return this.each(function ()
	        {
	            var divaParent = $(this);
	
	            // Return early if this element already has a plugin instance
	            if (divaParent.data('diva'))
	                return;
	
	            // Throw an error if the element is not in the DOM, since it causes some problems
	            if (!document.contains(this))
	                throw new Error('Diva could not be initialized because this element is not attached to the DOM');
	
	            // Otherwise, instantiate the document viewer
	            var diva = new Diva(this, options);
	            divaParent.data('diva', diva);
	        });
	    };
	})(jQuery);


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = elt;
	module.exports.setAttributes = setDOMAttributes;
	
	/**
	 * Convenience function to create a DOM element, set attributes on it, and
	 * append children. All arguments which are not of primitive type, are not
	 * arrays, and are not DOM nodes are treated as attribute hashes and are
	 * handled as described for setDOMAttributes. Children can either be a DOM
	 * node or a primitive value, which is converted to a text node. Arrays are
	 * handled recursively. Null and undefined values are ignored.
	 *
	 * Inspired by the ProseMirror helper of the same name.
	 */
	function elt(tag)
	{
	    var el = document.createElement(tag);
	    var args = Array.prototype.slice.call(arguments, 1);
	
	    while (args.length)
	    {
	        var arg = args.shift();
	        handleEltConstructorArg(el, arg);
	    }
	
	    return el;
	}
	
	function handleEltConstructorArg(el, arg)
	{
	    if (arg == null)
	        return;
	
	    if (typeof arg !== 'object' && typeof arg !== 'function')
	    {
	        // Coerce to string
	        el.appendChild(document.createTextNode(arg));
	    }
	    else if (arg instanceof window.Node)
	    {
	        el.appendChild(arg);
	    }
	    else if (arg instanceof Array)
	    {
	        var childCount = arg.length;
	        for (var i = 0; i < childCount; i++)
	            handleEltConstructorArg(el, arg[i]);
	    }
	    else
	    {
	        setDOMAttributes(el, arg);
	    }
	}
	
	/**
	 * Set attributes of a DOM element. The `style` property is special-cased to
	 * accept either a string or an object whose own attributes are assigned to
	 * el.style.
	 */
	function setDOMAttributes(el, attributes)
	{
	    for (var prop in attributes)
	    {
	        if (!attributes.hasOwnProperty(prop))
	            continue;
	
	        if (prop === 'style')
	        {
	            setStyle(el, attributes.style);
	        }
	        else
	        {
	            el.setAttribute(prop, attributes[prop]);
	        }
	    }
	}
	
	function setStyle(el, style)
	{
	    if (!style)
	        return;
	
	    if (typeof style !== 'object')
	    {
	        el.style.cssText = style;
	        return;
	    }
	
	    for (var cssProp in style)
	    {
	        if (!style.hasOwnProperty(cssProp))
	            continue;
	
	        el.style[cssProp] = style[cssProp];
	    }
	}


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports.get = getHashParam;
	module.exports.update = updateHashParam;
	
	// For getting the #key values from the URL. For specifying a page and zoom level
	// Look into caching, because we only need to get this during the initial load
	// Although for the tests I guess we would need to override caching somehow
	function getHashParam(key) {
	    var hash = window.location.hash;
	    if (hash !== '') {
	        // Check if there is something that looks like either &key= or #key=
	        var startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');
	
	        // If startIndex is still -1, it means it can't find either
	        if (startIndex >= 0) {
	            // Add the length of the key plus the & and =
	            startIndex += key.length + 2;
	
	            // Either to the next ampersand or to the end of the string
	            var endIndex = hash.indexOf('&', startIndex);
	            if (endIndex > startIndex) {
	                return decodeURIComponent(hash.substring(startIndex, endIndex));
	            } else if (endIndex < 0) {
	                // This means this hash param is the last one
	                return decodeURIComponent(hash.substring(startIndex));
	            }
	            // If the key doesn't have a value I think
	            return '';
	        } else {
	            // If it can't find the key
	            return false;
	        }
	    } else {
	        // If there are no hash params just return false
	        return false;
	    }
	}
	
	function updateHashParam(key, value) {
	    // First make sure that we have to do any work at all
	    var originalValue = getHashParam(key);
	    var hash = window.location.hash;
	    if (originalValue !== value) {
	        // Is the key already in the URL?
	        if (typeof originalValue == 'string') {
	            // Already in the URL. Just get rid of the original value
	            var startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');
	            var endIndex = startIndex + key.length + 2 + originalValue.length;
	            // # if it's the first, & otherwise
	            var startThing = (startIndex === 0) ? '#' : '&';
	            window.location.replace(hash.substring(0, startIndex) + startThing + key + '=' + value + hash.substring(endIndex));
	        } else {
	            // It's not present - add it
	            if (hash.length === 0) {
	                window.location.replace('#' + key + '=' + value);
	            } else {
	                // Append it
	                window.location.replace(hash + '&' + key + '=' + value);
	            }
	        }
	    }
	}


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var jQuery = __webpack_require__(3);
	
	//Used to keep track of whether Diva was last clicked or which Diva was last clicked when there are multiple
	var ActiveDivaController = (function ($)
	{
	    return function ()
	    {
	        var active;
	
	        //global click listener
	        $(document).on('click', function(e)
	        {
	            updateActive($(e.target));
	        });
	
	        //parameter should already be a jQuery selector
	        var updateActive = function (target)
	        {
	            var nearestOuter;
	
	            //these will find 0 or 1 objects, never more
	            var findOuter = target.find('.diva-outer');
	            var closestOuter = target.closest('.diva-outer');
	            var outers = document.getElementsByClassName('diva-outer');
	            var outerLen = outers.length;
	            var idx;
	
	            //clicked on something that was not either a parent or sibling of a diva-outer
	            if (findOuter.length > 0)
	            {
	                nearestOuter = findOuter;
	            }
	            //clicked on something that was a child of a diva-outer
	            else if (closestOuter.length > 0)
	            {
	                nearestOuter = closestOuter;
	            }
	            //clicked on something that was not in any Diva tree
	            else
	            {
	                //deactivate everything and return
	                for (idx = 0; idx < outerLen; idx++)
	                {
	                    $(outers[idx].parentElement.parentElement).data('diva').deactivate();
	                }
	                return;
	            }
	
	            //if we found one, activate it...
	            nearestOuter.parent().parent().data('diva').activate();
	            active = nearestOuter.parent();
	
	            //...and deactivate all the others
	            outers = document.getElementsByClassName('diva-outer');
	            for(idx = 0; idx < outerLen; idx++)
	            {
	                //getAttribute to attr - comparing DOM element to jQuery element
	                if (outers[idx].getAttribute('id') != nearestOuter.attr('id'))
	                    $(outers[idx].parentElement.parentElement).data('diva').deactivate();
	            }
	        };
	
	        //public accessor in case. Will return a jQuery selector.
	        this.getActive = function()
	        {
	            return active;
	        };
	    };
	})(jQuery);
	
	module.exports = ActiveDivaController;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint unused: true */
	
	var parseIIIFManifest = __webpack_require__(12);
	
	module.exports = ImageManifest;
	
	function ImageManifest(data, urlAdapter)
	{
	    // Save all the data we need
	    this.pages = data.pgs;
	    this.maxZoom = data.max_zoom;
	    this.maxRatio = data.dims.max_ratio;
	    this.minRatio = data.dims.min_ratio;
	    this.itemTitle = data.item_title;
	
	    // Only given for IIIF manifests
	    this.paged = !!data.paged;
	
	    // These are arrays, the index corresponding to the zoom level
	    this._maxWidths = data.dims.max_w;
	    this._maxHeights = data.dims.max_h;
	    this._averageWidths = data.dims.a_wid;
	    this._averageHeights = data.dims.a_hei;
	    this._totalHeights = data.dims.t_hei;
	    this._totalWidths = data.dims.t_wid;
	
	    this._urlAdapter = urlAdapter;
	}
	
	ImageManifest.fromIIIF = function (iiifManifest)
	{
	    var data = parseIIIFManifest(iiifManifest);
	    return new ImageManifest(data, new IIIFSourceAdapter());
	};
	
	ImageManifest.fromLegacyManifest = function (data, config)
	{
	    // For IIP manifests, use the page number (indexed starting from 1) as a label for each page
	    for (var i = 0, len = data.pgs.length; i < len; i++)
	        data.pgs[i].l = (i + 1).toString();
	
	    return new ImageManifest(data, new LegacyManifestSourceAdapter(config));
	};
	
	ImageManifest.prototype.isPageValid = function (pageIndex, showNonPagedPages)
	{
	    if (!showNonPagedPages && this.paged && !this.pages[pageIndex].paged)
	        return false;
	
	    return pageIndex >= 0 && pageIndex < this.pages.length;
	};
	
	ImageManifest.prototype.getMaxPageDimensions = function (pageIndex)
	{
	    var maxDims = this.pages[pageIndex].d[this.maxZoom];
	
	    return {
	        height: maxDims.h,
	        width: maxDims.w
	    };
	};
	
	ImageManifest.prototype.getPageDimensionsAtZoomLevel = function (pageIndex, zoomLevel)
	{
	    var maxDims = this.pages[pageIndex].d[this.maxZoom];
	
	    var scaleRatio = getScaleRatio(this.maxZoom, zoomLevel);
	
	    return {
	        height: maxDims.h * scaleRatio,
	        width: maxDims.w * scaleRatio
	    };
	};
	
	/**
	 * Returns a URL for the image of the given page. The optional size
	 * parameter supports setting the image width or height (default is
	 * full-sized).
	 */
	ImageManifest.prototype.getPageImageURL = function (pageIndex, size)
	{
	    return this._urlAdapter.getPageImageURL(this, pageIndex, size);
	};
	
	/**
	 * Return an array of tile objects for the specified page and integer zoom level
	 */
	ImageManifest.prototype.getPageImageTiles = function (pageIndex, zoomLevel, tileDimensions)
	{
	    var page = this.pages[pageIndex];
	
	    if (!isFinite(zoomLevel) || zoomLevel % 1 !== 0)
	        throw new TypeError('Zoom level must be an integer: ' + zoomLevel);
	
	    var rows = Math.ceil(page.d[zoomLevel].h / tileDimensions.height);
	    var cols = Math.ceil(page.d[zoomLevel].w / tileDimensions.width);
	
	    var tiles = [];
	
	    var row, col, url;
	
	    for (row = 0; row < rows; row++)
	    {
	        for (col = 0; col < cols; col++)
	        {
	            url = this._urlAdapter.getTileImageURL(this, pageIndex, {
	                row: row,
	                col: col,
	                rowCount: rows,
	                colCount: cols,
	                zoomLevel: zoomLevel,
	                tileDimensions: tileDimensions
	            });
	
	            // FIXME: Dimensions should account for partial tiles (e.g. the
	            // last row and column in a tiled image)
	            tiles.push({
	                row: row,
	                col: col,
	                zoomLevel: zoomLevel,
	                dimensions: {
	                    height: tileDimensions.height,
	                    width: tileDimensions.width
	                },
	                offset: {
	                    top: row * tileDimensions.height,
	                    left: col * tileDimensions.width
	                },
	                url: url
	            });
	        }
	    }
	
	    return {
	        zoomLevel: zoomLevel,
	        rows: rows,
	        cols: cols,
	        tiles: tiles
	    };
	};
	
	ImageManifest.prototype.getMaxWidth = zoomedPropertyGetter('_maxWidths');
	ImageManifest.prototype.getMaxHeight = zoomedPropertyGetter('_maxHeights');
	ImageManifest.prototype.getAverageWidth = zoomedPropertyGetter('_averageWidths');
	ImageManifest.prototype.getAverageHeight = zoomedPropertyGetter('_averageHeights');
	ImageManifest.prototype.getTotalWidth = zoomedPropertyGetter('_totalWidths');
	ImageManifest.prototype.getTotalHeight = zoomedPropertyGetter('_totalHeights');
	
	function zoomedPropertyGetter(privateName)
	{
	    return function (zoomLevel)
	    {
	        return this[privateName][zoomLevel];
	    };
	}
	
	function getScaleRatio(sourceZoomLevel, targetZoomLevel)
	{
	    return 1 / Math.pow(2, sourceZoomLevel - targetZoomLevel);
	}
	
	function IIIFSourceAdapter()
	{
	    // No-op
	}
	
	IIIFSourceAdapter.prototype.getPageImageURL = function (manifest, pageIndex, size)
	{
	    var dimens;
	
	    if (!size || (size.width == null && size.height == null))
	        dimens = 'full';
	    else
	        dimens = (size.width == null ? '' : size.width) + ',' + (size.height == null ? '' : size.height);
	
	    var page = manifest.pages[pageIndex];
	    var quality = (page.api > 1.1) ? 'default' : 'native';
	
	    return encodeURI(page.url + 'full/' + dimens + '/0/' + quality + '.jpg');
	};
	
	IIIFSourceAdapter.prototype.getTileImageURL = function (manifest, pageIndex, params)
	{
	    var page = manifest.pages[pageIndex];
	
	    var height, width;
	
	    if (params.row === params.rowCount - 1)
	        height = page.d[params.zoomLevel].h - (params.rowCount - 1) * params.tileDimensions.height;
	    else
	        height = params.tileDimensions.height;
	
	    if (params.col === params.colCount - 1)
	        width = page.d[params.zoomLevel].w - (params.colCount - 1) * params.tileDimensions.width;
	    else
	        width = params.tileDimensions.width;
	
	    var zoomDifference = Math.pow(2, manifest.maxZoom - params.zoomLevel);
	
	    var x = params.col * params.tileDimensions.width * zoomDifference;
	    var y = params.row * params.tileDimensions.height * zoomDifference;
	
	    if (page.hasOwnProperty('xoffset'))
	    {
	        x += page.xoffset;
	        y += page.yoffset;
	    }
	
	    var region = [x, y, width * zoomDifference, height * zoomDifference].join(',');
	
	    var quality = (page.api > 1.1) ? 'default' : 'native';
	
	    return encodeURI(page.url + region + '/' + width + ',' + height + '/0/' + quality + '.jpg');
	};
	
	function LegacyManifestSourceAdapter(config)
	{
	    this._config = config;
	}
	
	LegacyManifestSourceAdapter.prototype.getPageImageURL = function (manifest, pageIndex, size)
	{
	    // Without width or height specified, IIPImage defaults to full-size
	    var dimens = '';
	
	    if (size)
	    {
	        if (size.width != null)
	            dimens += '&WID=' + size.width;
	
	        if (size.height != null)
	            dimens += '&HEI=' + size.height;
	    }
	
	    var filename = manifest.pages[pageIndex].f;
	
	    return this._config.iipServerURL + "?FIF=" + this._config.imageDir + '/' + filename + dimens + '&CVT=JPEG';
	};
	
	LegacyManifestSourceAdapter.prototype.getTileImageURL = function (manifest, pageIndex, params)
	{
	    var page = manifest.pages[pageIndex];
	    var requestedZoomLevel = params.zoomLevel + page.m - manifest.maxZoom;
	    var index = (params.row * params.colCount) + params.col;
	    var jtl = requestedZoomLevel + ',' + index;
	
	    return encodeURI(this._config.iipServerURL + "?FIF=" + this._config.imageDir + '/' + page.f + '&JTL=' + jtl + '&CVT=JPEG');
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	/* jshint unused: true */
	
	module.exports = parseIIIFManifest;
	
	/**
	 * Parses a IIIF Presentation API Manifest and converts it into a Diva.js-format object
	 * (See https://github.com/DDMAL/diva.js/wiki/Development-notes#data-received-through-ajax-request)
	 * (This is a client-side re-implementation of generate_json.py)
	 *
	 * @param {Object} manifest - an object that represents a valid IIIF manifest
	 * @returns {Object} divaServiceBlock - the data needed by Diva to show a view of a single document
	 */
	function parseIIIFManifest(manifest)
	{
	
	    var incorporateZoom = function (imageDimension, zoomDifference)
	    {
	        return imageDimension / (Math.pow(2, zoomDifference));
	    };
	
	    var getMaxZoomLevel = function (width, height)
	    {
	        var largestDimension = Math.max(width, height);
	        return Math.ceil(Math.log((largestDimension + 1) / (256 + 1)) / Math.log(2));
	    };
	
	    var createArrayWithValue = function (length, value)
	    {
	        var array = new Array(length);
	        var i = length;
	
	        while (i--)
	        {
	            array[i] = value;
	        }
	
	        return array;
	    };
	
	    var sequence = manifest.sequences[0];
	
	    //@TODO choose a sequence intelligently
	    var canvases = sequence.canvases;
	
	    var zoomLevels = [];
	    var images = [];
	    var imageIndex = 0;
	
	    var width;
	    var height;
	    var url;
	    var filename;
	    var info;
	    var maxZoom;
	    var label;
	    var context;
	    var resource;
	    var imageAPIVersion;
	
	    var title = manifest.label;
	
	    for (var i = 0, numCanvases = canvases.length; i < numCanvases; i++)
	    {
	        resource = canvases[i].images[0].resource;
	        width = resource.width || canvases[i].width;
	        height = resource.height || canvases[i].height;
	
	        info = parseImageInfo(resource);
	        url = info.url;
	        filename = url; // For IIIF, the url is the filename
	
	        //append trailing / from url if it's not there
	        if (url.slice(-1) !== '/')
	        {
	            url = url + '/';
	        }
	
	        maxZoom = getMaxZoomLevel(width, height);
	
	        // get filenames from service block (@TODO should this be changed to 'identifiers?')
	        // get label from canvas block ('filename' is legacy)
	        label = canvases[i].label;
	
	        // indicate whether canvas has viewingHint of non-paged
	        var paged = canvases[i].viewingHint !== 'non-paged';
	        var facingPages = canvases[i].viewingHint === 'facing-pages';
	
	        context = resource.service['@context'];
	        if (context === 'http://iiif.io/api/image/2/context.json')
	        {
	            imageAPIVersion = 2.0;
	        }
	        else if (context === 'http://library.stanford.edu/iiif/image-api/1.1/context.json')
	        {
	            imageAPIVersion = 1.1;
	        }
	        else
	        {
	            imageAPIVersion = 1.0;
	        }
	
	        images[imageIndex] = {
	            'mx_w': width,
	            'mx_h': height,
	            'mx_z': maxZoom,
	            'label': label,
	            'fn': filename,
	            'url': url,
	            'api': imageAPIVersion,
	            'paged': paged,
	            'facingPages': facingPages
	        };
	
	        if (info.hasOwnProperty('x'))
	        {
	            images[imageIndex].xoffset = info.x;
	            images[imageIndex].yoffset = info.y;
	        }
	
	        zoomLevels[imageIndex] = maxZoom;
	        imageIndex++;
	    }
	
	    var lowestMaxZoom = Math.min.apply(Math, zoomLevels);
	
	    // ratio calculations
	    var maxRatio = 0;
	    var minRatio = 100; // initialize high so we can get the minimum later
	
	    var totalWidths = createArrayWithValue(lowestMaxZoom + 1, 0);
	    var totalHeights = createArrayWithValue(lowestMaxZoom + 1, 0);
	    var maxWidths = createArrayWithValue(lowestMaxZoom + 1, 0);
	    var maxHeights = createArrayWithValue(lowestMaxZoom + 1, 0);
	
	    var pages = [];
	    var currentPageZoomData; // dimensions per zoomlevel
	
	    var widthAtCurrentZoomLevel;
	    var heightAtCurrentZoomLevel;
	
	    var numImages = images.length;
	
	    // for each page image:
	    for (i = 0; i < numImages; i++)
	    {
	        currentPageZoomData = [];
	
	        // construct 'd' key. for each zoom level:
	        for (var j = 0; j < lowestMaxZoom + 1; j++)
	        {
	            // calculate current page zoom data
	            widthAtCurrentZoomLevel = Math.floor(incorporateZoom(images[i].mx_w, lowestMaxZoom - j));
	            heightAtCurrentZoomLevel = Math.floor(incorporateZoom(images[i].mx_h, lowestMaxZoom - j));
	            currentPageZoomData[j] = {
	                h: heightAtCurrentZoomLevel,
	                w: widthAtCurrentZoomLevel
	            };
	
	            // add width of image at current zoom level to total widths/heights
	            totalWidths[j] += widthAtCurrentZoomLevel;
	            totalHeights[j] += heightAtCurrentZoomLevel;
	            maxWidths[j] = Math.max(widthAtCurrentZoomLevel, maxWidths[j]);
	            maxHeights[j] = Math.max(heightAtCurrentZoomLevel, maxHeights[j]);
	
	            // calculate max/min ratios
	            var ratio = images[i].mx_h / images[i].mx_w;
	            maxRatio = Math.max(ratio, maxRatio);
	            minRatio = Math.min(ratio, minRatio);
	        }
	
	        pages[i] = {
	            d: currentPageZoomData,
	            m: images[i].mx_z,
	            l: images[i].label,
	            f: images[i].fn,
	            url: images[i].url,
	            api: images[i].api,
	            paged: images[i].paged,
	            facingPages: images[i].facingPages
	        };
	
	        if (images[i].hasOwnProperty('xoffset'))
	        {
	            pages[i].xoffset = images[i].xoffset;
	            pages[i].yoffset = images[i].yoffset;
	        }
	    }
	
	    var averageWidths = [];
	    var averageHeights = [];
	
	    // for each zoom level, calculate average of heights/widths
	    for (i = 0; i < lowestMaxZoom + 1; i++)
	    {
	        averageWidths.push(totalWidths[i] / images.length);
	        averageHeights.push(totalHeights[i] / images.length);
	    }
	
	    var dims = {
	        'a_wid': averageWidths,
	        'a_hei': averageHeights,
	        'max_w': maxWidths,
	        'max_h': maxHeights,
	        'max_ratio': maxRatio,
	        'min_ratio': minRatio,
	        't_hei': totalHeights,
	        't_wid': totalWidths
	    };
	
	
	    var divaServiceBlock = {
	        item_title: title,
	        dims: dims,
	        max_zoom: lowestMaxZoom,
	        pgs: pages,
	        paged: manifest.viewingHint === 'paged' || sequence.viewingHint === 'paged'
	    };
	
	    return divaServiceBlock;
	}
	
	/**
	 * Takes in a resource block from a canvas and outputs the following information associated with that resource:
	 * - Image URL
	 * - Image region to be displayed
	 *
	 * @param {Object} resource - an object representing the resource block of a canvas section in a IIIF manifest
	 * @returns {Object} imageInfo - an object containing image URL and region
	 */
	function parseImageInfo(resource)
	{
	    var url = resource['@id'];
	    var fragmentRegex = /#xywh=([0-9]+,[0-9]+,[0-9]+,[0-9]+)/;
	    var xywh = '';
	    var stripURL = true;
	
	    if (/\/([0-9]+,[0-9]+,[0-9]+,[0-9]+)\//.test(url))
	    {
	        // if resource in image API format, extract region x,y,w,h from URL (after 4th slash from last)
	        // matches coordinates in URLs of the form http://www.example.org/iiif/book1-page1/40,50,1200,1800/full/0/default.jpg
	        var urlArray = url.split('/');
	        xywh = urlArray[urlArray.length - 4];
	    }
	    else if (fragmentRegex.test(url))
	    {
	        // matches coordinates of the style http://www.example.org/iiif/book1/canvas/p1#xywh=50,50,320,240
	        var result = fragmentRegex.exec(url);
	        xywh = result[1];
	    }
	    else if (resource.service && resource.service['@id'])
	    {
	        // assume canvas size based on image size
	        url = resource.service['@id'];
	        // this URL excludes region parameters so we don't need to remove them
	        stripURL = false;
	    }
	
	    if (stripURL)
	    {
	        // extract URL up to identifier (we eliminate the last 5 parameters: /region/size/rotation/quality.format)
	        url = url.split('/').slice(0, -4).join('/');
	    }
	
	    var imageInfo = {
	        url: url
	    };
	
	    if (xywh.length)
	    {
	        // parse into separate components
	        var dimensions = xywh.split(',');
	        imageInfo.x = parseInt(dimensions[0], 10);
	        imageInfo.y = parseInt(dimensions[1], 10);
	        imageInfo.w = parseInt(dimensions[2], 10);
	        imageInfo.h = parseInt(dimensions[3], 10);
	    }
	
	    return imageInfo;
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	var diva = __webpack_require__(2);
	var elt = __webpack_require__(8);
	
	module.exports = createToolbar;
	
	function createToolbar(viewer)
	{
	    var settings = viewer.getSettings();
	
	    // FIXME(wabain): Temporarily copied from within Diva
	    var elemAttrs = function (ident, base)
	    {
	        var attrs = {
	            id: settings.ID + ident,
	            class: 'diva-' + ident
	        };
	
	        if (base)
	            return $.extend(attrs, base);
	        else
	            return attrs;
	    };
	
	    /** Convenience function to subscribe to a Diva event */
	    var subscribe = function (event, callback)
	    {
	        diva.Events.subscribe(event, callback, settings.ID);
	    };
	
	    // Creates a toolbar button
	    var createButtonElement = function(name, label, callback)
	    {
	        var button = elt('button', {
	            type: 'button',
	            id: settings.ID + name,
	            class: 'diva-' + name + ' diva-button',
	            title: label
	        });
	
	        if (callback)
	            button.addEventListener('click', callback, false);
	
	        return button;
	    };
	
	    // Higher-level function for creators of zoom and grid controls
	    var getResolutionControlCreator = function (config)
	    {
	        return function ()
	        {
	            var controls;
	
	            switch (settings[config.controllerSetting])
	            {
	                case 'slider':
	                    controls = config.createSlider();
	                    break;
	
	                case 'buttons':
	                    controls = config.createButtons();
	                    break;
	
	                default:
	                    // Don't display anything
	                    return null;
	            }
	
	            var wrapper = elt('span',
	                controls,
	                config.createLabel()
	            );
	
	            var updateWrapper = function ()
	            {
	                if (settings.inGrid === config.showInGrid)
	                    wrapper.style.display = 'inline';
	                else
	                    wrapper.style.display = 'none';
	            };
	
	            subscribe('ViewDidSwitch', updateWrapper);
	            subscribe('ObjectDidLoad', updateWrapper);
	
	            // Set initial value
	            updateWrapper();
	
	            return wrapper;
	        };
	    };
	
	    // Zoom controls
	    var createZoomControls = getResolutionControlCreator({
	        controllerSetting: 'enableZoomControls',
	        showInGrid: false,
	
	        createSlider: function ()
	        {
	            var elem = createSlider('zoom-slider', {
	                step: 0.1,
	                value: settings.zoomLevel,
	                min: settings.minZoomLevel,
	                max: settings.maxZoomLevel
	            });
	            var $elem = $(elem);
	
	            $elem.on('input', function()
	            {
	                var floatValue = parseFloat(this.value);
	                viewer.setZoomLevel(floatValue);
	            });
	
	            $elem.on('change', function ()
	            {
	                var floatValue = parseFloat(this.value);
	                if (floatValue !== settings.zoomLevel)
	                    viewer.setZoomLevel(floatValue);
	            });
	
	            var updateSlider = function ()
	            {
	                if (settings.zoomLevel !== $elem.val())
	                    $elem.val(settings.zoomLevel);
	            };
	
	            subscribe('ZoomLevelDidChange', updateSlider);
	            subscribe('ViewerDidLoad', function ()
	            {
	                elt.setAttributes(elem, {
	                    min: settings.minZoomLevel,
	                    max: settings.maxZoomLevel
	                });
	
	                updateSlider();
	            });
	
	            return elem;
	        },
	
	        createButtons: function ()
	        {
	            return elt('span',
	                createButtonElement('zoom-out-button', 'Zoom Out', function ()
	                {
	                    viewer.setZoomLevel(settings.zoomLevel - 1);
	                }),
	                createButtonElement('zoom-in-button', 'Zoom In', function ()
	                {
	                    viewer.setZoomLevel(settings.zoomLevel + 1);
	                })
	            );
	        },
	
	        createLabel: function ()
	        {
	            var elem = createLabel('diva-zoom-label', 'zoom-label', 'Zoom level: ', 'zoom-level', settings.zoomLevel);
	            var textSpan = $(elem).find(settings.selector + 'zoom-level')[0];
	
	            var updateText = function ()
	            {
	                textSpan.textContent = settings.zoomLevel.toFixed(2);
	            };
	
	            subscribe('ZoomLevelDidChange', updateText);
	            subscribe('ViewerDidLoad', updateText);
	
	            return elem;
	        }
	    });
	
	    // Grid controls
	    var createGridControls = getResolutionControlCreator({
	        controllerSetting: 'enableGridControls',
	        showInGrid: true,
	
	        createSlider: function ()
	        {
	            var elem = createSlider('grid-slider', {
	                value: settings.pagesPerRow,
	                min: settings.minPagesPerRow,
	                max: settings.maxPagesPerRow
	            });
	            var $elem = $(elem);
	
	            $elem.on('input', function()
	            {
	                var intValue = parseInt(elem.value, 10);
	                viewer.setGridPagesPerRow(intValue);
	            });
	
	            $elem.on('change', function ()
	            {
	                var intValue = parseInt(elem.value, 10);
	                if (intValue !== settings.pagesPerRow)
	                    viewer.setGridPagesPerRow(intValue);
	            });
	
	            subscribe('GridRowNumberDidChange', function ()
	            {
	                // Update the position of the handle within the slider
	                if (settings.pagesPerRow !== $elem.val())
	                    $elem.val(settings.pagesPerRow);
	            });
	
	            return elem;
	        },
	
	        createButtons: function ()
	        {
	            return elt('span',
	                createButtonElement('grid-out-button', 'Zoom Out', function ()
	                {
	                    viewer.setGridPagesPerRow(settings.pagesPerRow - 1);
	                }),
	                createButtonElement('grid-in-button', 'Zoom In', function ()
	                {
	                    viewer.setGridPagesPerRow(settings.pagesPerRow + 1);
	                })
	            );
	        },
	
	        createLabel: function ()
	        {
	            var elem = createLabel('diva-grid-label', 'grid-label', 'Pages per row: ', 'pages-per-row', settings.pagesPerRow);
	            var textSpan = $(elem).find(settings.selector + 'pages-per-row')[0];
	
	            subscribe('GridRowNumberDidChange', function ()
	            {
	                textSpan.textContent = settings.pagesPerRow;
	            });
	
	            return elem;
	        }
	    });
	
	    var createViewMenu = function()
	    {
	        var viewOptionsList = elt('div', elemAttrs('view-options'));
	
	        var changeViewButton = createButtonElement('view-icon', 'Change view', function ()
	        {
	            $(viewOptionsList).toggle();
	        });
	
	        $(document).mouseup(function (event)
	        {
	            var container = $(viewOptionsList);
	
	            if (!container.is(event.target) && container.has(event.target).length === 0 && event.target.id !== settings.ID + 'view-icon')
	            {
	                container.hide();
	            }
	        });
	
	        var selectView = function (view)
	        {
	            viewer.changeView(view);
	
	            //hide view menu
	            $(viewOptionsList).hide();
	        };
	
	        var updateViewMenu = function()
	        {
	            var viewIconClasses = ' diva-view-icon diva-button';
	
	            // display the icon of the mode we're currently in (?)
	            if (settings.inGrid)
	            {
	                changeViewButton.className = 'diva-grid-icon' + viewIconClasses;
	            }
	            else if (settings.inBookLayout)
	            {
	                changeViewButton.className = 'diva-book-icon' + viewIconClasses;
	            }
	            else
	            {
	                changeViewButton.className = 'diva-document-icon' + viewIconClasses;
	            }
	
	            var viewOptions = document.createDocumentFragment();
	
	            // then display document, book, and grid buttons in that order, excluding the current view
	            if (settings.inGrid || settings.inBookLayout)
	                viewOptions.appendChild(createButtonElement('document-icon', 'Document View', selectView.bind(null, 'document')));
	
	            if (settings.inGrid || !settings.inBookLayout)
	                viewOptions.appendChild(createButtonElement('book-icon', 'Book View', selectView.bind(null, 'book')));
	
	            if (!settings.inGrid)
	                viewOptions.appendChild(createButtonElement('grid-icon', 'Grid View', selectView.bind(null, 'grid')));
	
	            // remove old menu
	            while (viewOptionsList.firstChild)
	            {
	                viewOptionsList.removeChild(viewOptionsList.firstChild);
	            }
	
	            // insert new menu
	            viewOptionsList.appendChild(viewOptions);
	        };
	
	        subscribe('ViewDidSwitch', updateViewMenu);
	        subscribe('ObjectDidLoad', updateViewMenu);
	
	        return elt('div', elemAttrs('view-menu'),
	            changeViewButton,
	            viewOptionsList
	        );
	    };
	
	    var createSlider = function(name, options)
	    {
	        return elt('input', options, {
	            id: settings.ID + name,
	            class: 'diva-' + name + ' diva-slider',
	            type: 'range'
	        });
	    };
	
	    var createLabel = function(name, id, label, innerName, innerValue)
	    {
	        return elt('div', {
	                id: settings.ID + id,
	                class: name + ' diva-label'
	            },
	            [
	                label,
	                elt('span', {
	                    id: settings.ID + innerName
	                }, innerValue)
	            ]);
	    };
	
	    var createPageNavigationControls = function ()
	    {
	        // Go to page form
	        var gotoForm = settings.enableGotoPage ? createGotoPageForm() : null;
	
	        return elt('span', elemAttrs('page-nav'),
	            createPageLabel(), // 'Page x of y' label
	            gotoForm
	        );
	    };
	
	    var createGotoPageForm = function ()
	    {
	        var gotoPageInput = elt('input', {
	            id: settings.ID + 'goto-page-input',
	            class: 'diva-input diva-goto-page-input',
	            autocomplete: 'off',
	            type: 'text'
	        });
	
	        var gotoPageSubmit = elt('input', {
	            id: settings.ID + 'goto-page-submit',
	            class: 'diva-button diva-button-text',
	            type: 'submit',
	            value: 'Go'
	        });
	
	        var inputSuggestions = elt('div', {
	                id: settings.ID + 'input-suggestions',
	                class: 'diva-input-suggestions'
	            }
	        );
	
	        var gotoForm = elt('form', {
	                id: settings.ID + 'goto-page',
	                class: 'diva-goto-form'
	            },
	            gotoPageInput,
	            gotoPageSubmit,
	            inputSuggestions
	        );
	
	        $(gotoForm).on('submit', function ()
	        {
	            var desiredPageLabel = gotoPageInput.value;
	
	            if (settings.onGotoSubmit && typeof settings.onGotoSubmit === "function")
	            {
	                var pageIndex = settings.onGotoSubmit(desiredPageLabel);
	                if (!viewer.gotoPageByIndex(pageIndex))
	                    alert("No page could be found with that label or page number");
	
	            }
	            else // Default if no function is specified in the settings
	            {
	                if (!viewer.gotoPageByLabel(desiredPageLabel))
	                    alert("No page could be found with that label or page number");
	            }
	
	            // Hide the suggestions
	            inputSuggestions.style.display = 'none';
	
	            // Prevent the default action of reloading the page
	            return false;
	        });
	
	        $(gotoPageInput).on('input focus', function ()
	        {
	            inputSuggestions.innerHTML = ''; // Remove all previous suggestions
	
	            var value = gotoPageInput.value;
	            var numSuggestions = 0;
	            if (settings.enableGotoSuggestions && value)
	            {
	                var pages = settings.manifest.pages;
	                for (var i = 0, len = pages.length; i < len && numSuggestions < 10; i++)
	                {
	                    if (pages[i].l.toLowerCase().indexOf(value.toLowerCase()) > -1)
	                    {
	                        var newInputSuggestion = elt('div', {
	                                class: 'diva-input-suggestion'
	                            },
	                            pages[i].l
	                        );
	
	                        inputSuggestions.appendChild(newInputSuggestion);
	
	                        numSuggestions++;
	                    }
	                }
	
	                // Show label suggestions
	                if (numSuggestions > 0)
	                    inputSuggestions.style.display = 'block';
	            }
	            else
	                inputSuggestions.style.display = 'none';
	        });
	
	        $(gotoPageInput).on('keydown', function (e)
	        {
	            var el;
	            if (e.keyCode === 13) // 'Enter' key
	            {
	                var active = $('.active', inputSuggestions);
	                if (active.length)
	                    gotoPageInput.value = active.text();
	
	            }
	            if (e.keyCode === 38) // Up arrow key
	            {
	                el = $('.active', inputSuggestions);
	                var prevEl = el.prev();
	                if (prevEl.length)
	                {
	                    el.removeClass('active');
	                    prevEl.addClass('active');
	                }
	                else
	                {
	                    el.removeClass('active');
	                    $('.diva-input-suggestion:last', inputSuggestions).addClass('active');
	                }
	            }
	            else if (e.keyCode === 40) // Down arrow key
	            {
	                el = $('.active', inputSuggestions);
	                var nextEl = el.next();
	                if (nextEl.length)
	                {
	                    el.removeClass('active');
	                    nextEl.addClass('active');
	                }
	                else
	                {
	                    el.removeClass('active');
	                    $('.diva-input-suggestion:first', inputSuggestions).addClass('active');
	                }
	            }
	        });
	
	        $(inputSuggestions).on('mousedown', '.diva-input-suggestion', function()
	        {
	            gotoPageInput.value = this.textContent;
	            inputSuggestions.style.display = 'none';
	            $(gotoPageInput).trigger('submit');
	        });
	
	        $(gotoPageInput).on('blur', function ()
	        {
	            // Hide label suggestions
	            inputSuggestions.style.display = 'none';
	        });
	
	        return gotoForm;
	    };
	
	    var createPageLabel = function()
	    {
	        // Current page
	        var currentPage = elt('span', {
	            id: settings.ID + 'current-page'
	        });
	
	        var updateCurrentPage = function ()
	        {
	            currentPage.textContent = parseInt(settings.currentPageIndex, 10) + 1;
	        };
	
	        subscribe('VisiblePageDidChange', updateCurrentPage);
	        subscribe('ViewerDidLoad', updateCurrentPage);
	
	        // Number of pages
	        var numPages = elt('span', {
	            id: settings.ID + 'num-pages'
	        });
	
	        var updateNumPages = function ()
	        {
	            numPages.textContent = settings.numPages;
	        };
	
	        subscribe('NumberOfPagesDidChange', updateNumPages);
	        subscribe('ObjectDidLoad', updateNumPages);
	
	        return elt('span', {
	                class: 'diva-page-label diva-label'
	            },
	            'Page ', currentPage, ' of ', numPages
	        );
	    };
	
	    var createToolbarButtonGroup = function ()
	    {
	        var buttons = [createViewMenu()];
	
	        if (settings.enableLinkIcon)
	            buttons.push(createLinkIcon());
	
	        if (settings.enableNonPagedVisibilityIcon)
	            buttons.push(createToggleNonPagedButton());
	
	        if (settings.enableFullscreen)
	            buttons.push(createFullscreenButton());
	
	        return elt('span', elemAttrs('toolbar-button-group'), buttons);
	    };
	
	    var createLinkIcon = function ()
	    {
	        var elem = createButtonElement('link-icon', 'Link to this page');
	        var linkIcon = $(elem);
	
	        linkIcon.on('click', function ()
	        {
	            $('body').prepend(
	                elt('div', {
	                    id: settings.ID + 'link-popup',
	                    class: 'diva-popup diva-link-popup'
	                }, [
	                    elt('input', {
	                        id: settings.ID + 'link-popup-input',
	                        class: 'diva-input',
	                        type: 'text',
	                        value: viewer.getCurrentURL()
	                    })
	                ])
	            );
	
	            if (settings.inFullscreen)
	            {
	                $(settings.selector + 'link-popup').addClass('in-fullscreen');
	            }
	            else
	            {
	                // Calculate the left and top offsets
	                var leftOffset = linkIcon.offset().left - 222 + linkIcon.outerWidth();
	                var topOffset = linkIcon.offset().top + linkIcon.outerHeight() - 1;
	
	                $(settings.selector + 'link-popup').css({
	                    'top': topOffset + 'px',
	                    'left': leftOffset + 'px'
	                });
	            }
	
	            // Catch onmouseup events outside of this div
	            $('body').mouseup(function (event)
	            {
	                var targetID = event.target.id;
	
	                if (targetID !== settings.ID + 'link-popup' && targetID !== settings.ID + 'link-popup-input')
	                    $(settings.selector + 'link-popup').remove();
	            });
	
	            // Also delete it upon scroll and page up/down key events
	            // FIXME(wabain): This is aggressive
	            settings.viewportObject.scroll(function ()
	            {
	                $(settings.selector + 'link-popup').remove();
	            });
	            $(settings.selector + 'link-popup input').click(function ()
	            {
	                $(this).focus().select();
	            });
	
	            return false;
	        });
	
	        return elem;
	    };
	
	    var createFullscreenButton = function ()
	    {
	        return createButtonElement('fullscreen-icon', 'Toggle fullscreen mode', function ()
	        {
	            viewer.toggleFullscreenMode();
	        });
	    };
	
	    var createToggleNonPagedButton = function ()
	    {
	        var getClassName = function()
	        {
	            return 'toggle-nonpaged-icon' + (viewer.getSettings().showNonPagedPages ? '-active' : '');
	        };
	
	        var toggleNonPagedButton = createButtonElement(getClassName(), 'Toggle visibility of non-paged pages', function()
	        {
	            viewer.toggleNonPagedPagesVisibility();
	            var newClassName = 'diva-' + getClassName();
	            this.className = this.className.replace(/diva-toggle-nonpaged-icon(-active)?/, newClassName);
	        });
	
	        var updateNonPagedButtonVisibility = function ()
	        {
	            var pages = settings.manifest.pages;
	            for (var i = 0; i < pages.length; i++)
	            {
	                if (settings.manifest.paged && !pages[i].paged)
	                {
	                    // Show the button, there is at least one non-paged page
	                    toggleNonPagedButton.style.display = 'inline-block';
	                    return;
	                }
	            }
	
	            // No non-paged pages were found, hide the button
	            toggleNonPagedButton.style.display = 'none';
	        };
	        subscribe('ObjectDidLoad', updateNonPagedButtonVisibility);
	
	        return toggleNonPagedButton;
	    };
	
	    // Handles all status updating etc (both fullscreen and not)
	    var init = function ()
	    {
	        var leftTools = [createZoomControls(), createGridControls()];
	        var rightTools = [createPageNavigationControls(), createToolbarButtonGroup()];
	
	        var tools = elt('div', elemAttrs('tools'),
	            elt('div', elemAttrs('tools-left'), leftTools),
	            elt('div', elemAttrs('tools-right'), rightTools)
	        );
	
	        settings.toolbarParentObject.prepend(tools);
	
	        // Handle entry to and exit from fullscreen mode
	        var switchMode = function ()
	        {
	            var toolsRightElement = document.getElementById(settings.ID + 'tools-right');
	            var pageNavElement = document.getElementById(settings.ID + 'page-nav');
	
	            if (!settings.inFullscreen)
	            {
	                // Leaving fullscreen
	                $(tools).removeClass('diva-fullscreen-tools');
	
	                //move ID-page-nav to beginning of tools right
	                toolsRightElement.removeChild(pageNavElement);
	                toolsRightElement.insertBefore(pageNavElement, toolsRightElement.firstChild);
	            }
	            else
	            {
	                // Entering fullscreen
	                $(tools).addClass('diva-fullscreen-tools');
	
	                //move ID-page-nav to end of tools right
	                toolsRightElement.removeChild(pageNavElement);
	                toolsRightElement.appendChild(pageNavElement);
	            }
	        };
	
	        subscribe('ModeDidSwitch', switchMode);
	        subscribe('ViewerDidLoad', switchMode);
	
	        var toolbar = {
	            element: tools,
	            closePopups: function ()
	            {
	                $('.diva-popup').css('display', 'none');
	            }
	        };
	
	        return toolbar;
	    };
	
	    return init();
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	__webpack_require__(15);
	
	var elt = __webpack_require__(8);
	var getScrollbarWidth = __webpack_require__(16);
	
	var gestureEvents = __webpack_require__(17);
	var diva = __webpack_require__(2);
	var DocumentHandler = __webpack_require__(18);
	var GridHandler = __webpack_require__(25);
	var PageOverlayManager = __webpack_require__(26);
	var PluginRegistry = __webpack_require__(5);
	var Renderer = __webpack_require__(27);
	var getPageLayouts = __webpack_require__(36);
	var createSettingsView = __webpack_require__(41);
	var ValidationRunner = __webpack_require__(42);
	var Viewport = __webpack_require__(43);
	
	var debug = __webpack_require__(28)('diva:ViewerCore');
	
	module.exports = ViewerCore;
	
	// Define validations
	var optionsValidations = [
	    {
	        key: 'goDirectlyTo',
	        validate: function (value, settings)
	        {
	            if (value < 0 || value >= settings.manifest.pages.length)
	                return 0;
	        }
	    },
	    {
	        key: 'minPagesPerRow',
	        validate: function (value)
	        {
	            return Math.max(2, value);
	        }
	    },
	    {
	        key: 'maxPagesPerRow',
	        validate: function (value, settings)
	        {
	            return Math.max(value, settings.minPagesPerRow);
	        }
	    },
	    {
	        key: 'pagesPerRow',
	        validate: function (value, settings)
	        {
	            // Default to the maximum
	            if (value < settings.minPagesPerRow || value > settings.maxPagesPerRow)
	                return settings.maxPagesPerRow;
	        }
	    },
	    {
	        key: 'maxZoomLevel',
	        validate: function (value, settings, config)
	        {
	            // Changing this value isn't really an error, it just depends on the
	            // source manifest
	            config.suppressWarning();
	
	            if (value < 0 || value > settings.manifest.maxZoom)
	                return settings.manifest.maxZoom;
	        }
	    },
	    {
	        key: 'minZoomLevel',
	        validate: function (value, settings, config)
	        {
	            // Changes based on the manifest value shouldn't trigger a
	            // warning
	            if (value > settings.manifest.maxZoom)
	            {
	                config.suppressWarning();
	                return 0;
	            }
	
	            if (value < 0 || value > settings.maxZoomLevel)
	                return 0;
	        }
	    },
	    {
	        key: 'zoomLevel',
	        validate: function (value, settings, config)
	        {
	            if (value > settings.manifest.maxZoom)
	            {
	                config.suppressWarning();
	                return 0;
	            }
	
	            if (value < settings.minZoomLevel || value > settings.maxZoomLevel)
	                return settings.minZoomLevel;
	        }
	    }
	];
	
	function ViewerCore(element, options, publicInstance)
	{
	    var self = this;
	    var parentObject = $(element);
	
	    // Things that cannot be changed because of the way they are used by the script
	    // Many of these are declared with arbitrary values that are changed later on
	    var viewerState = {
	        currentPageIndex: 0,        // The current page in the viewport (center-most page)
	        horizontalOffset: 0,        // Distance from the center of the diva element to the top of the current page
	        horizontalPadding: 0,       // Either the fixed padding or adaptive padding
	        ID: null,                   // The prefix of the IDs of the elements (usually 1-diva-)
	        initialKeyScroll: false,    // Holds the initial state of enableKeyScroll
	        initialSpaceScroll: false,  // Holds the initial state of enableSpaceScroll
	        innerElement: null,         // The native .diva-outer DOM object
	        innerObject: {},            // $(settings.ID + 'inner'), for selecting the .diva-inner element
	        isActiveDiva: true,         // In the case that multiple diva panes exist on the same page, this should have events funneled to it.
	        isIIIF: false,              // Specifies whether objectData is in Diva native or IIIF Manifest format
	        isScrollable: true,         // Used in enable/disableScrollable public methods
	        isZooming: false,           // Flag to keep track of whether zooming is still in progress, for handleZoom
	        loaded: false,              // A flag for when everything is loaded and ready to go.
	        manifest: null,
	        mobileWebkit: false,        // Checks if the user is on a touch device (iPad/iPod/iPhone/Android)
	        numPages: 0,                // Number of pages in the array
	        oldZoomLevel: -1,           // Holds the previous zoom level after zooming in or out
	        options: options,
	        outerElement: null,         // The native .diva-outer DOM object
	        outerObject: {},            // $(settings.ID + 'outer'), for selecting the .diva-outer element
	        pageOverlays: new PageOverlayManager(),
	        pageTools: [],              // The plugins which are enabled as page tools
	        parentObject: parentObject, // JQuery object referencing the parent element
	        pendingManifestRequest: null, // Reference to the xhr request retrieving the manifest. Used to cancel the request on destroy()
	        plugins: [],                // Filled with the enabled plugins from the registry
	        renderer: null,
	        resizeTimer: -1,            // Holds the ID of the timeout used when resizing the window (for clearing)
	        scrollbarWidth: 0,          // Set to the actual scrollbar width in init()
	        selector: '',               // Uses the generated ID prefix to easily select elements
	        throbberTimeoutID: -1,      // Holds the ID of the throbber loading timeout
	        toolbar: null,              // Holds an object with some toolbar-related functions
	        verticalOffset: 0,          // Distance from the center of the diva element to the left side of the current page
	        verticalPadding: 0,         // Either the fixed padding or adaptive padding
	        viewHandler: null,
	        viewport: null,             // Object caching the viewport dimensions
	        viewportElement: null,
	        viewportObject: null
	    };
	
	    var settings = createSettingsView([options, viewerState]);
	
	    // Aliases for compatibilty
	    Object.defineProperties(settings, {
	        // Height of the document viewer pane
	        panelHeight: {
	            get: function ()
	            {
	                return viewerState.viewport.height;
	            }
	        },
	        // Width of the document viewer pane
	        panelWidth: {
	            get: function ()
	            {
	                return viewerState.viewport.width;
	            }
	        }
	    });
	
	    var optionsValidator = new ValidationRunner({
	        additionalProperties: [
	            {
	                key: 'manifest',
	                get: function ()
	                {
	                    return viewerState.manifest;
	                }
	            }
	        ],
	
	        validations: optionsValidations
	    });
	
	    var isValidOption = function (key, value)
	    {
	        return optionsValidator.isValid(key, value, viewerState.options);
	    };
	
	    var elemAttrs = function (ident, base)
	    {
	        var attrs = {
	            id: settings.ID + ident,
	            class: 'diva-' + ident
	        };
	
	        if (base)
	            return $.extend(attrs, base);
	        else
	            return attrs;
	    };
	
	    var getPageData = function (pageIndex, attribute)
	    {
	        return settings.manifest.pages[pageIndex].d[settings.zoomLevel][attribute];
	    };
	
	    // Reset some settings and empty the viewport
	    var clearViewer = function ()
	    {
	        viewerState.viewport.top = 0;
	
	        // Clear all the timeouts to prevent undesired pages from loading
	        clearTimeout(viewerState.resizeTimer);
	    };
	
	    /**
	     * Update settings to match the specified options. Load the viewer,
	     * fire appropriate events for changed options.
	     */
	    var reloadViewer = function (newOptions)
	    {
	        var queuedEvents = [];
	
	        newOptions = optionsValidator.getValidatedOptions(settings, newOptions);
	
	        // Set the zoom level if valid and fire a ZoomLevelDidChange event
	        if (hasChangedOption(newOptions, 'zoomLevel'))
	        {
	            viewerState.oldZoomLevel = settings.zoomLevel;
	            viewerState.options.zoomLevel = newOptions.zoomLevel;
	            queuedEvents.push(["ZoomLevelDidChange", newOptions.zoomLevel]);
	        }
	
	        // Set the pages per row if valid and fire an event
	        if (hasChangedOption(newOptions, 'pagesPerRow'))
	        {
	            viewerState.options.pagesPerRow = newOptions.pagesPerRow;
	            queuedEvents.push(["GridRowNumberDidChange", newOptions.pagesPerRow]);
	        }
	
	        // Update verticallyOriented (no event fired)
	        if (hasChangedOption(newOptions, 'verticallyOriented'))
	            viewerState.options.verticallyOriented = newOptions.verticallyOriented;
	
	        // Show/Hide non-paged pages
	        if (hasChangedOption(newOptions, 'showNonPagedPages'))
	        {
	            viewerState.options.showNonPagedPages = newOptions.showNonPagedPages;
	        }
	
	        // Update page position (no event fired here)
	        if ('goDirectlyTo' in newOptions)
	        {
	            viewerState.options.goDirectlyTo = newOptions.goDirectlyTo;
	
	            if ('verticalOffset' in newOptions)
	                viewerState.verticalOffset = newOptions.verticalOffset;
	
	            if ('horizontalOffset' in newOptions)
	                viewerState.horizontalOffset = newOptions.horizontalOffset;
	        }
	        else
	        {
	            // Otherwise the default is to remain on the current page
	            viewerState.options.goDirectlyTo = settings.currentPageIndex;
	        }
	
	        if (hasChangedOption(newOptions, 'inGrid') || hasChangedOption(newOptions, 'inBookLayout'))
	        {
	            if ('inGrid' in newOptions)
	                viewerState.options.inGrid = newOptions.inGrid;
	
	            if ('inBookLayout' in newOptions)
	                viewerState.options.inBookLayout = newOptions.inBookLayout;
	
	            queuedEvents.push(["ViewDidSwitch", settings.inGrid]);
	        }
	
	        // Note: prepareModeChange() depends on inGrid and the vertical/horizontalOffset (for now)
	        if (hasChangedOption(newOptions, 'inFullscreen'))
	        {
	            viewerState.options.inFullscreen = newOptions.inFullscreen;
	            prepareModeChange(newOptions);
	            queuedEvents.push(["ModeDidSwitch", settings.inFullscreen]);
	        }
	
	        clearViewer();
	        updateViewHandlerAndRendering();
	
	        if (viewerState.renderer)
	        {
	            // TODO: The usage of padding variables is still really
	            // messy and inconsistent
	            var rendererConfig = {
	                pageLayouts: getPageLayouts(settings),
	                padding: getPadding(),
	                maxZoomLevel: settings.inGrid ? null : viewerState.manifest.maxZoom,
	                verticallyOriented: settings.verticallyOriented || settings.inGrid,
	            };
	
	            var viewportPosition = {
	                zoomLevel: settings.inGrid ? null : settings.zoomLevel,
	                anchorPage: settings.goDirectlyTo,
	                verticalOffset: viewerState.verticalOffset,
	                horizontalOffset: viewerState.horizontalOffset
	            };
	
	            var sourceProvider = getCurrentSourceProvider();
	
	            if (debug.enabled)
	            {
	                var serialized = Object.keys(rendererConfig)
	                    .filter(function (key)
	                    {
	                        // Too long
	                        return key !== 'pageLayouts' && key !== 'padding';
	                    })
	                    .map(function (key)
	                    {
	                        var value = rendererConfig[key];
	                        return key + ': ' + JSON.stringify(value);
	                    })
	                    .join(', ');
	
	                debug('reload with %s', serialized);
	            }
	
	            viewerState.renderer.load(rendererConfig, viewportPosition, sourceProvider);
	        }
	
	        queuedEvents.forEach(function (params)
	        {
	            publish.apply(null, params);
	        });
	
	        return true;
	    };
	
	    var hasChangedOption = function (options, key)
	    {
	        return key in options && options[key] !== settings[key];
	    };
	
	    // Handles switching in and out of fullscreen mode
	    var prepareModeChange = function (options)
	    {
	        // Toggle the classes
	        var changeClass = options.inFullscreen ? 'addClass' : 'removeClass';
	        viewerState.outerObject[changeClass]('diva-fullscreen');
	        $('body')[changeClass]('diva-hide-scrollbar');
	        settings.parentObject[changeClass]('diva-full-width');
	
	        // Adjust Diva's internal panel size, keeping the old values
	        var storedHeight = settings.panelHeight;
	        var storedWidth = settings.panelWidth;
	        viewerState.viewport.invalidate();
	
	        // If this isn't the original load, the offsets matter, and the position isn't being changed...
	        if (!viewerState.loaded && !settings.inGrid && !('verticalOffset' in options))
	        {
	            //get the updated panel size
	            var newHeight = settings.panelHeight;
	            var newWidth = settings.panelWidth;
	
	            //and re-center the new panel on the same point
	            viewerState.verticalOffset += ((storedHeight - newHeight) / 2);
	            viewerState.horizontalOffset += ((storedWidth - newWidth) / 2);
	        }
	
	        //turn on/off escape key listener
	        if (options.inFullscreen)
	            $(document).on('keyup', escapeListener);
	        else
	            $(document).off('keyup', escapeListener);
	    };
	
	    // Update the view handler and the view rendering for the current view
	    var updateViewHandlerAndRendering = function ()
	    {
	        var Handler = settings.inGrid ? GridHandler : DocumentHandler;
	
	        if (viewerState.viewHandler && !(viewerState.viewHandler instanceof Handler))
	        {
	            viewerState.viewHandler.destroy();
	            viewerState.viewHandler = null;
	        }
	
	        if (!viewerState.viewHandler)
	            viewerState.viewHandler = new Handler(self);
	
	        if (!viewerState.renderer)
	            initializeRenderer();
	    };
	
	    // TODO: This could probably be done upon ViewerCore initialization
	    var initializeRenderer = function ()
	    {
	        var compatErrors = Renderer.getCompatibilityErrors();
	
	        if (compatErrors)
	        {
	            showError(compatErrors);
	        }
	        else
	        {
	            var options = {
	                viewport: viewerState.viewport,
	                outerElement: viewerState.outerElement,
	                innerElement: viewerState.innerElement
	            };
	
	            var hooks = {
	                onViewWillLoad: function ()
	                {
	                    viewerState.viewHandler.onViewWillLoad();
	                },
	                onViewDidLoad: function ()
	                {
	                    updatePageOverlays();
	                    viewerState.viewHandler.onViewDidLoad();
	                },
	                onViewDidUpdate: function (pages, targetPage)
	                {
	                    updatePageOverlays();
	                    viewerState.viewHandler.onViewDidUpdate(pages, targetPage);
	                },
	                onViewDidTransition: function ()
	                {
	                    updatePageOverlays();
	                },
	                onPageWillLoad: function (pageIndex)
	                {
	                    publish('PageWillLoad', pageIndex);
	                }
	            };
	
	            viewerState.renderer = new Renderer(options, hooks);
	        }
	    };
	
	    var getCurrentSourceProvider = function ()
	    {
	        if (settings.inGrid)
	        {
	            var gridSourceProvider = {
	                getAllZoomLevelsForPage: function (page)
	                {
	                    return [gridSourceProvider.getBestZoomLevelForPage(page)];
	                },
	                getBestZoomLevelForPage: function (page)
	                {
	                    var url = settings.manifest.getPageImageURL(page.index, {
	                        width: page.dimensions.width
	                    });
	
	                    return {
	                        zoomLevel: 1, // FIXME
	                        rows: 1,
	                        cols: 1,
	                        tiles: [{
	                            url: url,
	                            zoomLevel: 1, // FIXME
	                            row: 0,
	                            col: 0,
	                            dimensions: page.dimensions,
	                            offset: {
	                                top: 0,
	                                left: 0
	                            }
	                        }]
	                    };
	                }
	            };
	
	            return gridSourceProvider;
	        }
	
	        var tileDimens = {
	            width: settings.tileWidth,
	            height: settings.tileHeight
	        };
	
	        return {
	            getBestZoomLevelForPage: function (page)
	            {
	                return settings.manifest.getPageImageTiles(page.index, Math.ceil(settings.zoomLevel), tileDimens);
	            },
	            getAllZoomLevelsForPage: function (page)
	            {
	                var levels = [];
	
	                var levelCount = viewerState.manifest.maxZoom;
	                for (var level=0; level <= levelCount; level++)
	                {
	                    levels.push(settings.manifest.getPageImageTiles(page.index, level, tileDimens));
	                }
	
	                levels.reverse();
	
	                return levels;
	            }
	        };
	    };
	
	    var getPadding = function ()
	    {
	        var topPadding, leftPadding;
	        var docVPadding, docHPadding;
	
	        if (settings.inGrid)
	        {
	            docVPadding = settings.fixedPadding;
	            topPadding = leftPadding = docHPadding = 0;
	        }
	        else
	        {
	            topPadding = settings.verticallyOriented ? viewerState.verticalPadding : 0;
	            leftPadding = settings.verticallyOriented ? 0 : viewerState.horizontalPadding;
	
	            docVPadding = settings.verticallyOriented ? 0 : viewerState.verticalPadding;
	            docHPadding = settings.verticallyOriented ? viewerState.horizontalPadding : 0;
	        }
	
	        return {
	            document: {
	                top: docVPadding,
	                bottom: docVPadding,
	                left: docHPadding,
	                right: docHPadding
	            },
	            page: {
	                top: topPadding,
	                bottom: 0,
	                left: leftPadding,
	                right: 0
	            }
	        };
	    };
	
	    var updatePageOverlays = function ()
	    {
	        viewerState.pageOverlays.updateOverlays(viewerState.renderer.getRenderedPages());
	    };
	
	    //Shortcut for closing fullscreen with the escape key
	    var escapeListener = function (e)
	    {
	        if (e.keyCode == 27)
	        {
	            reloadViewer({
	                inFullscreen: !settings.inFullscreen
	            });
	        }
	    };
	
	    // Called to handle any zoom level
	    var handleZoom = function (newZoomLevel, focalPoint)
	    {
	        // If the zoom level provided is invalid, return false
	        if (!isValidOption('zoomLevel', newZoomLevel))
	            return false;
	
	        // If no focal point was given, zoom on the center of the viewport
	        if (focalPoint == null)
	        {
	            var viewport = viewerState.viewport;
	            var currentRegion = viewerState.renderer.layout.getPageRegion(settings.currentPageIndex);
	
	            focalPoint = {
	                anchorPage: settings.currentPageIndex,
	                offset: {
	                    left: (viewport.width / 2) - (currentRegion.left - viewport.left),
	                    top: (viewport.height / 2) - (currentRegion.top - viewport.top)
	                }
	            };
	        }
	
	        var pageRegion = viewerState.renderer.layout.getPageRegion(focalPoint.anchorPage);
	
	        // calculate distance from cursor coordinates to center of viewport
	        var focalXToCenter = (pageRegion.left + focalPoint.offset.left) -
	            (settings.viewport.left + (settings.viewport.width / 2));
	        var focalYToCenter = (pageRegion.top + focalPoint.offset.top) -
	            (settings.viewport.top + (settings.viewport.height / 2));
	
	        function getPositionForZoomLevel(zoomLevel)
	        {
	            var zoomRatio = Math.pow(2, zoomLevel - initialZoomLevel);
	
	            //TODO(jeromepl): Calculate position from page top left to viewport top left
	            // calculate horizontal/verticalOffset: distance from viewport center to page upper left corner
	            var horizontalOffset = (focalPoint.offset.left * zoomRatio) - focalXToCenter;
	            var verticalOffset = (focalPoint.offset.top * zoomRatio) - focalYToCenter;
	
	            return {
	                zoomLevel: zoomLevel,
	                anchorPage: focalPoint.anchorPage,
	                verticalOffset: verticalOffset,
	                horizontalOffset: horizontalOffset
	            };
	        }
	
	        var initialZoomLevel = viewerState.oldZoomLevel = settings.zoomLevel;
	        viewerState.options.zoomLevel = newZoomLevel;
	
	        var endPosition = getPositionForZoomLevel(newZoomLevel);
	        viewerState.options.goDirectlyTo = endPosition.anchorPage;
	        viewerState.verticalOffset = endPosition.verticalOffset;
	        viewerState.horizontalOffset = endPosition.horizontalOffset;
	
	        viewerState.renderer.transitionViewportPosition({
	            duration: 300,
	            parameters: {
	                zoomLevel: {
	                    from: initialZoomLevel,
	                    to: newZoomLevel
	                }
	            },
	            getPosition: function (parameters)
	            {
	                return getPositionForZoomLevel(parameters.zoomLevel);
	            },
	            onEnd: function (info)
	            {
	                viewerState.viewportObject.scroll(scrollFunction);
	
	                if (info.interrupted)
	                    viewerState.oldZoomLevel = newZoomLevel;
	            }
	        });
	
	        // Update the slider
	        publish("ZoomLevelDidChange", newZoomLevel);
	
	        // While zooming, don't update scroll offsets based on the scaled version of diva-inner
	        viewerState.viewportObject.off('scroll');
	
	        return true;
	    };
	
	    /*
	     Gets the Y-offset for a specific point on a specific page
	     Acceptable values for "anchor":
	     "top" (default) - will anchor top of the page to the top of the diva-outer element
	     "bottom" - top, s/top/bottom
	     "center" - will center the page on the diva element
	     Returned value will be the distance from the center of the diva-outer element to the top of the current page for the specified anchor
	     */
	    var getYOffset = function (pageIndex, anchor)
	    {
	        pageIndex = (typeof(pageIndex) === "undefined" ? settings.currentPageIndex : pageIndex);
	
	        if (anchor === "center" || anchor === "centre") //how you can tell an American coded this
	        {
	            return parseInt(getPageData(pageIndex, "h") / 2, 10);
	        }
	        else if (anchor === "bottom")
	        {
	            return parseInt(getPageData(pageIndex, "h") - settings.panelHeight / 2, 10);
	        }
	        else
	        {
	            return parseInt(settings.panelHeight / 2, 10);
	        }
	    };
	
	    //Same as getYOffset with "left" and "right" as acceptable values instead of "top" and "bottom"
	    var getXOffset = function (pageIndex, anchor)
	    {
	        pageIndex = (typeof(pageIndex) === "undefined" ? settings.currentPageIndex : pageIndex);
	
	        if (anchor === "left")
	        {
	            return parseInt(settings.panelWidth / 2, 10);
	        }
	        else if (anchor === "right")
	        {
	            return parseInt(getPageData(pageIndex, "w") - settings.panelWidth / 2, 10);
	        }
	        else
	        {
	            return parseInt(getPageData(pageIndex, "w") / 2, 10);
	        }
	    };
	
	    // updates panelHeight/panelWidth on resize
	    var updatePanelSize = function ()
	    {
	        viewerState.viewport.invalidate();
	
	        // FIXME(wabain): This should really only be called after initial load
	        if (viewerState.renderer)
	        {
	            updateOffsets();
	            viewerState.renderer.goto(settings.currentPageIndex, viewerState.verticalOffset, viewerState.horizontalOffset);
	        }
	
	        return true;
	    };
	
	    var updateOffsets = function ()
	    {
	        var pageOffset = viewerState.renderer.layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	        if (pageOffset)
	        {
	            viewerState.horizontalOffset = pageOffset.x;
	            viewerState.verticalOffset = pageOffset.y;
	        }
	    };
	
	    // Bind mouse events (drag to scroll, double-click)
	    var bindMouseEvents = function()
	    {
	        // Set drag scroll on first descendant of class dragger on both selected elements
	        viewerState.viewportObject.dragscrollable({dragSelector: '.diva-dragger', acceptPropagatedEvent: true});
	        viewerState.innerObject.dragscrollable({dragSelector: '.diva-dragger', acceptPropagatedEvent: true});
	
	        gestureEvents.onDoubleClick(viewerState.viewportObject, function (event, coords)
	        {
	            debug('Double click at %s, %s', coords.left, coords.top);
	            viewerState.viewHandler.onDoubleClick(event, coords);
	        });
	    };
	
	    var onResize = function()
	    {
	        updatePanelSize();
	        // Cancel any previously-set resize timeouts
	        clearTimeout(viewerState.resizeTimer);
	
	        viewerState.resizeTimer = setTimeout(function ()
	        {
	            var pageOffset = viewerState.renderer.layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	            if (pageOffset)
	            {
	                reloadViewer({
	                    goDirectlyTo: settings.currentPageIndex,
	                    verticalOffset: pageOffset.y,
	                    horizontalOffset: pageOffset.x
	                });
	            }
	            else
	            {
	                reloadViewer({
	                    goDirectlyTo: settings.currentPageIndex
	                });
	            }
	        }, 200);
	    };
	
	    // Bind touch and orientation change events
	    var bindTouchEvents = function()
	    {
	        // Block the user from moving the window only if it's not integrated
	        if (settings.blockMobileMove)
	        {
	            $('body').bind('touchmove', function (event)
	            {
	                var e = event.originalEvent;
	                e.preventDefault();
	
	                return false;
	            });
	        }
	
	        // Touch events for swiping in the viewport to scroll pages
	        viewerState.viewportObject.kinetic({
	            triggerHardware: true
	        });
	
	        gestureEvents.onPinch(viewerState.viewportObject, function (event, coords, start, end)
	        {
	            debug('Pinch %s at %s, %s', end - start, coords.left, coords.top);
	            viewerState.viewHandler.onPinch(event, coords, start, end);
	        });
	
	        gestureEvents.onDoubleTap(viewerState.viewportObject, function (event, coords)
	        {
	            debug('Double tap at %s, %s', coords.left, coords.top);
	            viewerState.viewHandler.onDoubleClick(event, coords);
	        });
	    };
	
	    // Handle the scroll
	    var scrollFunction = function ()
	    {
	        var previousTopScroll = viewerState.viewport.top;
	        var previousLeftScroll = viewerState.viewport.left;
	
	        var direction;
	
	        viewerState.viewport.invalidate();
	
	        var newScrollTop = viewerState.viewport.top;
	        var newScrollLeft = viewerState.viewport.left;
	
	        if (settings.verticallyOriented || settings.inGrid)
	            direction = newScrollTop - previousTopScroll;
	        else
	            direction = newScrollLeft - previousLeftScroll;
	
	        //give adjust the direction we care about
	        viewerState.renderer.adjust(direction);
	
	        var primaryScroll = (settings.verticallyOriented || settings.inGrid) ? newScrollTop : newScrollLeft;
	
	        publish("ViewerDidScroll", primaryScroll);
	
	        if (direction > 0)
	        {
	            publish("ViewerDidScrollDown", primaryScroll);
	        }
	        else if (direction < 0)
	        {
	            publish("ViewerDidScrollUp", primaryScroll);
	        }
	
	        updateOffsets();
	    };
	
	    // Binds most of the event handlers (some more in createToolbar)
	    var handleEvents = function ()
	    {
	        // Change the cursor for dragging
	        viewerState.innerObject.mousedown(function ()
	        {
	            viewerState.innerObject.addClass('diva-grabbing');
	        });
	
	        viewerState.innerObject.mouseup(function ()
	        {
	            viewerState.innerObject.removeClass('diva-grabbing');
	        });
	
	        bindMouseEvents();
	
	        viewerState.viewportObject.scroll(scrollFunction);
	
	        var upArrowKey = 38,
	            downArrowKey = 40,
	            leftArrowKey = 37,
	            rightArrowKey = 39,
	            spaceKey = 32,
	            pageUpKey = 33,
	            pageDownKey = 34,
	            homeKey = 36,
	            endKey = 35;
	
	        // Catch the key presses in document
	        $(document).on('keydown.diva', function (event)
	        {
	            if (!viewerState.isActiveDiva)
	                return true;
	
	            // Space or page down - go to the next page
	            if ((settings.enableSpaceScroll && !event.shiftKey && event.keyCode === spaceKey) || (settings.enableKeyScroll && event.keyCode === pageDownKey))
	            {
	                viewerState.viewport.top += settings.panelHeight;
	                return false;
	            }
	            else if (!settings.enableSpaceScroll && event.keyCode === spaceKey)
	            {
	                event.preventDefault();
	            }
	
	            if (settings.enableKeyScroll)
	            {
	                // Don't steal keyboard shortcuts (metaKey = command [OS X], super [Win/Linux])
	                if (event.shiftKey || event.ctrlKey || event.metaKey)
	                    return true;
	
	                switch (event.keyCode)
	                {
	                    case pageUpKey:
	                        // Page up - go to the previous page
	                        viewerState.viewport.top -= settings.panelHeight;
	                        return false;
	
	                    case upArrowKey:
	                        // Up arrow - scroll up
	                        viewerState.viewport.top -= settings.arrowScrollAmount;
	                        return false;
	
	                    case downArrowKey:
	                        // Down arrow - scroll down
	                        viewerState.viewport.top += settings.arrowScrollAmount;
	                        return false;
	
	                    case leftArrowKey:
	                        // Left arrow - scroll left
	                        viewerState.viewport.left -= settings.arrowScrollAmount;
	                        return false;
	
	                    case rightArrowKey:
	                        // Right arrow - scroll right
	                        viewerState.viewport.left += settings.arrowScrollAmount;
	                        return false;
	
	                    case homeKey:
	                        // Home key - go to the beginning of the document
	                        viewerState.viewport.top = 0;
	                        return false;
	
	                    case endKey:
	                        // End key - go to the end of the document
	                        // Count on the viewport coordinate value being normalized
	                        if (settings.verticallyOriented)
	                            viewerState.viewport.top = Infinity;
	                        else
	                            viewerState.viewport.left = Infinity;
	
	                        return false;
	
	                    default:
	                        return true;
	                }
	            }
	            return true;
	        });
	
	        diva.Events.subscribe('ViewerDidTerminate', function()
	        {
	            $(document).off('keydown.diva');
	        }, settings.ID);
	
	        bindTouchEvents();
	
	        // Handle window resizing events
	        window.addEventListener('resize', onResize, false);
	
	        diva.Events.subscribe('ViewerDidTerminate', function()
	        {
	            window.removeEventListener('resize', onResize, false);
	        }, settings.ID);
	
	        // Handle orientation change separately
	        if ('onorientationchange' in window)
	        {
	            window.addEventListener('orientationchange', onResize, false);
	
	            diva.Events.subscribe('ViewerDidTerminate', function()
	            {
	                window.removeEventListener('orientationchange', onResize, false);
	            }, settings.ID);
	        }
	
	        diva.Events.subscribe('PanelSizeDidChange', updatePanelSize, settings.ID);
	
	        // Clear page and resize timeouts when the viewer is destroyed
	        diva.Events.subscribe('ViewerDidTerminate', function ()
	        {
	            if (viewerState.renderer)
	                viewerState.renderer.destroy();
	
	            clearTimeout(viewerState.resizeTimer);
	        }, settings.ID);
	    };
	
	    var initPlugins = function ()
	    {
	        // Add all the plugins that have not been explicitly disabled to
	        // settings.plugins
	        PluginRegistry.getAll().forEach(function (plugin)
	        {
	            var pluginProperName = plugin.pluginName[0].toUpperCase() + plugin.pluginName.substring(1);
	
	            if (settings['enable' + pluginProperName])
	            {
	                // Call the init function and check return value
	                var enablePlugin = plugin.init(settings, publicInstance);
	
	                // If int returns false, consider the plugin disabled
	                if (!enablePlugin)
	                    return;
	
	                // Create the pageTools bar if handleClick is set to a function
	                if (typeof plugin.handleClick === 'function')
	                {
	                    viewerState.pageTools.push(plugin);
	                }
	
	                // Add it to settings.plugins so it can be used later
	                settings.plugins.push(plugin);
	            }
	        });
	    };
	
	    var showThrobber = function ()
	    {
	        hideThrobber();
	
	        viewerState.throbberTimeoutID = setTimeout(function ()
	        {
	            $(settings.selector + 'throbber').show();
	        }, settings.throbberTimeout);
	    };
	
	    var hideThrobber = function ()
	    {
	        // Clear the timeout, if it hasn't executed yet
	        clearTimeout(viewerState.throbberTimeoutID);
	
	        // Hide the throbber if it has already executed
	        $(settings.selector + 'throbber').hide();
	    };
	
	    var showError = function(message)
	    {
	        var errorElement = elt('div', elemAttrs('error'), [
	            elt('button', elemAttrs('error-close', {'aria-label': 'Close dialog'})),
	            elt('p',
	                elt('strong', 'Error')
	            ),
	            elt('div', message)
	        ]);
	
	        viewerState.outerObject.append(errorElement);
	
	        //bind dialog close button
	        $(settings.selector + 'error-close').on('click', function()
	        {
	            errorElement.parentNode.removeChild(errorElement);
	        });
	    };
	
	    var setManifest = function (manifest, isIIIF, loadOptions)
	    {
	        viewerState.manifest = manifest;
	
	        // FIXME: is isIIIF even needed?
	        viewerState.isIIIF = isIIIF;
	
	        hideThrobber();
	
	        // Convenience value
	        viewerState.numPages = settings.manifest.pages.length;
	
	        optionsValidator.validate(viewerState.options);
	
	        publish('NumberOfPagesDidChange', settings.numPages);
	
	        if (settings.enableAutoTitle)
	        {
	            if ($(settings.selector + 'title').length)
	                $(settings.selector + 'title').html(settings.manifest.itemTitle);
	            else
	                settings.parentObject.prepend(elt('div', elemAttrs('title'), [settings.manifest.itemTitle]));
	        }
	
	        // Calculate the horizontal and vertical inter-page padding based on the dimensions of the average zoom level
	        if (settings.adaptivePadding > 0)
	        {
	            var z = Math.floor((settings.minZoomLevel + settings.maxZoomLevel) / 2);
	            viewerState.horizontalPadding = parseInt(settings.manifest.getAverageWidth(z) * settings.adaptivePadding, 10);
	            viewerState.verticalPadding = parseInt(settings.manifest.getAverageHeight(z) * settings.adaptivePadding, 10);
	        }
	        else
	        {
	            // It's less than or equal to 0; use fixedPadding instead
	            viewerState.horizontalPadding = settings.fixedPadding;
	            viewerState.verticalPadding = settings.fixedPadding;
	        }
	
	        // Make sure the vertical padding is at least 40, if plugin icons are enabled
	        if (viewerState.pageTools.length)
	        {
	            viewerState.verticalPadding = Math.max(40, viewerState.verticalPadding);
	        }
	
	        // If we detect a viewingHint of 'paged' in the manifest or sequence, enable book view by default
	        if (settings.manifest.paged)
	        {
	            viewerState.options.inBookLayout = true;
	        }
	
	        // Plugin setup hooks should be bound to the ObjectDidLoad event
	        publish('ObjectDidLoad', settings);
	
	        // Adjust the document panel dimensions
	        updatePanelSize();
	
	        var needsXCoord, needsYCoord;
	
	        var anchoredVertically = false;
	        var anchoredHorizontally = false;
	
	        if (loadOptions.goDirectlyTo == null)
	        {
	            loadOptions.goDirectlyTo = settings.goDirectlyTo;
	            needsXCoord = needsYCoord = true;
	        }
	        else
	        {
	            needsXCoord = loadOptions.horizontalOffset == null || isNaN(loadOptions.horizontalOffset);
	            needsYCoord = loadOptions.verticalOffset == null || isNaN(loadOptions.verticalOffset);
	        }
	
	        // Set default values for the horizontal and vertical offsets
	        if (needsXCoord)
	        {
	            // FIXME: What if inBookLayout/verticallyOriented is changed by loadOptions?
	            if (loadOptions.goDirectlyTo === 0 && settings.inBookLayout && settings.verticallyOriented)
	            {
	                // if in book layout, center the first opening by default
	                loadOptions.horizontalOffset = viewerState.horizontalPadding;
	            }
	            else
	            {
	                anchoredHorizontally = true;
	                loadOptions.horizontalOffset = getXOffset(loadOptions.goDirectlyTo, "center");
	            }
	        }
	
	        if (needsYCoord)
	        {
	            anchoredVertically = true;
	            loadOptions.verticalOffset = getYOffset(loadOptions.goDirectlyTo, "top");
	        }
	
	        reloadViewer(loadOptions);
	
	        //prep dimensions one last time now that pages have loaded
	        updatePanelSize();
	
	        // FIXME: This is a hack to ensure that the outerElement scrollbars are taken into account
	        if (settings.verticallyOriented)
	            viewerState.innerElement.style.minWidth = settings.panelWidth + 'px';
	        else
	            viewerState.innerElement.style.minHeight = settings.panelHeight + 'px';
	
	        // FIXME: If the page was supposed to be positioned relative to the viewport we need to
	        // recalculate it to take into account the scrollbars
	        if (anchoredVertically || anchoredHorizontally)
	        {
	            if (anchoredVertically)
	                viewerState.verticalOffset = getYOffset(settings.currentPageIndex, "top");
	
	            if (anchoredHorizontally)
	                viewerState.horizontalOffset = getXOffset(settings.currentPageIndex, "center");
	
	            viewerState.renderer.goto(settings.currentPageIndex, viewerState.verticalOffset, viewerState.horizontalOffset);
	        }
	
	        // signal that everything should be set up and ready to go.
	        viewerState.loaded = true;
	
	        publish("ViewerDidLoad", settings);
	    };
	
	    var publish = function (event)
	    {
	        var args = Array.prototype.slice.call(arguments, 1);
	        diva.Events.publish(event, args, publicInstance);
	    };
	
	    var init = function ()
	    {
	        // First figure out the width of the scrollbar in this browser
	        // TODO(wabain): Cache this somewhere else
	        // Only some of the plugins rely on this now
	        viewerState.scrollbarWidth = getScrollbarWidth();
	
	        // If window.orientation is defined, then it's probably mobileWebkit
	        viewerState.mobileWebkit = window.orientation !== undefined;
	
	        // Generate an ID that can be used as a prefix for all the other IDs
	        var idNumber = generateId();
	        viewerState.ID = 'diva-' + idNumber + '-';
	        viewerState.selector = '#' + settings.ID;
	
	        if (options.hashParamSuffix === null)
	        {
	            // Omit the suffix from the first instance
	            if (idNumber === 1)
	                options.hashParamSuffix = '';
	            else
	                options.hashParamSuffix = idNumber + '';
	        }
	
	        // Create the inner and outer panels
	        var innerElem = elt('div', elemAttrs('inner', { class: 'diva-inner diva-dragger' }));
	        var viewportElem = elt('div', elemAttrs('viewport'), innerElem);
	        var outerElem = elt('div', elemAttrs('outer'),
	            viewportElem,
	            elt('div', elemAttrs('throbber')));
	
	        viewerState.innerElement = innerElem;
	        viewerState.viewportElement = viewportElem;
	        viewerState.outerElement = outerElem;
	
	        viewerState.innerObject = $(innerElem);
	        viewerState.viewportObject = $(viewportElem);
	        viewerState.outerObject = $(outerElem);
	
	        settings.parentObject.append(outerElem);
	
	        viewerState.viewport = new Viewport(viewerState.viewportElement, {
	            intersectionTolerance: settings.viewportMargin
	        });
	
	        // Do all the plugin initialisation
	        initPlugins();
	
	        handleEvents();
	
	        // Show the throbber while waiting for the manifest to load
	        showThrobber();
	    };
	
	    this.getSettings = function ()
	    {
	        return settings;
	    };
	
	    // Temporary accessor for the state of the viewer core
	    // TODO: Replace this with a more restricted view of whatever needs
	    // be exposed through settings for backwards compat
	    this.getInternalState = function ()
	    {
	        return viewerState;
	    };
	
	    this.getPublicInstance = function ()
	    {
	        return publicInstance;
	    };
	
	    this.getPageTools = function ()
	    {
	        return viewerState.pageTools;
	    };
	
	    this.getCurrentLayout = function ()
	    {
	        return viewerState.renderer ? viewerState.renderer.layout : null;
	    };
	
	    /** Get a copy of the current viewport dimensions */
	    this.getViewport = function ()
	    {
	        var viewport = viewerState.viewport;
	
	        return {
	            top: viewport.top,
	            left: viewport.left,
	            bottom: viewport.bottom,
	            right: viewport.right,
	
	            width: viewport.width,
	            height: viewport.height
	        };
	    };
	
	    this.addPageOverlay = function (overlay)
	    {
	        viewerState.pageOverlays.addOverlay(overlay);
	    };
	
	    this.removePageOverlay = function (overlay)
	    {
	        viewerState.pageOverlays.removeOverlay(overlay);
	    };
	
	    this.getPageRegion = function (pageIndex, options)
	    {
	        var layout = viewerState.renderer.layout;
	        var region = layout.getPageRegion(pageIndex, options);
	
	        if (options && options.incorporateViewport)
	        {
	            var secondaryDim = settings.verticallyOriented ? 'width' : 'height';
	
	            if (viewerState.viewport[secondaryDim] > layout.dimensions[secondaryDim])
	            {
	                var docOffset = (viewerState.viewport[secondaryDim] - layout.dimensions[secondaryDim]) / 2;
	
	                if (settings.verticallyOriented)
	                {
	                    return {
	                        top: region.top,
	                        bottom: region.bottom,
	
	                        left: region.left + docOffset,
	                        right: region.right + docOffset
	                    };
	                }
	                else
	                {
	                    return {
	                        top: region.top + docOffset,
	                        bottom: region.bottom + docOffset,
	
	                        left: region.left,
	                        right: region.right
	                    };
	                }
	            }
	        }
	
	        return region;
	    };
	
	    this.getPagePositionAtViewportOffset = function (coords)
	    {
	        var docCoords = {
	            left: coords.left + viewerState.viewport.left,
	            top: coords.top + viewerState.viewport.top
	        };
	
	        var renderedPages = viewerState.renderer.getRenderedPages();
	        var pageCount = renderedPages.length;
	
	        // Find the page on which the coords occur
	        for (var i=0; i < pageCount; i++)
	        {
	            var pageIndex = renderedPages[i];
	            var region = viewerState.renderer.layout.getPageRegion(pageIndex);
	
	            if (region.left <= docCoords.left && region.right >= docCoords.left &&
	                region.top <= docCoords.top && region.bottom >= docCoords.top)
	            {
	                return {
	                    anchorPage: pageIndex,
	                    offset: {
	                        left: docCoords.left - region.left,
	                        top: docCoords.top - region.top
	                    }
	                };
	            }
	        }
	
	        // Fall back to current page
	        // FIXME: Would be better to use the closest page or something
	        var currentRegion = viewerState.renderer.layout.getPageRegion(settings.currentPageIndex);
	
	        return {
	            anchorPage: settings.currentPageIndex,
	            offset: {
	                left: docCoords.left - currentRegion.left,
	                top: docCoords.top - currentRegion.top
	            }
	        };
	    };
	
	    this.setManifest = function (manifest, isIIIF, loadOptions)
	    {
	        setManifest(manifest, isIIIF, loadOptions || {});
	    };
	
	    /**
	     * Set the current page to the given index, firing VisiblePageDidChange
	     *
	     * @param pageIndex
	     */
	    this.setCurrentPage = function (pageIndex)
	    {
	        if (viewerState.currentPageIndex !== pageIndex)
	        {
	            viewerState.currentPageIndex = pageIndex;
	            publish("VisiblePageDidChange", pageIndex, this.getPageName(pageIndex));
	        }
	    };
	
	    this.getPageName = function (pageIndex)
	    {
	        return viewerState.manifest.pages[pageIndex].f;
	    };
	
	    this.reload = function (newOptions)
	    {
	        reloadViewer(newOptions);
	    };
	
	    this.zoom = function (zoomLevel, focalPoint)
	    {
	        return handleZoom(zoomLevel, focalPoint);
	    };
	
	    this.enableScrollable = function ()
	    {
	        if (!viewerState.isScrollable)
	        {
	            bindMouseEvents();
	            viewerState.options.enableKeyScroll = viewerState.initialKeyScroll;
	            viewerState.options.enableSpaceScroll = viewerState.initialSpaceScroll;
	            viewerState.viewportElement.style.overflow = 'auto';
	            viewerState.isScrollable = true;
	        }
	    };
	
	    this.disableScrollable = function ()
	    {
	        if (viewerState.isScrollable)
	        {
	            // block dragging/double-click zooming
	            if (viewerState.innerObject.hasClass('diva-dragger'))
	                viewerState.innerObject.unbind('mousedown');
	            viewerState.outerObject.unbind('dblclick');
	            viewerState.outerObject.unbind('contextmenu');
	
	            // disable all other scrolling actions
	            viewerState.viewportElement.style.overflow = 'hidden';
	
	            // block scrolling keys behavior, respecting initial scroll settings
	            viewerState.initialKeyScroll = settings.enableKeyScroll;
	            viewerState.initialSpaceScroll = settings.enableSpaceScroll;
	            viewerState.options.enableKeyScroll = false;
	            viewerState.options.enableSpaceScroll = false;
	
	            viewerState.isScrollable = false;
	        }
	    };
	
	    this.isValidOption = function (key, value)
	    {
	        return isValidOption(key, value);
	    };
	
	    this.showError = function (message)
	    {
	        // FIXME: Not totally sure it makes sense to always do that here
	        hideThrobber();
	
	        var errorElement = elt('div', elemAttrs('error'), [
	            elt('button', elemAttrs('error-close', {'aria-label': 'Close dialog'})),
	            elt('p',
	                elt('strong', 'Error')
	            ),
	            elt('div', message)
	        ]);
	
	        viewerState.outerObject.append(errorElement);
	
	        //bind dialog close button
	        $(settings.selector + 'error-close').on('click', function()
	        {
	            errorElement.parentNode.removeChild(errorElement);
	        });
	    };
	
	    this.getXOffset = function (pageIndex, xAnchor)
	    {
	        return getXOffset(pageIndex, xAnchor);
	    };
	
	    this.getYOffset = function (pageIndex, yAnchor)
	    {
	        return getYOffset(pageIndex, yAnchor);
	    };
	
	    this.publish = publish;
	
	    this.clear = function ()
	    {
	        clearViewer();
	    };
	
	    this.setPendingManifestRequest = function (pendingManifestRequest)
	    {
	        viewerState.pendingManifestRequest = pendingManifestRequest;
	    };
	
	    // Destroys this instance, tells plugins to do the same (for testing)
	    this.destroy = function ()
	    {
	        // Useful event to access elements in diva before they get destroyed. Used by the highlight plugin.
	        publish('ViewerWillTerminate', settings);
	
	        // Cancel any pending request retrieving a manifest
	        if (settings.pendingManifestRequest)
	            settings.pendingManifestRequest.abort();
	
	        // Removes the hide-scrollbar class from the body
	        $('body').removeClass('diva-hide-scrollbar');
	
	        // Empty the parent container and remove any diva-related data
	        settings.parentObject.parent().empty().removeData('diva');
	
	        // Remove any additional styling on the parent element
	        settings.parentObject.parent().removeAttr('style').removeAttr('class');
	
	        publish('ViewerDidTerminate', settings);
	
	        // Clear the Events cache
	        diva.Events.unsubscribeAll(settings.ID);
	    };
	
	    // Call the init function when this object is created.
	    init();
	}
	
	generateId.counter = 1;
	
	function generateId() {
	    return generateId.counter++;
	}


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint unused: false */
	
	var jQuery = __webpack_require__(3);
	
	/* istanbul ignore next This is a vendored dependency */
	/*
	 * jQuery dragscrollable Plugin
	 * version: 1.0 (25-Jun-2009)
	 * Copyright (c) 2009 Miquel Herrera
	 * http://plugins.jquery.com/project/Dragscrollable
	 *
	 * Dual licensed under the MIT and GPL licenses:
	 *   http://www.opensource.org/licenses/mit-license.php
	 *   http://www.gnu.org/licenses/gpl.html
	 *
	 */
	(function ($) { // secure $ jQuery alias
	
	    /**
	     * Adds the ability to manage elements scroll by dragging
	     * one or more of its descendant elements. Options parameter
	     * allow to specifically select which inner elements will
	     * respond to the drag events.
	     *
	     * options properties:
	     * ------------------------------------------------------------------------
	     *  dragSelector         | jquery selector to apply to each wrapped element
	     *                       | to find which will be the dragging elements.
	     *                       | Defaults to '>:first' which is the first child of
	     *                       | scrollable element
	     * ------------------------------------------------------------------------
	     *  acceptPropagatedEvent| Will the dragging element accept propagated
	     *                       | events? default is yes, a propagated mouse event
	     *                       | on a inner element will be accepted and processed.
	     *                       | If set to false, only events originated on the
	     *                       | draggable elements will be processed.
	     * ------------------------------------------------------------------------
	     *  preventDefault       | Prevents the event to propagate further effectivey
	     *                       | dissabling other default actions. Defaults to true
	     * ------------------------------------------------------------------------
	     *
	     *  usage examples:
	     *
	     *  To add the scroll by drag to the element id=viewport when dragging its
	     *  first child accepting any propagated events
	     *  $('#viewport').dragscrollable();
	     *
	     *  To add the scroll by drag ability to any element div of class viewport
	     *  when dragging its first descendant of class dragMe responding only to
	     *  evcents originated on the '.dragMe' elements.
	     *  $('div.viewport').dragscrollable({dragSelector:'.dragMe:first',
	 *                                    acceptPropagatedEvent: false});
	     *
	     *  Notice that some 'viewports' could be nested within others but events
	     *  would not interfere as acceptPropagatedEvent is set to false.
	     *
	     */
	    $.fn.dragscrollable = function( options ){
	
	        var settings = $.extend(
	            {
	                dragSelector:'>:first',
	                acceptPropagatedEvent: true,
	                preventDefault: true
	            },options || {});
	
	
	        var dragscroll= {
	            mouseDownHandler : function(event) {
	                // mousedown, left click, check propagation
	                if (event.which!=1 ||
	                    (!event.data.acceptPropagatedEvent && event.target != this)){
	                    return false;
	                }
	
	                // Initial coordinates will be the last when dragging
	                event.data.lastCoord = {left: event.clientX, top: event.clientY};
	
	                $.event.add( document, "mouseup",
	                    dragscroll.mouseUpHandler, event.data );
	                $.event.add( document, "mousemove",
	                    dragscroll.mouseMoveHandler, event.data );
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	            },
	            mouseMoveHandler : function(event) { // User is dragging
	                // How much did the mouse move?
	                var delta = {left: (event.clientX - event.data.lastCoord.left),
	                    top: (event.clientY - event.data.lastCoord.top)};
	
	                // Set the scroll position relative to what ever the scroll is now
	                event.data.scrollable.scrollLeft(
	                    event.data.scrollable.scrollLeft() - delta.left);
	                event.data.scrollable.scrollTop(
	                    event.data.scrollable.scrollTop() - delta.top);
	
	                // Save where the cursor is
	                event.data.lastCoord={left: event.clientX, top: event.clientY};
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	
	            },
	            mouseUpHandler : function(event) { // Stop scrolling
	                $.event.remove( document, "mousemove", dragscroll.mouseMoveHandler);
	                $.event.remove( document, "mouseup", dragscroll.mouseUpHandler);
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	            }
	        };
	
	        // set up the initial events
	        this.each(function() {
	            // closure object data for each scrollable element
	            var data = {scrollable : $(this),
	                acceptPropagatedEvent : settings.acceptPropagatedEvent,
	                preventDefault : settings.preventDefault };
	            // Set mouse initiating event on the desired descendant
	            $(this).find(settings.dragSelector).
	            bind('mousedown', data, dragscroll.mouseDownHandler);
	        });
	    }; //end plugin dragscrollable
	
	})( jQuery ); // confine scope
	
	/* istanbul ignore next This is a vendored dependency */
	/**
	 jQuery.kinetic v2.2.1
	 Dave Taylor http://davetayls.me
	
	 @license The MIT License (MIT)
	 @preserve Copyright (c) 2012 Dave Taylor http://davetayls.me
	 */
	(function ($){
	    'use strict';
	
	    var ACTIVE_CLASS = 'kinetic-active';
	
	    /**
	     * Provides requestAnimationFrame in a cross browser way.
	     * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	     */
	    if (!window.requestAnimationFrame){
	
	        window.requestAnimationFrame = ( function (){
	
	            return window.webkitRequestAnimationFrame ||
	                window.mozRequestAnimationFrame ||
	                window.oRequestAnimationFrame ||
	                window.msRequestAnimationFrame ||
	                function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element){
	                    window.setTimeout(callback, 1000 / 60);
	                };
	
	        }());
	
	    }
	
	    // add touch checker to jQuery.support
	    $.support = $.support || {};
	    $.extend($.support, {
	        touch: 'ontouchend' in document
	    });
	
	
	    // KINETIC CLASS DEFINITION
	    // ======================
	
	    var Kinetic = function (element, settings) {
	        this.settings = settings;
	        this.el       = element;
	        this.$el      = $(element);
	
	        this._initElements();
	
	        return this;
	    };
	
	    Kinetic.DATA_KEY = 'kinetic';
	    Kinetic.DEFAULTS = {
	        cursor: 'move',
	        decelerate: true,
	        triggerHardware: false,
	        threshold: 0,
	        y: true,
	        x: true,
	        slowdown: 0.9,
	        maxvelocity: 40,
	        throttleFPS: 60,
	        invert: false,
	        movingClass: {
	            up: 'kinetic-moving-up',
	            down: 'kinetic-moving-down',
	            left: 'kinetic-moving-left',
	            right: 'kinetic-moving-right'
	        },
	        deceleratingClass: {
	            up: 'kinetic-decelerating-up',
	            down: 'kinetic-decelerating-down',
	            left: 'kinetic-decelerating-left',
	            right: 'kinetic-decelerating-right'
	        }
	    };
	
	
	    // Public functions
	
	    Kinetic.prototype.start = function (options){
	        this.settings = $.extend(this.settings, options);
	        this.velocity = options.velocity || this.velocity;
	        this.velocityY = options.velocityY || this.velocityY;
	        this.settings.decelerate = false;
	        this._move();
	    };
	
	    Kinetic.prototype.end = function (){
	        this.settings.decelerate = true;
	    };
	
	    Kinetic.prototype.stop = function (){
	        this.velocity = 0;
	        this.velocityY = 0;
	        this.settings.decelerate = true;
	        if ($.isFunction(this.settings.stopped)){
	            this.settings.stopped.call(this);
	        }
	    };
	
	    Kinetic.prototype.detach = function (){
	        this._detachListeners();
	        this.$el
	            .removeClass(ACTIVE_CLASS)
	            .css('cursor', '');
	    };
	
	    Kinetic.prototype.attach = function (){
	        if (this.$el.hasClass(ACTIVE_CLASS)) {
	            return;
	        }
	        this._attachListeners(this.$el);
	        this.$el
	            .addClass(ACTIVE_CLASS)
	            .css('cursor', this.settings.cursor);
	    };
	
	
	    // Internal functions
	
	    Kinetic.prototype._initElements = function (){
	        this.$el.addClass(ACTIVE_CLASS);
	
	        $.extend(this, {
	            xpos: null,
	            prevXPos: false,
	            ypos: null,
	            prevYPos: false,
	            mouseDown: false,
	            throttleTimeout: 1000 / this.settings.throttleFPS,
	            lastMove: null,
	            elementFocused: null
	        });
	
	        this.velocity = 0;
	        this.velocityY = 0;
	
	        // make sure we reset everything when mouse up
	        $(document)
	            .mouseup($.proxy(this._resetMouse, this))
	            .click($.proxy(this._resetMouse, this));
	
	        this._initEvents();
	
	        this.$el.css('cursor', this.settings.cursor);
	
	        if (this.settings.triggerHardware){
	            this.$el.css({
	                '-webkit-transform': 'translate3d(0,0,0)',
	                '-webkit-perspective': '1000',
	                '-webkit-backface-visibility': 'hidden'
	            });
	        }
	    };
	
	    Kinetic.prototype._initEvents = function(){
	        var self = this;
	        this.settings.events = {
	            touchStart: function (e){
	                var touch;
	                if (self._useTarget(e.target, e)){
	                    touch = e.originalEvent.touches[0];
	                    self.threshold = self._threshold(e.target, e);
	                    self._start(touch.clientX, touch.clientY);
	                    e.stopPropagation();
	                }
	            },
	            touchMove: function (e){
	                var touch;
	                if (self.mouseDown){
	                    touch = e.originalEvent.touches[0];
	                    self._inputmove(touch.clientX, touch.clientY);
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            inputDown: function (e){
	                if (self._useTarget(e.target, e)){
	                    self.threshold = self._threshold(e.target, e);
	                    self._start(e.clientX, e.clientY);
	                    self.elementFocused = e.target;
	                    if (e.target.nodeName === 'IMG'){
	                        e.preventDefault();
	                    }
	                    e.stopPropagation();
	                }
	            },
	            inputEnd: function (e){
	                if (self._useTarget(e.target, e)){
	                    self._end();
	                    self.elementFocused = null;
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            inputMove: function (e){
	                if (self.mouseDown){
	                    self._inputmove(e.clientX, e.clientY);
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            scroll: function (e){
	                if ($.isFunction(self.settings.moved)){
	                    self.settings.moved.call(self, self.settings);
	                }
	                if (e.preventDefault){
	                    e.preventDefault();
	                }
	            },
	            inputClick: function (e){
	                if (Math.abs(self.velocity) > 0){
	                    e.preventDefault();
	                    return false;
	                }
	            },
	            // prevent drag and drop images in ie
	            dragStart: function (e){
	                if (self._useTarget(e.target, e) && self.elementFocused){
	                    return false;
	                }
	            },
	            // prevent selection when dragging
	            selectStart: function (e){
	                if ($.isFunction(self.settings.selectStart)){
	                    return self.settings.selectStart.apply(self, arguments);
	                } else if (self._useTarget(e.target, e)) {
	                    return false;
	                }
	            }
	        };
	
	        this._attachListeners(this.$el, this.settings);
	
	    };
	
	    Kinetic.prototype._inputmove = function (clientX, clientY){
	        var $this = this.$el;
	        var el = this.el;
	
	        if (!this.lastMove || new Date() > new Date(this.lastMove.getTime() + this.throttleTimeout)){
	            this.lastMove = new Date();
	
	            if (this.mouseDown && (this.xpos || this.ypos)){
	                var movedX = (clientX - this.xpos);
	                var movedY = (clientY - this.ypos);
	                if (this.settings.invert) {
	                    movedX *= -1;
	                    movedY *= -1;
	                }
	                if(this.threshold > 0){
	                    var moved = Math.sqrt(movedX * movedX + movedY * movedY);
	                    if(this.threshold > moved){
	                        return;
	                    } else {
	                        this.threshold = 0;
	                    }
	                }
	                if (this.elementFocused){
	                    $(this.elementFocused).blur();
	                    this.elementFocused = null;
	                    $this.focus();
	                }
	
	                this.settings.decelerate = false;
	                this.velocity = this.velocityY = 0;
	
	                var scrollLeft = this.scrollLeft();
	                var scrollTop = this.scrollTop();
	
	                this.scrollLeft(this.settings.x ? scrollLeft - movedX : scrollLeft);
	                this.scrollTop(this.settings.y ? scrollTop - movedY : scrollTop);
	
	                this.prevXPos = this.xpos;
	                this.prevYPos = this.ypos;
	                this.xpos = clientX;
	                this.ypos = clientY;
	
	                this._calculateVelocities();
	                this._setMoveClasses(this.settings.movingClass);
	
	                if ($.isFunction(this.settings.moved)){
	                    this.settings.moved.call(this, this.settings);
	                }
	            }
	        }
	    };
	
	    Kinetic.prototype._calculateVelocities = function (){
	        this.velocity = this._capVelocity(this.prevXPos - this.xpos, this.settings.maxvelocity);
	        this.velocityY = this._capVelocity(this.prevYPos - this.ypos, this.settings.maxvelocity);
	        if (this.settings.invert) {
	            this.velocity *= -1;
	            this.velocityY *= -1;
	        }
	    };
	
	    Kinetic.prototype._end = function (){
	        if (this.xpos && this.prevXPos && this.settings.decelerate === false){
	            this.settings.decelerate = true;
	            this._calculateVelocities();
	            this.xpos = this.prevXPos = this.mouseDown = false;
	            this._move();
	        }
	    };
	
	    Kinetic.prototype._useTarget = function (target, event){
	        if ($.isFunction(this.settings.filterTarget)){
	            return this.settings.filterTarget.call(this, target, event) !== false;
	        }
	        return true;
	    };
	
	    Kinetic.prototype._threshold = function (target, event){
	        if ($.isFunction(this.settings.threshold)){
	            return this.settings.threshold.call(this, target, event);
	        }
	        return this.settings.threshold;
	    };
	
	    Kinetic.prototype._start = function (clientX, clientY){
	        this.mouseDown = true;
	        this.velocity = this.prevXPos = 0;
	        this.velocityY = this.prevYPos = 0;
	        this.xpos = clientX;
	        this.ypos = clientY;
	    };
	
	    Kinetic.prototype._resetMouse = function (){
	        this.xpos = false;
	        this.ypos = false;
	        this.mouseDown = false;
	    };
	
	    Kinetic.prototype._decelerateVelocity = function (velocity, slowdown){
	        return Math.floor(Math.abs(velocity)) === 0 ? 0 // is velocity less than 1?
	            : velocity * slowdown; // reduce slowdown
	    };
	
	    Kinetic.prototype._capVelocity = function (velocity, max){
	        var newVelocity = velocity;
	        if (velocity > 0){
	            if (velocity > max){
	                newVelocity = max;
	            }
	        } else {
	            if (velocity < (0 - max)){
	                newVelocity = (0 - max);
	            }
	        }
	        return newVelocity;
	    };
	
	    Kinetic.prototype._setMoveClasses = function (classes){
	        // FIXME: consider if we want to apply PL #44, this should not remove
	        // classes we have not defined on the element!
	        var settings = this.settings;
	        var $this = this.$el;
	
	        $this.removeClass(settings.movingClass.up)
	            .removeClass(settings.movingClass.down)
	            .removeClass(settings.movingClass.left)
	            .removeClass(settings.movingClass.right)
	            .removeClass(settings.deceleratingClass.up)
	            .removeClass(settings.deceleratingClass.down)
	            .removeClass(settings.deceleratingClass.left)
	            .removeClass(settings.deceleratingClass.right);
	
	        if (this.velocity > 0){
	            $this.addClass(classes.right);
	        }
	        if (this.velocity < 0){
	            $this.addClass(classes.left);
	        }
	        if (this.velocityY > 0){
	            $this.addClass(classes.down);
	        }
	        if (this.velocityY < 0){
	            $this.addClass(classes.up);
	        }
	
	    };
	
	
	    // do the actual kinetic movement
	    Kinetic.prototype._move = function (){
	        var $scroller = this._getScroller();
	        var scroller = $scroller[0];
	        var self = this;
	        var settings = self.settings;
	
	        // set scrollLeft
	        if (settings.x && scroller.scrollWidth > 0){
	            this.scrollLeft(this.scrollLeft() + this.velocity);
	            if (Math.abs(this.velocity) > 0){
	                this.velocity = settings.decelerate ?
	                    self._decelerateVelocity(this.velocity, settings.slowdown) : this.velocity;
	            }
	        } else {
	            this.velocity = 0;
	        }
	
	        // set scrollTop
	        if (settings.y && scroller.scrollHeight > 0){
	            this.scrollTop(this.scrollTop() + this.velocityY);
	            if (Math.abs(this.velocityY) > 0){
	                this.velocityY = settings.decelerate ?
	                    self._decelerateVelocity(this.velocityY, settings.slowdown) : this.velocityY;
	            }
	        } else {
	            this.velocityY = 0;
	        }
	
	        self._setMoveClasses(settings.deceleratingClass);
	
	        if ($.isFunction(settings.moved)){
	            settings.moved.call(this, settings);
	        }
	
	        if (Math.abs(this.velocity) > 0 || Math.abs(this.velocityY) > 0){
	            if (!this.moving) {
	                this.moving = true;
	                // tick for next movement
	                window.requestAnimationFrame(function (){
	                    self.moving = false;
	                    self._move();
	                });
	            }
	        } else {
	            self.stop();
	        }
	    };
	
	    // get current scroller to apply positioning to
	    Kinetic.prototype._getScroller = function(){
	        var $scroller = this.$el;
	        if (this.$el.is('body') || this.$el.is('html')){
	            $scroller = $(window);
	        }
	        return $scroller;
	    };
	
	    // set the scroll position
	    Kinetic.prototype.scrollLeft = function(left){
	        var $scroller = this._getScroller();
	        if (typeof left === 'number'){
	            $scroller.scrollLeft(left);
	            this.settings.scrollLeft = left;
	        } else {
	            return $scroller.scrollLeft();
	        }
	    };
	    Kinetic.prototype.scrollTop = function(top){
	        var $scroller = this._getScroller();
	        if (typeof top === 'number'){
	            $scroller.scrollTop(top);
	            this.settings.scrollTop = top;
	        } else {
	            return $scroller.scrollTop();
	        }
	    };
	
	    Kinetic.prototype._attachListeners = function (){
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch){
	            $this
	                .bind('touchstart', settings.events.touchStart)
	                .bind('touchend', settings.events.inputEnd)
	                .bind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .mousedown(settings.events.inputDown)
	            .mouseup(settings.events.inputEnd)
	            .mousemove(settings.events.inputMove);
	
	        $this
	            .click(settings.events.inputClick)
	            .scroll(settings.events.scroll)
	            .bind('selectstart', settings.events.selectStart)
	            .bind('dragstart', settings.events.dragStart);
	    };
	
	    Kinetic.prototype._detachListeners = function (){
	        var $this = this.$el;
	        var settings = this.settings;
	        if ($.support.touch){
	            $this
	                .unbind('touchstart', settings.events.touchStart)
	                .unbind('touchend', settings.events.inputEnd)
	                .unbind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .unbind('mousedown', settings.events.inputDown)
	            .unbind('mouseup', settings.events.inputEnd)
	            .unbind('mousemove', settings.events.inputMove);
	
	        $this
	            .unbind('click', settings.events.inputClick)
	            .unbind('scroll', settings.events.scroll)
	            .unbind('selectstart', settings.events.selectStart)
	            .unbind('dragstart', settings.events.dragStart);
	    };
	
	
	    // EXPOSE KINETIC CONSTRUCTOR
	    // ==========================
	    $.Kinetic = Kinetic;
	
	    // KINETIC PLUGIN DEFINITION
	    // =======================
	
	    $.fn.kinetic = function (option, callOptions) {
	        return this.each(function () {
	            var $this    = $(this);
	            var instance = $this.data(Kinetic.DATA_KEY);
	            var options  = $.extend({}, Kinetic.DEFAULTS, $this.data(), typeof option === 'object' && option);
	
	            if (!instance) {
	                $this.data(Kinetic.DATA_KEY, (instance = new Kinetic(this, options)));
	            }
	
	            if (typeof option === 'string') {
	                instance[option](callOptions);
	            }
	
	        });
	    };
	
	}(jQuery));
	
	/* istanbul ignore next
	    We should maybe be testing this, but realistically that would mean maintaining a real fork */
	
	// jQuery.kinetic core modifications for diva.js (compatible with jQuery.kinetic 2.2.1)
	// use jQuery.kinetic for touch handlers only since we are using dragscrollable for mouse handlers
	//    - (kinetic provides inertial scrolling [ease into stopped state on release] for touch events and dragscrollable
	//      allows non-inertial scrolling which we like for mice)
	
	(function($)
	{
	    $.Kinetic.prototype._attachListeners = function()
	    {
	        // attach only touch listeners
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch)
	        {
	            $this
	                .bind('touchstart', settings.events.touchStart)
	                .bind('touchend', settings.events.inputEnd)
	                .bind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .click(settings.events.inputClick)
	            .scroll(settings.events.scroll)
	            .bind('selectstart', settings.events.selectStart)
	            .bind('dragstart', settings.events.dragStart);
	    };
	
	    $.Kinetic.prototype._detachListeners = function()
	    {
	        // detach only touch listeners
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch)
	        {
	            $this
	                .unbind('touchstart', settings.events.touchStart)
	                .unbind('touchend', settings.events.inputEnd)
	                .unbind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .unbind('click', settings.events.inputClick)
	            .unbind('scroll', settings.events.scroll)
	            .unbind('selectstart', settings.events.selectStart)
	            .unbind('dragstart', settings.events.dragStart);
	    };
	})(jQuery);


/***/ },
/* 16 */
/***/ function(module, exports) {

	// From http://www.alexandre-gomes.com/?p=115, modified slightly
	module.exports = function getScrollbarWidth() {
	    var inner = document.createElement('p');
	    inner.style.width = '100%';
	    inner.style.height = '200px';
	
	    var outer = document.createElement('div');
	    outer.style.position = 'absolute';
	    outer.style.top = '0px';
	    outer.style.left = '0px';
	    outer.style.visibility = 'hidden';
	    outer.style.width = '200px';
	    outer.style.height = '150px';
	    outer.style.overflow = 'hidden';
	    outer.appendChild(inner);
	
	    document.body.appendChild(outer);
	
	    var w1 = inner.offsetWidth;
	    outer.style.overflow = 'scroll';
	    var w2 = inner.offsetWidth;
	    if (w1 == w2) {
	        w2 = outer.clientWidth; // for IE i think
	    }
	
	    document.body.removeChild(outer);
	    return w1 - w2;
	};


/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = {
	    onDoubleClick: onDoubleClick,
	    onPinch: onPinch,
	    onDoubleTap: onDoubleTap
	};
	
	var DOUBLE_CLICK_TIMEOUT = 500;
	
	var DOUBLE_TAP_DISTANCE_THRESHOLD = 50;
	var DOUBLE_TAP_TIMEOUT = 250;
	
	function onDoubleClick(elem, callback)
	{
	    elem.on('dblclick', function (event)
	    {
	        if (!event.ctrlKey)
	        {
	            callback(event, getRelativeOffset(event.currentTarget, event));
	        }
	    });
	
	    // Handle the control key for macs (in conjunction with double-clicking)
	    // FIXME: Does a click get handled with ctrl pressed on non-Macs?
	    var tracker = createDoubleEventTracker(DOUBLE_CLICK_TIMEOUT);
	
	    elem.on('contextmenu', function (event)
	    {
	        event.preventDefault();
	
	        if (event.ctrlKey)
	        {
	            if (tracker.isTriggered())
	            {
	                tracker.reset();
	                callback(event, getRelativeOffset(event.currentTarget, event));
	            }
	            else
	            {
	                tracker.trigger();
	            }
	        }
	    });
	}
	
	function onPinch(elem, callback)
	{
	    var startDistance = 0;
	
	    elem.on('touchstart', function(event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (event.originalEvent.touches.length === 2)
	        {
	            startDistance = distance(
	                event.originalEvent.touches[0].clientX,
	                event.originalEvent.touches[0].clientY,
	                event.originalEvent.touches[1].clientX,
	                event.originalEvent.touches[1].clientY
	            );
	        }
	    });
	
	    elem.on('touchmove', function(event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (event.originalEvent.touches.length === 2)
	        {
	            var touches = event.originalEvent.touches;
	
	            var moveDistance = distance(
	                touches[0].clientX,
	                touches[0].clientY,
	                touches[1].clientX,
	                touches[1].clientY
	            );
	
	            var zoomDelta = moveDistance - startDistance;
	
	            if (Math.abs(zoomDelta) > 0)
	            {
	                var touchCenter = {
	                    pageX: (touches[0].clientX + touches[1].clientX) / 2,
	                    pageY: (touches[0].clientY + touches[1].clientY) / 2
	                };
	
	                callback(event, getRelativeOffset(event.currentTarget, touchCenter), startDistance, moveDistance);
	            }
	        }
	    });
	}
	
	function onDoubleTap(elem, callback)
	{
	    var tracker = createDoubleEventTracker(DOUBLE_TAP_TIMEOUT);
	    var firstTap = null;
	
	    elem.on('touchend', function (event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (tracker.isTriggered())
	        {
	            tracker.reset();
	
	            // Doubletap has occurred
	            var secondTap = {
	                pageX: event.originalEvent.changedTouches[0].clientX,
	                pageY: event.originalEvent.changedTouches[0].clientY
	            };
	
	            // If first tap is close to second tap (prevents interference with scale event)
	            var tapDistance = distance(firstTap.pageX, firstTap.pageY, secondTap.pageX, secondTap.pageY);
	
	            // TODO: Could give something higher-level than secondTap to callback
	            if (tapDistance < DOUBLE_TAP_DISTANCE_THRESHOLD)
	                callback(event, getRelativeOffset(event.currentTarget, secondTap));
	
	            firstTap = null;
	        }
	        else
	        {
	            firstTap = {
	                pageX: event.originalEvent.changedTouches[0].clientX,
	                pageY: event.originalEvent.changedTouches[0].clientY
	            };
	
	            tracker.trigger();
	        }
	    });
	}
	
	// Pythagorean theorem to get the distance between two points (used for
	// calculating finger distance for double-tap and pinch-zoom)
	function distance(x1, y1, x2, y2)
	{
	    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	}
	
	// Utility to keep track of whether an event has been triggered twice
	// during a a given duration
	function createDoubleEventTracker(timeoutDuration)
	{
	    var triggered = false;
	    var timeoutId = null;
	
	    return {
	        trigger: function ()
	        {
	            triggered = true;
	            resetTimeout();
	            timeoutId = setTimeout(function ()
	            {
	                triggered = false;
	                timeoutId = null;
	            }, timeoutDuration);
	        },
	        isTriggered: function ()
	        {
	            return triggered;
	        },
	        reset: function ()
	        {
	            triggered = false;
	            resetTimeout();
	        }
	    };
	
	    function resetTimeout()
	    {
	        if (timeoutId !== null)
	        {
	            clearTimeout(timeoutId);
	            timeoutId = null;
	        }
	    }
	}
	
	function getRelativeOffset(elem, pageCoords)
	{
	    var bounds = elem.getBoundingClientRect();
	
	    return {
	        left: pageCoords.pageX - bounds.left,
	        top: pageCoords.pageY - bounds.top
	    };
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var maxBy = __webpack_require__(19);
	var PageToolsOverlay = __webpack_require__(24);
	
	module.exports = DocumentHandler;
	
	function DocumentHandler(viewerCore)
	{
	    this._viewerCore = viewerCore;
	    this._viewerState = viewerCore.getInternalState();
	    this._overlays = [];
	
	    if (viewerCore.getPageTools().length)
	    {
	        var numPages = viewerCore.getSettings().numPages;
	
	        for (var i=0; i < numPages; i++)
	        {
	            var overlay = new PageToolsOverlay(i, viewerCore);
	            this._overlays.push(overlay);
	            viewerCore.addPageOverlay(overlay);
	        }
	    }
	}
	
	// USER EVENTS
	DocumentHandler.prototype.onDoubleClick = function (event, coords)
	{
	    var settings = this._viewerCore.getSettings();
	    var newZoomLevel = event.ctrlKey ? settings.zoomLevel - 1 : settings.zoomLevel + 1;
	
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    this._viewerCore.zoom(newZoomLevel, position);
	};
	
	DocumentHandler.prototype.onPinch = function (event, coords, startDistance, endDistance)
	{
	    // FIXME: Do this check in a way which is less spaghetti code-y
	    var viewerState = this._viewerCore.getInternalState();
	    var settings = this._viewerCore.getSettings();
	
	    var newZoomLevel = Math.log(Math.pow(2, settings.zoomLevel) * endDistance / (startDistance * Math.log(2))) / Math.log(2);
	    newZoomLevel = Math.max(settings.minZoomLevel, newZoomLevel);
	    newZoomLevel = Math.min(settings.maxZoomLevel, newZoomLevel);
	
	    if (newZoomLevel === settings.zoomLevel)
	        return;
	
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var centerOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewerState.viewport);
	    var scaleRatio = 1 / Math.pow(2, settings.zoomLevel - newZoomLevel);
	
	    this._viewerCore.reload({
	        zoomLevel: newZoomLevel,
	        goDirectlyTo: position.anchorPage,
	        horizontalOffset: (centerOffset.x - position.offset.left) + position.offset.left * scaleRatio,
	        verticalOffset: (centerOffset.y - position.offset.top) + position.offset.top * scaleRatio
	    });
	};
	
	// VIEW EVENTS
	DocumentHandler.prototype.onViewWillLoad = function ()
	{
	    this._viewerCore.publish('DocumentWillLoad', this._viewerCore.getSettings());
	};
	
	DocumentHandler.prototype.onViewDidLoad = function ()
	{
	    // TODO: Should only be necessary to handle changes on view update, not
	    // initial load
	    this._handleZoomLevelChange();
	
	    var currentPageIndex = this._viewerCore.getSettings().currentPageIndex;
	    var fileName = this._viewerCore.getPageName(currentPageIndex);
	    this._viewerCore.publish("DocumentDidLoad", currentPageIndex, fileName);
	};
	
	DocumentHandler.prototype.onViewDidUpdate = function (renderedPages, targetPage)
	{
	    var currentPage = (targetPage !== null) ?
	        targetPage :
	        getCentermostPage(renderedPages, this._viewerCore.getCurrentLayout(), this._viewerCore.getViewport());
	
	    // Don't change the current page if there is no page in the viewport
	    // FIXME: Would be better to fall back to the page closest to the viewport
	    if (currentPage !== null)
	        this._viewerCore.setCurrentPage(currentPage);
	
	    if (targetPage !== null)
	        this._viewerCore.publish("ViewerDidJump", targetPage);
	
	    this._handleZoomLevelChange();
	};
	
	DocumentHandler.prototype._handleZoomLevelChange = function ()
	{
	    var viewerState = this._viewerState;
	    var zoomLevel = viewerState.options.zoomLevel;
	
	    // If this is not the initial load, trigger the zoom events
	    if (viewerState.oldZoomLevel !== zoomLevel && viewerState.oldZoomLevel >= 0)
	    {
	        if (viewerState.oldZoomLevel < zoomLevel)
	        {
	            this._viewerCore.publish("ViewerDidZoomIn", zoomLevel);
	        }
	        else
	        {
	            this._viewerCore.publish("ViewerDidZoomOut", zoomLevel);
	        }
	
	        this._viewerCore.publish("ViewerDidZoom", zoomLevel);
	    }
	
	    viewerState.oldZoomLevel = zoomLevel;
	};
	
	DocumentHandler.prototype.destroy = function ()
	{
	    this._overlays.forEach(function (overlay)
	    {
	        this._viewerCore.removePageOverlay(overlay);
	    }, this);
	};
	
	function getCentermostPage(renderedPages, layout, viewport)
	{
	    var centerY = viewport.top + (viewport.height / 2);
	    var centerX = viewport.left + (viewport.width / 2);
	
	    // Find the minimum distance from the viewport center to a page.
	    // Compute minus the squared distance from viewport center to the page's border.
	    // http://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle
	    var centerPage = maxBy(renderedPages, function (pageIndex)
	    {
	        var dims = layout.getPageDimensions(pageIndex);
	        var imageOffset = layout.getPageOffset(pageIndex, {excludePadding: false});
	
	        var midX = imageOffset.left + (dims.height / 2);
	        var midY = imageOffset.top + (dims.width / 2);
	
	        var dx = Math.max(Math.abs(centerX - midX) - (dims.width / 2), 0);
	        var dy = Math.max(Math.abs(centerY - midY) - (dims.height / 2), 0);
	
	        return -(dx * dx + dy * dy);
	    });
	
	    return centerPage != null ? centerPage : null;
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	var baseIteratee = __webpack_require__(20);
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * The base implementation of methods like `_.max` and `_.min` which accepts a
	 * `comparator` to determine the extremum value.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The iteratee invoked per iteration.
	 * @param {Function} comparator The comparator used to compare values.
	 * @returns {*} Returns the extremum value.
	 */
	function baseExtremum(array, iteratee, comparator) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    var value = array[index],
	        current = iteratee(value);
	
	    if (current != null && (computed === undefined
	          ? (current === current && !isSymbol(current))
	          : comparator(current, computed)
	        )) {
	      var computed = current,
	          result = value;
	    }
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.gt` which doesn't coerce arguments to numbers.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is greater than `other`,
	 *  else `false`.
	 */
	function baseGt(value, other) {
	  return value > other;
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	/**
	 * This method is like `_.max` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the criterion by which
	 * the value is ranked. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Array|Function|Object|string} [iteratee=_.identity]
	 *  The iteratee invoked per element.
	 * @returns {*} Returns the maximum value.
	 * @example
	 *
	 * var objects = [{ 'n': 1 }, { 'n': 2 }];
	 *
	 * _.maxBy(objects, function(o) { return o.n; });
	 * // => { 'n': 2 }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.maxBy(objects, 'n');
	 * // => { 'n': 2 }
	 */
	function maxBy(array, iteratee) {
	  return (array && array.length)
	    ? baseExtremum(array, baseIteratee(iteratee), baseGt)
	    : undefined;
	}
	
	module.exports = maxBy;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	var stringToPath = __webpack_require__(22);
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/** Used to determine if values are of the language type `Object`. */
	var objectTypes = {
	  'function': true,
	  'object': true
	};
	
	/** Detect free variable `exports`. */
	var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	  ? exports
	  : undefined;
	
	/** Detect free variable `module`. */
	var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	  ? module
	  : undefined;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
	
	/** Detect free variable `self`. */
	var freeSelf = checkGlobal(objectTypes[typeof self] && self);
	
	/** Detect free variable `window`. */
	var freeWindow = checkGlobal(objectTypes[typeof window] && window);
	
	/** Detect `this` as the global object. */
	var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
	
	/**
	 * Used as a reference to the global object.
	 *
	 * The `this` value is used if it's the global object to avoid Greasemonkey's
	 * restricted `window` object, otherwise the `window` object is used.
	 */
	var root = freeGlobal ||
	  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
	    freeSelf || thisGlobal || Function('return this')();
	
	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	 * of key-value pairs for `object` corresponding to the property names of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the key-value pairs.
	 */
	function baseToPairs(object, props) {
	  return arrayMap(props, function(key) {
	    return [key, object[key]];
	  });
	}
	
	/**
	 * Checks if `value` is a global object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	 */
	function checkGlobal(value) {
	  return (value && value.Object === Object) ? value : null;
	}
	
	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	
	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	
	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}
	
	/**
	 * Converts `set` to its value-value pairs.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the value-value pairs.
	 */
	function setToPairs(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = [value, value];
	  });
	  return result;
	}
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf,
	    nativeKeys = Object.keys;
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}
	
	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;
	
	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}
	
	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}
	
	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}
	
	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}
	
	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}
	
	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
	    cache = this.__data__ = new MapCache(cache.__data__);
	  }
	  cache.set(key, value);
	  return this;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
	  // that are composed entirely of index properties, return `false` for
	  // `hasOwnProperty` checks of them.
	  return hasOwnProperty.call(object, key) ||
	    (typeof object == 'object' && key in object && getPrototype(object) === null);
	}
	
	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return key in Object(object);
	}
	
	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;
	
	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}
	
	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}
	
	/**
	 * The base implementation of `_.keys` which doesn't skip the constructor
	 * property of prototypes or treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  return nativeKeys(Object(object));
	}
	
	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}
	
	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}
	
	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}
	
	/**
	 * Creates a `_.toPairs` or `_.toPairsIn` function.
	 *
	 * @private
	 * @param {Function} keysFunc The function to get the keys of a given object.
	 * @returns {Function} Returns the new pairs function.
	 */
	function createToPairs(keysFunc) {
	  return function(object) {
	    var tag = getTag(object);
	    if (tag == mapTag) {
	      return mapToArray(object);
	    }
	    if (tag == setTag) {
	      return setToPairs(object);
	    }
	    return baseToPairs(object, keysFunc(object));
	  };
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
	
	  stack.set(array, other);
	
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	
	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;
	
	    case boolTag:
	    case dateTag:
	      // Coerce dates and booleans to numbers, dates to milliseconds and
	      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
	      // not equal.
	      return +object == +other;
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case numberTag:
	      // Treat `NaN` vs. `NaN` as equal.
	      return (object != +object) ? other != +other : object == +other;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');
	
	    case mapTag:
	      var convert = mapToArray;
	
	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);
	
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;
	      stack.set(object, other);
	
	      // Recursively compare objects (susceptible to call stack limits).
	      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	
	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : baseHas(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  return result;
	}
	
	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a
	 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
	 * Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = toPairs(object),
	      length = result.length;
	
	  while (length--) {
	    result[length][2] = isStrictComparable(result[length][1]);
	  }
	  return result;
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object[key];
	  return isNative(value) ? value : undefined;
	}
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function getTag(value) {
	  return objectToString.call(value);
	}
	
	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var result,
	      index = -1,
	      length = path.length;
	
	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isString(object) || isArguments(object));
	}
	
	/**
	 * Creates an array of index keys for `object` values of arrays,
	 * `arguments` objects, and strings, otherwise `null` is returned.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array|null} Returns index keys, else `null`.
	 */
	function indexKeys(object) {
	  var length = object ? object.length : undefined;
	  if (isLength(length) &&
	      (isArray(object) || isString(object) || isArguments(object))) {
	    return baseTimes(length, String);
	  }
	  return null;
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}
	
	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}
	
	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 * var other = { 'user': 'fred' };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @type {Function}
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value)) && !isFunction(value);
	}
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length,
	 *  else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	function isTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}
	
	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is used in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}
	
	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  var isProto = isPrototype(object);
	  if (!(isProto || isArrayLike(object))) {
	    return baseKeys(object);
	  }
	  var indexes = indexKeys(object),
	      skipIndexes = !!indexes,
	      result = indexes || [],
	      length = result.length;
	
	  for (var key in object) {
	    if (baseHas(object, key) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
	        !(isProto && key == 'constructor')) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Creates an array of own enumerable string keyed-value pairs for `object`
	 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	 * entries are returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias entries
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the key-value pairs.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.toPairs(new Foo);
	 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	 */
	var toPairs = createToPairs(keys);
	
	/**
	 * This method returns the first argument given to it.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	
	module.exports = baseIteratee;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module), (function() { return this; }())))

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	var baseToString = __webpack_require__(23);
	
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';
	
	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used to determine if values are of the language type `Object`. */
	var objectTypes = {
	  'function': true,
	  'object': true
	};
	
	/** Detect free variable `exports`. */
	var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	  ? exports
	  : undefined;
	
	/** Detect free variable `module`. */
	var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	  ? module
	  : undefined;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
	
	/** Detect free variable `self`. */
	var freeSelf = checkGlobal(objectTypes[typeof self] && self);
	
	/** Detect free variable `window`. */
	var freeWindow = checkGlobal(objectTypes[typeof window] && window);
	
	/** Detect `this` as the global object. */
	var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
	
	/**
	 * Used as a reference to the global object.
	 *
	 * The `this` value is used if it's the global object to avoid Greasemonkey's
	 * restricted `window` object, otherwise the `window` object is used.
	 */
	var root = freeGlobal ||
	  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
	    freeSelf || thisGlobal || Function('return this')();
	
	/**
	 * Checks if `value` is a global object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	 */
	function checkGlobal(value) {
	  return (value && value.Object === Object) ? value : null;
	}
	
	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/** Built-in value references. */
	var splice = arrayProto.splice;
	
	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map'),
	    nativeCreate = getNative(Object, 'create');
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}
	
	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object[key];
	  return isNative(value) ? value : undefined;
	}
	
	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  var result = [];
	  toString(string).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;
	
	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}
	
	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 * var other = { 'user': 'fred' };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	module.exports = stringToPath;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module), (function() { return this; }())))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/** Used to determine if values are of the language type `Object`. */
	var objectTypes = {
	  'function': true,
	  'object': true
	};
	
	/** Detect free variable `exports`. */
	var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	  ? exports
	  : undefined;
	
	/** Detect free variable `module`. */
	var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	  ? module
	  : undefined;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
	
	/** Detect free variable `self`. */
	var freeSelf = checkGlobal(objectTypes[typeof self] && self);
	
	/** Detect free variable `window`. */
	var freeWindow = checkGlobal(objectTypes[typeof window] && window);
	
	/** Detect `this` as the global object. */
	var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
	
	/**
	 * Used as a reference to the global object.
	 *
	 * The `this` value is used if it's the global object to avoid Greasemonkey's
	 * restricted `window` object, otherwise the `window` object is used.
	 */
	var root = freeGlobal ||
	  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
	    freeSelf || thisGlobal || Function('return this')();
	
	/**
	 * Checks if `value` is a global object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	 */
	function checkGlobal(value) {
	  return (value && value.Object === Object) ? value : null;
	}
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	module.exports = baseToString;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module), (function() { return this; }())))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var elt = __webpack_require__(8);
	
	module.exports = PageToolsOverlay;
	
	function PageToolsOverlay(pageIndex, viewerCore)
	{
	    this.page = pageIndex;
	
	    this._viewerCore = viewerCore;
	
	    this._innerElement = viewerCore.getSettings().innerElement;
	    this._pageToolsElem = null;
	}
	
	PageToolsOverlay.prototype.mount = function ()
	{
	    if (this._pageToolsElem === null)
	    {
	        var buttons = this._initializePageToolButtons();
	
	        this._pageToolsElem = elt('div', {class: 'diva-page-tools-wrapper'},
	            elt('div', {class: 'diva-page-tools'}, buttons)
	        );
	    }
	
	    this.refresh();
	    this._innerElement.appendChild(this._pageToolsElem);
	};
	
	PageToolsOverlay.prototype._initializePageToolButtons = function ()
	{
	    // Callback parameters
	    var settings = this._viewerCore.getSettings();
	    var publicInstance = this._viewerCore.getPublicInstance();
	    var pageIndex = this.page;
	
	    return this._viewerCore.getPageTools().map(function (plugin)
	    {
	        // If the title text is undefined, use the name of the plugin
	        var titleText = plugin.titleText || plugin.pluginName[0].toUpperCase() + plugin.pluginName.substring(1) + " plugin";
	
	        var button = elt('div', {
	            class: 'diva-' + plugin.pluginName + '-icon',
	            title: titleText
	        });
	
	        button.addEventListener('click', function (event)
	        {
	            plugin.handleClick.call(this, event, settings, publicInstance, pageIndex);
	        }, false);
	
	        button.addEventListener('touchend', function (event)
	        {
	            // Prevent firing of emulated mouse events
	            event.preventDefault();
	
	            plugin.handleClick.call(this, event, settings, publicInstance, pageIndex);
	        }, false);
	
	        return button;
	    }, this);
	};
	
	PageToolsOverlay.prototype.unmount = function ()
	{
	    this._innerElement.removeChild(this._pageToolsElem);
	};
	
	PageToolsOverlay.prototype.refresh = function ()
	{
	    var pos = this._viewerCore.getPageRegion(this.page, {
	        excludePadding: true,
	        incorporateViewport: true
	    });
	
	    this._pageToolsElem.style.top = pos.top + 'px';
	    this._pageToolsElem.style.left = pos.left + 'px';
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var maxBy = __webpack_require__(19);
	
	module.exports = GridHandler;
	
	function GridHandler(viewerCore)
	{
	    this._viewerCore = viewerCore;
	}
	
	// USER EVENTS
	GridHandler.prototype.onDoubleClick = function (event, coords)
	{
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var viewport = this._viewerCore.getViewport();
	    var pageToViewportCenterOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewport);
	
	    this._viewerCore.reload({
	        inGrid: false,
	        goDirectlyTo: position.anchorPage,
	        horizontalOffset: pageToViewportCenterOffset.x + position.offset.left,
	        verticalOffset: pageToViewportCenterOffset.y + position.offset.top
	    });
	};
	
	GridHandler.prototype.onPinch = function ()
	{
	    this._viewerCore.reload({ inGrid: false });
	};
	
	// VIEW EVENTS
	GridHandler.prototype.onViewWillLoad = function ()
	{
	    // FIXME(wabain): Should something happen here?
	    /* No-op */
	};
	
	GridHandler.prototype.onViewDidLoad = function ()
	{
	    // FIXME(wabain): Should something happen here?
	    /* No-op */
	};
	
	GridHandler.prototype.onViewDidUpdate = function (renderedPages, targetPage)
	{
	    if (targetPage !== null)
	    {
	        this._viewerCore.setCurrentPage(targetPage);
	        return;
	    }
	
	    // Select the current page from the first row if it is fully visible, or from
	    // the second row if it is fully visible, or from the centermost row otherwise.
	    // If the current page is in that group then don't change it. Otherwise, set
	    // the current page to the group's first page.
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var groups = [];
	    renderedPages.forEach(function (pageIndex)
	    {
	        var group = layout.getPageInfo(pageIndex).group;
	        if (groups.length === 0 || group !== groups[groups.length - 1])
	            groups.push(group);
	    });
	
	    var viewport = this._viewerCore.getViewport();
	    var chosenGroup;
	
	    if (groups.length === 1 || groups[0].region.top >= viewport.top)
	        chosenGroup = groups[0];
	    else if (groups[1].region.bottom <= viewport.bottom)
	        chosenGroup = groups[1];
	    else
	        chosenGroup = getCentermostGroup(groups, viewport);
	
	    var currentPage = this._viewerCore.getSettings().currentPageIndex;
	
	    var hasCurrentPage = chosenGroup.pages.some(function (page)
	    {
	        return page.index === currentPage;
	    });
	
	    if (!hasCurrentPage)
	        this._viewerCore.setCurrentPage(chosenGroup.pages[0].index);
	};
	
	GridHandler.prototype.destroy = function ()
	{
	    // No-op
	};
	
	function getCentermostGroup(groups, viewport)
	{
	    var viewportMiddle = viewport.top + viewport.height / 2;
	
	    return maxBy(groups, function (group)
	    {
	        var groupMiddle = group.region.top + group.dimensions.height / 2;
	        return -Math.abs(viewportMiddle - groupMiddle);
	    });
	}


/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = PageOverlayManager;
	
	/**
	 * Manages a collection of page overlays, which implement a low-level
	 * API for synchronizing HTML pages to the canvas. Each overlay needs
	 * to implement the following protocol:
	 *
	 *   mount(): Called when a page is first rendered
	 *   refresh(): Called when a page is moved
	 *   unmount(): Called when a previously rendered page has stopped being rendered
	 *
	 * @class
	 */
	
	function PageOverlayManager()
	{
	    this._pages = {};
	    this._renderedPages = [];
	    this._renderedPageMap = {};
	}
	
	PageOverlayManager.prototype.addOverlay = function (overlay)
	{
	    var overlaysByPage = this._pages[overlay.page] || (this._pages[overlay.page] = []);
	
	    overlaysByPage.push(overlay);
	
	    if (this._renderedPageMap[overlay.page])
	        overlay.mount();
	};
	
	PageOverlayManager.prototype.removeOverlay = function (overlay)
	{
	    var page = overlay.page;
	    var overlaysByPage = this._pages[page];
	
	    if (!overlaysByPage)
	        return;
	
	    var overlayIndex = overlaysByPage.indexOf(overlay);
	
	    if (overlayIndex === -1)
	        return;
	
	    if (this._renderedPageMap[page])
	        overlaysByPage[overlayIndex].unmount();
	
	    overlaysByPage.splice(overlayIndex, 1);
	
	    if (overlaysByPage.length === 0)
	        delete this._pages[page];
	};
	
	PageOverlayManager.prototype.updateOverlays = function (renderedPages)
	{
	    var previouslyRendered = this._renderedPages;
	    var newRenderedMap = {};
	
	    renderedPages.forEach(function (pageIndex)
	    {
	        newRenderedMap[pageIndex] = true;
	
	        if (!this._renderedPageMap[pageIndex])
	        {
	            this._renderedPageMap[pageIndex] = true;
	
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.mount();
	            });
	        }
	    }, this);
	
	    previouslyRendered.forEach(function (pageIndex)
	    {
	        if (newRenderedMap[pageIndex])
	        {
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.refresh();
	            });
	        }
	        else
	        {
	            delete this._renderedPageMap[pageIndex];
	
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.unmount();
	            });
	        }
	    }, this);
	
	    this._renderedPages = renderedPages;
	};
	
	PageOverlayManager.prototype._invokeOnOverlays = function (pageIndex, func)
	{
	    var overlays = this._pages[pageIndex];
	    if (overlays)
	        overlays.forEach(func, this);
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = __webpack_require__(28)('diva:Renderer');
	var debugPaints = __webpack_require__(28)('diva:Renderer:paints');
	
	var elt = __webpack_require__(8);
	
	var CompositeImage = __webpack_require__(31);
	var DocumentLayout = __webpack_require__(32);
	var ImageCache = __webpack_require__(33);
	var ImageRequestHandler = __webpack_require__(34);
	var InterpolateAnimation = __webpack_require__(35);
	
	var REQUEST_DEBOUNCE_INTERVAL = 250;
	
	
	module.exports = Renderer;
	
	function Renderer(options, hooks)
	{
	    this._viewport = options.viewport;
	    this._outerElement = options.outerElement;
	    this._documentElement = options.innerElement;
	
	    this._hooks = hooks || {};
	
	    this._canvas = elt('canvas', { class: 'diva-viewer-canvas' });
	    this._ctx = this._canvas.getContext('2d');
	
	    this.layout = null;
	
	    this._sourceResolver = null;
	    this._renderedPages = null;
	    this._config = null;
	    this._zoomLevel = null;
	    this._compositeImages = null;
	    this._renderedTiles = null;
	    this._animation = null;
	
	    // FIXME(wabain): What level should this be maintained at?
	    // Diva global?
	    this._cache = new ImageCache();
	    this._pendingRequests = {};
	}
	
	Renderer.getCompatibilityErrors = function ()
	{
	    if (typeof HTMLCanvasElement !== 'undefined')
	        return null;
	
	    return [
	        'Your browser lacks support for the ', elt('pre', 'canvas'),
	        ' element. Please upgrade your browser.'
	    ];
	};
	
	Renderer.prototype.load = function (config, viewportPosition, sourceResolver)
	{
	    this._clearAnimation();
	
	    if (this._hooks.onViewWillLoad)
	        this._hooks.onViewWillLoad();
	
	    this._sourceResolver = sourceResolver;
	    this._config = config;
	    this._compositeImages = {};
	    this._setLayoutToZoomLevel(viewportPosition.zoomLevel);
	
	    // FIXME(wabain): Remove this when there's more confidence the check shouldn't be needed
	    if (!this.layout.getPageInfo(viewportPosition.anchorPage))
	        throw new Error('invalid page: ' + viewportPosition.anchorPage);
	
	    if (this._canvas.width !== this._viewport.width || this._canvas.height !== this._viewport.height)
	    {
	        debug('Canvas dimension change: (%s, %s) -> (%s, %s)', this._canvas.width, this._canvas.height,
	            this._viewport.width, this._viewport.height);
	
	        this._canvas.width = this._viewport.width;
	        this._canvas.height = this._viewport.height;
	    } else {
	        debug('Reload, no size change');
	    }
	
	    // FIXME: What hooks should be called here?
	    this.goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);
	
	    if (this._canvas.parentNode !== this._outerElement)
	        this._outerElement.insertBefore(this._canvas, this._outerElement.firstChild);
	
	    if (this._hooks.onViewDidLoad)
	        this._hooks.onViewDidLoad();
	};
	
	Renderer.prototype._setViewportPosition = function (viewportPosition)
	{
	    if (viewportPosition.zoomLevel !== this._zoomLevel)
	    {
	        if (this._zoomLevel === null)
	            throw new TypeError('The current view is not zoomable');
	        else if (viewportPosition.zoomLevel === null)
	            throw new TypeError('The current view requires a zoom level');
	
	        this._setLayoutToZoomLevel(viewportPosition.zoomLevel);
	    }
	
	    this._goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);
	};
	
	Renderer.prototype._setLayoutToZoomLevel = function (zoomLevel)
	{
	    this.layout = new DocumentLayout(this._config, zoomLevel);
	    this._zoomLevel = zoomLevel;
	
	    elt.setAttributes(this._documentElement, {
	        style: {
	            height: this.layout.dimensions.height + 'px',
	            width: this.layout.dimensions.width + 'px'
	        }
	    });
	
	    this._viewport.setInnerDimensions(this.layout.dimensions);
	};
	
	Renderer.prototype.adjust = function (direction)
	{
	    this._clearAnimation();
	
	    this._render(direction);
	
	    if (this._hooks.onViewDidUpdate)
	    {
	        this._hooks.onViewDidUpdate(this._renderedPages.slice(), null);
	    }
	};
	
	// FIXME(wabain): Remove the direction argument if it doesn't end up being needed.
	Renderer.prototype._render = function (direction) // jshint ignore:line
	{
	    var newRenderedPages = [];
	    this.layout.pageGroups.forEach(function (group)
	    {
	        if (!this._viewport.intersectsRegion(group.region))
	            return;
	
	        var visiblePages = group.pages
	            .filter(function (page)
	            {
	                return this.isPageVisible(page.index);
	            }, this)
	            .map(function (page)
	            {
	                return page.index;
	            });
	
	        newRenderedPages.push.apply(newRenderedPages, visiblePages);
	    }, this);
	
	    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
	    this._paintOutline(newRenderedPages);
	
	    newRenderedPages.forEach(function (pageIndex)
	    {
	        if (!this._compositeImages[pageIndex])
	        {
	            var page = this.layout.getPageInfo(pageIndex);
	            var zoomLevels = this._sourceResolver.getAllZoomLevelsForPage(page);
	            var composite = new CompositeImage(zoomLevels);
	            composite.updateFromCache(this._cache);
	            this._compositeImages[pageIndex] = composite;
	        }
	    }, this);
	
	    this._initiateTileRequests(newRenderedPages);
	
	    var changes = findChanges(this._renderedPages || [], newRenderedPages);
	
	    changes.removed.forEach(function (pageIndex)
	    {
	        delete this._compositeImages[pageIndex];
	    }, this);
	
	    this._renderedPages = newRenderedPages;
	    this._paint();
	
	    if (this._hooks.onPageWillLoad)
	    {
	        changes.added.forEach(function (pageIndex)
	        {
	            this._hooks.onPageWillLoad(pageIndex);
	        }, this);
	    }
	};
	
	Renderer.prototype._paint = function ()
	{
	    debug('Repainting');
	
	    var renderedTiles = [];
	
	    this._renderedPages.forEach(function (pageIndex)
	    {
	        this._compositeImages[pageIndex].getTiles(this._zoomLevel).forEach(function (source)
	        {
	            var scaled = getScaledTileRecord(source, this._zoomLevel);
	
	            if (this._isTileVisible(pageIndex, scaled))
	            {
	                renderedTiles.push(source.url);
	                this._drawTile(pageIndex, scaled, this._cache.get(source.url));
	            }
	        }, this);
	    }, this);
	
	    var cache = this._cache;
	
	    var changes = findChanges(this._renderedTiles || [], renderedTiles);
	
	    changes.added.forEach(function (url)
	    {
	        cache.acquire(url);
	    });
	
	    changes.removed.forEach(function (url)
	    {
	        cache.release(url);
	    });
	
	    if (changes.removed)
	    {
	        // FIXME: Should only need to update the composite images
	        // for which tiles were removed
	        this._renderedPages.forEach(function (pageIndex)
	        {
	            this._compositeImages[pageIndex].updateFromCache(this._cache);
	        }, this);
	    }
	
	    this._renderedTiles = renderedTiles;
	};
	
	// Paint a page outline while the tiles are loading.
	Renderer.prototype._paintOutline = function (pages)
	{
	    pages.forEach(function (pageIndex)
	    {
	        var pageInfo = this.layout.getPageInfo(pageIndex);
	        var pageOffset = this._getImageOffset(pageIndex);
	
	        // Ensure the document is drawn to the center of the viewport
	        var viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);
	        var viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);
	
	        var viewportOffsetX = pageOffset.left - this._viewport.left + viewportPaddingX;
	        var viewportOffsetY = pageOffset.top - this._viewport.top + viewportPaddingY;
	
	        var destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;
	        var destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;
	
	        var canvasX = Math.max(0, viewportOffsetX);
	        var canvasY = Math.max(0, viewportOffsetY);
	
	        var destWidth = pageInfo.dimensions.width - destXOffset;
	        var destHeight = pageInfo.dimensions.height - destYOffset;
	
	        this._ctx.strokeStyle = '#AAA';
	        // In order to get a 1px wide line using strokes, we need to start at a 'half pixel'
	        this._ctx.strokeRect(canvasX + 0.5, canvasY + 0.5, destWidth, destHeight);
	    }, this);
	};
	
	// This method should be sent all visible pages at once because it will initiate
	// all image requests and cancel any remaining image requests. In the case that
	// a request is ongoing and the tile is still visible in the viewport, the old request
	// is kept active instead of restarting it. The image requests are given a timeout
	// before loading in order to debounce them and have a small reaction time
	// to cancel them and avoid useless requests.
	Renderer.prototype._initiateTileRequests = function(pages)
	{
	    // Only requests in this object are kept alive, since all others are not visible in the viewport
	    var newPendingRequests = {};
	
	    // Used later as a closure to initiate the image requests with the right source and pageIndex
	    var initiateRequest = function (source, pageIndex)
	    {
	        var composite = this._compositeImages[pageIndex];
	
	        newPendingRequests[source.url] = new ImageRequestHandler({
	            url: source.url,
	            timeoutTime: REQUEST_DEBOUNCE_INTERVAL,
	            load: function (img)
	            {
	                delete this._pendingRequests[source.url];
	                this._cache.put(source.url, img);
	
	                // Awkward way to check for updates
	                if (composite === this._compositeImages[pageIndex])
	                {
	                    composite.updateWithLoadedUrls([source.url]);
	
	                    if (this._isTileForSourceVisible(pageIndex, source))
	                        this._paint();
	                    else
	                        debugPaints('Page %s, tile %s no longer visible on image load', pageIndex, source.url);
	                }
	            }.bind(this),
	            error: function ()
	            {
	                // TODO: Could make a limited number of retries, etc.
	                delete this._pendingRequests[source.url];
	            }.bind(this)
	        });
	    }.bind(this);
	
	    for (var i = 0; i < pages.length; i++)
	    {
	        var pageIndex = pages[i];
	        var tiles = this._sourceResolver.getBestZoomLevelForPage(this.layout.getPageInfo(pageIndex)).tiles;
	
	        for (var j = 0; j < tiles.length; j++)
	        {
	            var source = tiles[j];
	            if (this._cache.has(source.url) || !this._isTileForSourceVisible(pageIndex, source))
	                continue;
	
	            // Don't create a new request if the tile is already being loaded
	            if (this._pendingRequests[source.url])
	            {
	                newPendingRequests[source.url] = this._pendingRequests[source.url];
	                delete this._pendingRequests[source.url];
	                continue;
	            }
	
	            // Use a closure since the load and error methods are going to be called later and
	            // we need to keep the right reference to the source and the page index
	            initiateRequest(source, pageIndex);
	        }
	    }
	
	    for (var url in this._pendingRequests)
	        this._pendingRequests[url].abort();
	    this._pendingRequests = newPendingRequests;
	};
	
	Renderer.prototype._drawTile = function (pageIndex, scaledTile, img)
	{
	    var tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);
	
	    // Ensure the document is drawn to the center of the viewport
	    var viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);
	    var viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);
	
	    var viewportOffsetX = tileOffset.left - this._viewport.left + viewportPaddingX;
	    var viewportOffsetY = tileOffset.top - this._viewport.top + viewportPaddingY;
	
	    var destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;
	    var destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;
	
	    var sourceXOffset = destXOffset / scaledTile.scaleRatio;
	    var sourceYOffset = destYOffset / scaledTile.scaleRatio;
	
	    var canvasX = Math.max(0, viewportOffsetX);
	    var canvasY = Math.max(0, viewportOffsetY);
	
	    // Ensure that the specified dimensions are no greater than the actual
	    // size of the image. Safari won't display the tile if they are.
	    var destWidth = Math.min(scaledTile.dimensions.width, img.width * scaledTile.scaleRatio) - destXOffset;
	    var destHeight = Math.min(scaledTile.dimensions.height, img.height * scaledTile.scaleRatio) - destYOffset;
	
	    var sourceWidth = destWidth / scaledTile.scaleRatio;
	    var sourceHeight = destHeight / scaledTile.scaleRatio;
	
	    if (debugPaints.enabled) {
	        debugPaints('Drawing page %s, tile %sx (%s, %s) from %s, %s to viewport at %s, %s, scale %s%%',
	            pageIndex,
	            scaledTile.sourceZoomLevel, scaledTile.row, scaledTile.col,
	            sourceXOffset, sourceYOffset,
	            canvasX, canvasY,
	            Math.round(scaledTile.scaleRatio * 100));
	    }
	
	    this._ctx.drawImage(
	        img,
	        sourceXOffset, sourceYOffset,
	        sourceWidth, sourceHeight,
	        canvasX, canvasY,
	        destWidth, destHeight);
	};
	
	Renderer.prototype._isTileForSourceVisible = function (pageIndex, tileSource)
	{
	    return this._isTileVisible(pageIndex, getScaledTileRecord(tileSource, this._zoomLevel));
	};
	
	Renderer.prototype._isTileVisible = function (pageIndex, scaledTile)
	{
	    var tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);
	
	    // FIXME(wabain): This check is insufficient during a zoom transition
	    return this._viewport.intersectsRegion({
	        top: tileOffset.top,
	        bottom: tileOffset.top + scaledTile.dimensions.height,
	        left: tileOffset.left,
	        right: tileOffset.left + scaledTile.dimensions.width
	    });
	};
	
	Renderer.prototype._getTileToDocumentOffset = function (pageIndex, scaledTile)
	{
	    var imageOffset = this._getImageOffset(pageIndex);
	
	    return {
	        top: imageOffset.top + scaledTile.offset.top,
	        left: imageOffset.left + scaledTile.offset.left
	    };
	};
	
	Renderer.prototype._getImageOffset = function (pageIndex)
	{
	    return this.layout.getPageOffset(pageIndex, {excludePadding: true});
	};
	
	// TODO: Update signature
	Renderer.prototype.goto = function (pageIndex, verticalOffset, horizontalOffset)
	{
	    this._clearAnimation();
	    this._goto(pageIndex, verticalOffset, horizontalOffset);
	    if (this._hooks.onViewDidUpdate)
	    {
	        this._hooks.onViewDidUpdate(this._renderedPages.slice(), pageIndex);
	    }
	};
	
	Renderer.prototype._goto = function (pageIndex, verticalOffset, horizontalOffset)
	{
	    // FIXME(wabain): Move this logic to the viewer
	    var pageOffset = this.layout.getPageOffset(pageIndex);
	
	    var desiredVerticalCenter = pageOffset.top + verticalOffset;
	    var top = desiredVerticalCenter - parseInt(this._viewport.height / 2, 10);
	
	    var desiredHorizontalCenter = pageOffset.left + horizontalOffset;
	    var left = desiredHorizontalCenter - parseInt(this._viewport.width / 2, 10);
	
	    this._viewport.top = top;
	    this._viewport.left = left;
	
	    this._render(0);
	};
	
	Renderer.prototype.transitionViewportPosition = function (options)
	{
	    this._clearAnimation();
	
	    var getPosition = options.getPosition;
	    var self = this;
	
	    var onViewDidTransition = this._hooks.onViewDidTransition;
	
	    this._animation = InterpolateAnimation.animate({
	        duration: options.duration,
	        parameters: options.parameters,
	        onUpdate: function (values)
	        {
	            // TODO: Do image preloading, work with that
	            self._setViewportPosition(getPosition(values));
	
	            if (onViewDidTransition)
	                onViewDidTransition();
	        },
	        onEnd: function (info)
	        {
	            if (options.onEnd)
	                options.onEnd(info);
	
	            if (self._hooks.onViewDidUpdate && !info.interrupted)
	            {
	                self._hooks.onViewDidUpdate(self._renderedPages.slice(), null);
	            }
	        }
	    });
	};
	
	Renderer.prototype._clearAnimation = function ()
	{
	    if (this._animation)
	    {
	        this._animation.cancel();
	        this._animation = null;
	    }
	};
	
	Renderer.prototype.preload = function ()
	{
	    // TODO
	};
	
	Renderer.prototype.isPageVisible = function (pageIndex)
	{
	    if (!this.layout)
	        return false;
	
	    var page = this.layout.getPageInfo(pageIndex);
	
	    if (!page)
	        return false;
	
	    return this._viewport.intersectsRegion(this.layout.getPageRegion(pageIndex));
	};
	
	Renderer.prototype.getRenderedPages = function ()
	{
	    return this._renderedPages.slice();
	};
	
	Renderer.prototype.destroy = function ()
	{
	    this._clearAnimation();
	
	    // FIXME(wabain): I don't know if we should actually do this
	    Object.keys(this._pendingRequests).forEach(function (req)
	    {
	        var handler = this._pendingRequests[req];
	        delete this._pendingRequests[req];
	
	        handler.abort();
	    }, this);
	
	    this._canvas.parentNode.removeChild(this._canvas);
	};
	
	function getScaledTileRecord(source, scaleFactor)
	{
	    var scaleRatio;
	
	    if (scaleFactor === null)
	        scaleRatio = 1;
	    else
	        scaleRatio = Math.pow(2, scaleFactor - source.zoomLevel);
	
	    return {
	        sourceZoomLevel: source.zoomLevel,
	        scaleRatio: scaleRatio,
	        row: source.row,
	        col: source.col,
	        dimensions: {
	            width: source.dimensions.width * scaleRatio,
	            height: source.dimensions.height * scaleRatio
	        },
	        offset: {
	            left: source.offset.left * scaleRatio,
	            top: source.offset.top * scaleRatio
	        },
	        url: source.url
	    };
	}
	
	function findChanges(oldArray, newArray)
	{
	    if (oldArray === newArray)
	    {
	        return {
	            added: [],
	            removed: []
	        };
	    }
	
	    var removed = oldArray.filter(function (oldEntry)
	    {
	        return newArray.indexOf(oldEntry) === -1;
	    });
	
	    var added = newArray.filter(function (newEntry)
	    {
	        return oldArray.indexOf(newEntry) === -1;
	    });
	
	    return {
	        added: added,
	        removed: removed
	    };
	}


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(29);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(30);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 30 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = CompositeImage;
	
	/**
	 * @class CompositeImage
	 * @private
	 *
	 * Utility class to composite tiles into a complete image
	 * and track the rendered state of an image as new tiles
	 * load.
	 */
	
	/**
	 * @param levels {Array.<Array.<Tile>>}
	 * @constructor
	 */
	function CompositeImage(levels)
	{
	    this._levels = levels;  // Assume levels sorted high-res first
	    var urlsToTiles = this._urlsToTiles = {};
	
	    levels.forEach(function (level)
	    {
	        level.tiles.forEach(function (tile)
	        {
	            urlsToTiles[tile.url] = {
	                zoomLevel: level.zoomLevel,
	                row: tile.row,
	                col: tile.col
	            };
	        });
	    });
	
	    this.clear();
	}
	
	CompositeImage.prototype.clear = function ()
	{
	    var loadedByLevel = this._loadedByLevel = {};
	
	    this._levels.forEach(function (level)
	    {
	        loadedByLevel[level.zoomLevel] = new TileCoverageMap(level.rows, level.cols);
	    });
	};
	
	CompositeImage.prototype.getTiles = function (baseZoomLevel)
	{
	    var toRenderByLevel = [];
	    var highestZoomLevel = this._levels[0].zoomLevel;
	    var covered = new TileCoverageMap(this._levels[0].rows, this._levels[0].cols);
	
	    var bestLevelIndex;
	
	    // Default to the lowest zoom level
	    if (baseZoomLevel === null)
	    {
	        bestLevelIndex = 0;
	    }
	    else
	    {
	        var ceilLevel = Math.ceil(baseZoomLevel);
	        bestLevelIndex = findIndex(this._levels, function (level)
	        {
	            return level.zoomLevel <= ceilLevel;
	        });
	    }
	
	
	    // The best level, followed by higher-res levels in ascending order of resolution,
	    // followed by lower-res levels in descending order of resolution
	    var levelsByPreference = this._levels.slice(0, bestLevelIndex + 1).reverse()
	        .concat(this._levels.slice(bestLevelIndex + 1));
	
	    levelsByPreference.forEach(function (level)
	    {
	        var loaded = this._loadedByLevel[level.zoomLevel];
	
	        var additionalTiles = level.tiles.filter(function (tile)
	        {
	            return loaded.isLoaded(tile.row, tile.col);
	        });
	
	        // Filter out entirely covered tiles
	
	        // FIXME: Is it better to draw all of a partially covered tile,
	        // with some of it ultimately covered, or to pick out the region
	        // which needs to be drawn?
	
	        var scaleRatio = Math.pow(2, highestZoomLevel - level.zoomLevel);
	
	        additionalTiles = additionalTiles.filter(function (tile)
	        {
	            var isNeeded = false;
	
	            var highResRow = tile.row * scaleRatio;
	            var highResCol = tile.col * scaleRatio;
	
	            for (var i=0; i < scaleRatio; i++)
	            {
	                for (var j=0; j < scaleRatio; j++)
	                {
	                    if (!covered.isLoaded(highResRow + i, highResCol + j))
	                    {
	                        isNeeded = true;
	                        covered.set(highResRow + i, highResCol + j, true);
	                    }
	                }
	            }
	
	            return isNeeded;
	        });
	
	        toRenderByLevel.push(additionalTiles);
	    }, this);
	
	    // Less-preferred tiles should come first
	    toRenderByLevel.reverse();
	
	    var tiles = [];
	
	    toRenderByLevel.forEach(function (byLevel)
	    {
	        tiles.push.apply(tiles, byLevel);
	    });
	
	    return tiles;
	};
	
	/**
	 * Update the composite image to take into account all the URLs
	 * loaded in an image cache.
	 *
	 * @param cache {ImageCache}
	 */
	CompositeImage.prototype.updateFromCache = function (cache)
	{
	    this.clear();
	
	    this._levels.forEach(function (level)
	    {
	        var loaded = this._loadedByLevel[level.zoomLevel];
	
	        level.tiles.forEach(function (tile)
	        {
	            if (cache.has(tile.url))
	                loaded.set(tile.row, tile.col, true);
	        });
	    }, this);
	};
	
	CompositeImage.prototype.updateWithLoadedUrls = function (urls)
	{
	    urls.forEach(function (url)
	    {
	        var entry = this._urlsToTiles[url];
	        this._loadedByLevel[entry.zoomLevel].set(entry.row, entry.col, true);
	    }, this);
	};
	
	function TileCoverageMap(rows, cols)
	{
	    this._rows = rows;
	    this._cols = cols;
	
	    this._map = fill(rows).map(function ()
	    {
	        return fill(cols, false);
	    });
	}
	
	TileCoverageMap.prototype.isLoaded = function (row, col)
	{
	    // Return true for out of bounds tiles because they
	    // don't need to load. (Unfortunately this will also
	    // mask logical errors.)
	    if (row >= this._rows || col >= this._cols)
	        return true;
	
	    return this._map[row][col];
	};
	
	TileCoverageMap.prototype.set = function (row, col, value)
	{
	    this._map[row][col] = value;
	};
	
	function fill(count, value)
	{
	    var arr = new Array(count);
	
	    for (var i=0; i < count; i++)
	        arr[i] = value;
	
	    return arr;
	}
	
	function findIndex(array, predicate)
	{
	    var length = array.length;
	    for (var i = 0; i < length; i++)
	    {
	        if (predicate(array[i], i))
	            return i;
	    }
	
	    return -1;
	}


/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = DocumentLayout;
	
	/**
	 * Translate page layouts, as generated by page-layouts, into an
	 * object which computes layout information for the document as
	 * a whole.
	 */
	function DocumentLayout(config, zoomLevel)
	{
	    var computedLayout = getComputedLayout(config, zoomLevel);
	
	    this.dimensions = computedLayout.dimensions;
	    this.pageGroups = computedLayout.pageGroups;
	    this._pageLookup = getPageLookup(computedLayout.pageGroups);
	}
	
	/**
	 * @typedef {Object} PageInfo
	 * @property {number} index
	 * @property {{index, dimensions, pages, region, padding}} group
	 * @property {{height: number, width: number}} dimensions
	 * @property {{top: number, left: number}} groupOffset
	 */
	
	/**
	 * @param pageIndex
	 * @returns {PageInfo|null}
	 */
	DocumentLayout.prototype.getPageInfo = function (pageIndex)
	{
	    return this._pageLookup[pageIndex] || null;
	};
	
	/**
	 * Get the dimensions of a page
	 *
	 * @param pageIndex
	 * @returns {{height: number, width: number}}
	 */
	DocumentLayout.prototype.getPageDimensions = function (pageIndex)
	{
	    if (!this._pageLookup || !this._pageLookup[pageIndex])
	        return null;
	
	    var region = getPageRegionFromPageInfo(this._pageLookup[pageIndex]);
	
	    return {
	        height: region.bottom - region.top,
	        width: region.right - region.left
	    };
	};
	
	// TODO(wabain): Get rid of this; it's a subset of the page region, so
	// give that instead
	/**
	 * Get the top-left coordinates of a page, including*** padding
	 *
	 * @param pageIndex
	 * @param options
	 * @returns {{top: number, left: number} | null}
	 */
	DocumentLayout.prototype.getPageOffset = function (pageIndex, options)
	{
	    var region = this.getPageRegion(pageIndex, options);
	
	    if (!region)
	        return null;
	
	    return {
	        top: region.top,
	        left: region.left
	    };
	};
	
	DocumentLayout.prototype.getPageRegion = function (pageIndex, options)
	{
	    var pageInfo = this._pageLookup[pageIndex];
	
	    if (!pageInfo)
	        return null;
	
	    var region = getPageRegionFromPageInfo(pageInfo);
	
	    if (options && options.excludePadding)
	    {
	        // FIXME?
	        var padding = pageInfo.group.padding;
	
	        return {
	            top: region.top + padding.top,
	            left: region.left + padding.left,
	            bottom: region.bottom,
	            right: region.right
	        };
	    }
	
	    return region;
	};
	
	/**
	 * Get the distance from the top-right of the page to the center of the
	 * specified viewport region
	 *
	 * @param pageIndex
	 * @param viewport {{top: number, left: number, bottom: number, right: number}}
	 * @returns {{x: number, y: number}}
	 */
	DocumentLayout.prototype.getPageToViewportCenterOffset = function (pageIndex, viewport)
	{
	    var scrollLeft = viewport.left;
	    var elementWidth = viewport.right - viewport.left;
	
	    var offset = this.getPageOffset(pageIndex);
	
	    var x = scrollLeft - offset.left + parseInt(elementWidth / 2, 10);
	
	    var scrollTop = viewport.top;
	    var elementHeight = viewport.bottom - viewport.top;
	
	    var y = scrollTop - offset.top + parseInt(elementHeight / 2, 10);
	
	    return {
	        x: x,
	        y: y
	    };
	};
	
	function getPageRegionFromPageInfo(page)
	{
	    var top    = page.groupOffset.top  + page.group.region.top;
	    var bottom = top + page.dimensions.height;
	    var left   = page.groupOffset.left + page.group.region.left;
	    var right  = left + page.dimensions.width;
	
	    return {
	        top: top,
	        bottom: bottom,
	        left: left,
	        right: right
	    };
	}
	
	function getPageLookup(pageGroups)
	{
	    var pageLookup = {};
	
	    pageGroups.forEach(function (group)
	    {
	        group.pages.forEach(function (page)
	        {
	            pageLookup[page.index] = {
	                index: page.index,
	                group: group,
	                dimensions: page.dimensions,
	                groupOffset: page.groupOffset
	            };
	        });
	    });
	
	    return pageLookup;
	}
	
	function getComputedLayout(config, zoomLevel)
	{
	    var scaledLayouts = zoomLevel === null ? config.pageLayouts : getScaledPageLayouts(config, zoomLevel);
	
	    var documentSecondaryExtent = getExtentAlongSecondaryAxis(config, scaledLayouts);
	
	    // The current position in the document along the primary axis
	    var primaryDocPosition = config.verticallyOriented ?
	        config.padding.document.top :
	        config.padding.document.left;
	
	    var pageGroups = [];
	
	    // TODO: Use bottom, right as well
	    var pagePadding = {
	        top: config.padding.page.top,
	        left: config.padding.page.left
	    };
	
	    scaledLayouts.forEach(function (layout, index)
	    {
	        var top, left;
	
	        if (config.verticallyOriented)
	        {
	            top = primaryDocPosition;
	            left = (documentSecondaryExtent - layout.dimensions.width) / 2;
	        }
	        else
	        {
	            top = (documentSecondaryExtent - layout.dimensions.height) / 2;
	            left = primaryDocPosition;
	        }
	
	        var region = {
	            top: top,
	            bottom: top + pagePadding.top + layout.dimensions.height,
	            left: left,
	            right: left + pagePadding.left + layout.dimensions.width
	        };
	
	        pageGroups.push({
	            index: index,
	            dimensions: layout.dimensions,
	            pages: layout.pages,
	            region: region,
	            padding: pagePadding
	        });
	
	        primaryDocPosition = config.verticallyOriented ? region.bottom : region.right;
	    });
	
	    var height, width;
	
	    if (config.verticallyOriented)
	    {
	        height = primaryDocPosition + pagePadding.top;
	        width = documentSecondaryExtent;
	    }
	    else
	    {
	        height = documentSecondaryExtent;
	        width = primaryDocPosition + pagePadding.left;
	    }
	
	    return {
	        dimensions: {
	            height: height,
	            width: width
	        },
	        pageGroups: pageGroups
	    };
	}
	
	function getScaledPageLayouts(config, zoomLevel)
	{
	    var scaleRatio = Math.pow(2, zoomLevel - config.maxZoomLevel);
	
	    return config.pageLayouts.map(function (group)
	    {
	        return {
	            dimensions: scaleDimensions(group.dimensions, scaleRatio),
	            pages: group.pages.map(function (page)
	            {
	                return {
	                    index: page.index,
	                    groupOffset: {
	                        top: Math.floor(page.groupOffset.top * scaleRatio),
	                        left: Math.floor(page.groupOffset.left * scaleRatio)
	                    },
	                    dimensions: scaleDimensions(page.dimensions, scaleRatio)
	                };
	            })
	        };
	    });
	}
	
	function scaleDimensions(dimensions, scaleRatio)
	{
	    return {
	        height: Math.floor(dimensions.height * scaleRatio),
	        width: Math.floor(dimensions.width * scaleRatio)
	    };
	}
	
	function getExtentAlongSecondaryAxis(config, scaledLayouts)
	{
	    // Get the extent of the document along the secondary axis
	    var secondaryDim, secondaryPadding;
	    var docPadding = config.padding.document;
	
	    if (config.verticallyOriented)
	    {
	        secondaryDim = 'width';
	        secondaryPadding = docPadding.left + docPadding.right;
	    }
	    else
	    {
	        secondaryDim = 'height';
	        secondaryPadding = docPadding.top + docPadding.bottom;
	    }
	
	    return secondaryPadding + scaledLayouts.reduce(function (maxDim, layout)
	    {
	        return Math.max(layout.dimensions[secondaryDim], maxDim);
	    }, 0);
	}


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = __webpack_require__(28)('diva:ImageCache');
	
	module.exports = ImageCache;
	
	/* FIXME(wabain): The caching strategy here is completely
	 * arbitrary and the implementation isn't especially efficient.
	 */
	
	var DEFAULT_MAX_KEYS = 100;
	
	function ImageCache(options)
	{
	    options = options || { maxKeys: DEFAULT_MAX_KEYS };
	    this.maxKeys = options.maxKeys || DEFAULT_MAX_KEYS;
	
	    this._held = {};
	    this._urls = {};
	    this._lru = [];
	}
	
	ImageCache.prototype.get = function (url)
	{
	    var record = this._urls[url];
	    return record ? record.img : null;
	};
	
	ImageCache.prototype.has = function (url)
	{
	    return !!this._urls[url];
	};
	
	ImageCache.prototype.put = function (url, img)
	{
	    var record = this._urls[url];
	    if (record)
	    {
	        // FIXME: Does this make sense for this use case?
	        record.img = img;
	        this._promote(record);
	    }
	    else
	    {
	        record = {
	            img: img,
	            url: url
	        };
	
	        this._urls[url] = record;
	        this._tryEvict(1);
	        this._lru.unshift(record);
	    }
	};
	
	ImageCache.prototype._promote = function (record)
	{
	    var index = this._lru.indexOf(record);
	    this._lru.splice(index, 1);
	    this._lru.unshift(record);
	};
	
	ImageCache.prototype._tryEvict = function (extraCapacity)
	{
	    var allowedEntryCount = this.maxKeys - extraCapacity;
	
	    if (this._lru.length <= allowedEntryCount)
	        return;
	
	    var evictionIndex = this._lru.length - 1;
	
	    for (;;)
	    {
	        var target = this._lru[evictionIndex];
	
	        if (!this._held[target.url])
	        {
	            debug('Evicting image %s', target.url);
	            this._lru.splice(evictionIndex, 1);
	            delete this._urls[target.url];
	
	            if (this._lru.length <= allowedEntryCount)
	                break;
	        }
	
	        if (evictionIndex === 0)
	        {
	            /* istanbul ignore next */
	            debug.enabled && debug('Cache overfull by %s (all entries are being held)',
	                this._lru.length - allowedEntryCount);
	
	            break;
	        }
	
	        evictionIndex--;
	    }
	};
	
	ImageCache.prototype.acquire = function (url)
	{
	    this._held[url] = (this._held[url] || 0) + 1;
	    this._promote(this._urls[url]);
	};
	
	ImageCache.prototype.release = function (url)
	{
	    var count = this._held[url];
	
	    if (count > 1)
	        this._held[url]--;
	    else
	        delete this._held[url];
	
	    this._tryEvict(0);
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var debug = __webpack_require__(28)('diva:ImageRequestHandler');
	
	module.exports = ImageRequestHandler;
	
	/**
	 * Handler for the request for an image tile
	 *
	 * @param url
	 * @param callback
	 * @constructor
	 */
	function ImageRequestHandler(options)
	{
	    this._url = options.url;
	    this._callback = options.load;
	    this._errorCallback = options.error;
	    this.timeoutTime = options.timeoutTime || 0;
	    this._aborted = this._complete = false;
	
	    //Use a timeout to allow the requests to be debounced (as they are in renderer)
	    this.timeout = setTimeout(function()
	    {
	        // Initiate the request
	        this._image = new Image();
	        this._image.crossOrigin = "anonymous";
	        this._image.onload = this._handleLoad.bind(this);
	        this._image.onerror = this._handleError.bind(this);
	        this._image.src = options.url;
	
	        debug('Requesting image %s', options.url);
	    }.bind(this), this.timeoutTime);
	}
	
	ImageRequestHandler.prototype.abort = function ()
	{
	    debug('Aborting request to %s', this._url);
	
	    clearTimeout(this.timeout);
	
	    // FIXME
	    // People on the Internet say that doing this {{should/should not}} abort the request. I believe
	    // it corresponds to what the WHATWG HTML spec says should happen when the UA
	    // updates the image data if selected source is null.
	    //
	    // Sources:
	    //
	    // https://html.spec.whatwg.org/multipage/embedded-content.html#the-img-element
	    // http://stackoverflow.com/questions/7390888/does-changing-the-src-attribute-of-an-image-stop-the-image-from-downloading
	    if (this._image)
	    {
	        this._image.onload = this._image.onerror = null;
	
	        this._image.src = '';
	    }
	
	    this._aborted = true;
	};
	
	ImageRequestHandler.prototype._handleLoad = function ()
	{
	    if (this._aborted)
	    {
	        console.error('ImageRequestHandler invoked on cancelled request for ' + this._url);
	        return;
	    }
	
	    if (this._complete)
	    {
	        console.error('ImageRequestHandler invoked on completed request for ' + this._url);
	        return;
	    }
	
	    this._complete = true;
	
	    debug('Received image %s', this._url);
	    this._callback(this._image);
	};
	
	ImageRequestHandler.prototype._handleError = function ()
	{
	    debug('Failed to load image %s', this._url);
	    this._errorCallback(this._image);
	};


/***/ },
/* 35 */
/***/ function(module, exports) {

	/* global performance */
	
	// TODO: requestAnimationFrame fallback
	
	module.exports = {
	    animate: animate,
	    easing: {
	        linear: linearEasing
	    }
	};
	
	function animate(options)
	{
	    var durationMs = options.duration;
	    var parameters = options.parameters;
	    var onUpdate = options.onUpdate;
	    var onEnd = options.onEnd;
	
	    // Setup
	    // Times are in milliseconds from a basically arbitrary start
	    var start = now();
	    var end = start + durationMs;
	
	    var tweenFns = {};
	    var values = {};
	    var paramKeys = Object.keys(parameters);
	
	    paramKeys.forEach(function (key)
	    {
	        var config = parameters[key];
	        tweenFns[key] = interpolate(config.from, config.to, config.easing || linearEasing);
	    });
	
	    // Run it!
	    var requestId = requestAnimationFrame(update);
	
	    return {
	        cancel: function ()
	        {
	            if (requestId !== null)
	            {
	                cancelAnimationFrame(requestId);
	                handleAnimationCompletion({
	                    interrupted: true
	                });
	            }
	        }
	    };
	
	    function update()
	    {
	        var current = now();
	        var elapsed = Math.min((current - start) / durationMs, 1);
	
	        updateValues(elapsed);
	        onUpdate(values);
	
	        if (current < end)
	            requestId = requestAnimationFrame(update);
	        else
	            handleAnimationCompletion({
	                interrupted: false
	            });
	    }
	
	    function updateValues(elapsed)
	    {
	        paramKeys.forEach(function (key)
	        {
	            values[key] = tweenFns[key](elapsed);
	        });
	    }
	
	    function handleAnimationCompletion(info)
	    {
	        requestId = null;
	
	        if (onEnd)
	            onEnd(info);
	    }
	}
	
	function interpolate(start, end, easing)
	{
	    return function (elapsed)
	    {
	        return start + (end - start) * easing(elapsed);
	    };
	}
	
	function linearEasing(e)
	{
	    return e;
	}
	
	var now;
	
	if (typeof performance !== 'undefined' && performance.now)
	{
	    now = function ()
	    {
	        return performance.now();
	    };
	}
	else
	{
	    now = function ()
	    {
	        return Date.now();
	    };
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var getBookLayoutGroups = __webpack_require__(37);
	var getSinglesLayoutGroups = __webpack_require__(39);
	var getGridLayoutGroups = __webpack_require__(40);
	
	module.exports = getPageLayouts;
	
	/** Get the relative positioning of pages for the current view */
	function getPageLayouts(settings)
	{
	    if (settings.inGrid)
	    {
	        return getGridLayoutGroups(pluck(settings, [
	            'manifest',
	            'viewport',
	            'pagesPerRow',
	            'fixedHeightGrid',
	            'fixedPadding',
	            'showNonPagedPages'
	        ]));
	    }
	    else
	    {
	        var config = pluck(settings, ['manifest', 'verticallyOriented', 'showNonPagedPages']);
	
	        if (settings.inBookLayout)
	            return getBookLayoutGroups(config);
	        else
	            return getSinglesLayoutGroups(config);
	    }
	}
	
	function pluck(obj, keys)
	{
	    var out = {};
	    keys.forEach(function (key)
	    {
	        out[key] = obj[key];
	    });
	    return out;
	}


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var getPageDimensions = __webpack_require__(38);
	
	module.exports = getBookLayoutGroups;
	
	function getBookLayoutGroups(viewerConfig)
	{
	    var groupings = getGroupings(viewerConfig);
	
	    return groupings.map(function (grouping)
	    {
	        return getGroupLayoutsFromPageGrouping(viewerConfig, grouping);
	    });
	}
	
	function getGroupings(viewerConfig)
	{
	    var manifest = viewerConfig.manifest;
	
	    var pagesByGroup = [];
	    var leftPage = null;
	    var nonPagedPages = []; // Pages to display below the current group
	
	    var _addNonPagedPages = function()
	    {
	        for (var i = 0; i < nonPagedPages.length; i++)
	        {
	            pagesByGroup.push([ nonPagedPages[i] ]);
	        }
	        nonPagedPages = [];
	    };
	
	    manifest.pages.forEach(function (page, index)
	    {
	        var pageRecord = {
	            index: index,
	            dimensions: getPageDimensions(index, manifest),
	            paged: (!manifest.paged || page.paged)
	        };
	
	        // Only display non-paged pages if specified in the settings
	        if (!viewerConfig.showNonPagedPages && !pageRecord.paged)
	            return;
	
	        if (!pageRecord.paged)
	        {
	            nonPagedPages.push(pageRecord);
	        }
	        else if (index === 0 || page.facingPages)
	        {
	            // The first page is placed on its own
	            pagesByGroup.push([pageRecord]);
	            _addNonPagedPages();
	        }
	        else if (leftPage === null)
	        {
	            leftPage = pageRecord;
	        }
	        else
	        {
	            pagesByGroup.push([leftPage, pageRecord]);
	            leftPage = null;
	            _addNonPagedPages();
	        }
	    });
	
	    // Flush a final left page
	    if (leftPage !== null)
	    {
	        pagesByGroup.push([leftPage]);
	        _addNonPagedPages();
	    }
	
	    return pagesByGroup;
	}
	
	function getGroupLayoutsFromPageGrouping(viewerConfig, grouping)
	{
	    var verticallyOriented = viewerConfig.verticallyOriented;
	
	    if (grouping.length === 2)
	        return getFacingPageGroup(grouping[0], grouping[1], verticallyOriented);
	
	    var page = grouping[0];
	    var pageDims = page.dimensions;
	
	    // The first page is placed on its own to the right in vertical orientation.
	    // NB that this needs to be the page with index 0; if the first page is excluded
	    // from the layout then this special case shouldn't apply.
	    // If the page is tagged as 'non-paged', center it horizontally
	    var leftOffset;
	    if (page.paged)
	        leftOffset = (page.index === 0 && verticallyOriented) ? pageDims.width : 0;
	    else
	        leftOffset = (verticallyOriented) ? pageDims.width / 2 : 0;
	
	    var shouldBeHorizontallyAdjusted =
	        verticallyOriented && !viewerConfig.manifest.pages[page.index].facingPages;
	
	    // We need to left-align the page in vertical orientation, so we double
	    // the group width
	    return {
	        dimensions: {
	            height: pageDims.height,
	            width: shouldBeHorizontallyAdjusted ? pageDims.width * 2 : pageDims.width
	        },
	        pages: [{
	            index: page.index,
	            groupOffset: {
	                top: 0,
	                left: leftOffset
	            },
	            dimensions: pageDims
	        }]
	    };
	}
	
	function getFacingPageGroup(leftPage, rightPage, verticallyOriented)
	{
	    var leftDims = leftPage.dimensions;
	    var rightDims = rightPage.dimensions;
	
	    var height = Math.max(leftDims.height, rightDims.height);
	
	    var width, firstLeftOffset, secondLeftOffset;
	
	    if (verticallyOriented)
	    {
	        var midWidth = Math.max(leftDims.width, rightDims.width);
	
	        width = midWidth * 2;
	
	        firstLeftOffset = midWidth - leftDims.width;
	        secondLeftOffset = midWidth;
	    }
	    else
	    {
	        width = leftDims.width + rightDims.width;
	        firstLeftOffset = 0;
	        secondLeftOffset = leftDims.width;
	    }
	
	    return {
	        dimensions: {
	            height: height,
	            width: width
	        },
	        pages: [
	            {
	                index: leftPage.index,
	                dimensions: leftDims,
	                groupOffset: {
	                    top: 0,
	                    left: firstLeftOffset
	                }
	            },
	            {
	                index: rightPage.index,
	                dimensions: rightDims,
	                groupOffset: {
	                    top: 0,
	                    left: secondLeftOffset
	                }
	            }
	        ]
	    };
	}


/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = function getPageDimensions(pageIndex, manifest)
	{
	    var dims = manifest.getMaxPageDimensions(pageIndex);
	
	    return {
	        width: Math.floor(dims.width),
	        height: Math.floor(dims.height)
	    };
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var getPageDimensions = __webpack_require__(38);
	
	module.exports = function getSinglesLayoutGroups(viewerConfig)
	{
	    var manifest = viewerConfig.manifest;
	
	    // Render each page alone in a group
	    var pages = [];
	    manifest.pages.forEach(function (page, index)
	    {
	        if (!viewerConfig.showNonPagedPages && manifest.paged && !page.paged)
	            return;
	
	        var pageDims = getPageDimensions(index, manifest);
	
	        pages.push({
	            dimensions: pageDims,
	            pages: [
	                {
	                    index: index,
	                    groupOffset: {top: 0, left: 0},
	                    dimensions: pageDims
	                }
	            ]
	        });
	    });
	
	    return pages;
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = getGridLayoutGroups;
	
	function getGridLayoutGroups(viewerConfig)
	{
	    var viewportWidth = viewerConfig.viewport.width;
	    var manifest = viewerConfig.manifest;
	    var pagesPerRow = viewerConfig.pagesPerRow;
	    var fixedHeightGrid = viewerConfig.fixedHeightGrid;
	    var fixedPadding = viewerConfig.fixedPadding;
	    var showNonPagedPages = viewerConfig.showNonPagedPages;
	
	    var horizontalPadding = fixedPadding * (pagesPerRow + 1);
	    var pageWidth = (viewportWidth - horizontalPadding) / pagesPerRow;
	    var gridPageWidth = pageWidth;
	
	    // Calculate the row height depending on whether we want to fix the width or the height
	    var rowHeight = (fixedHeightGrid) ? fixedPadding + manifest.minRatio * pageWidth : fixedPadding + manifest.maxRatio * pageWidth;
	
	    var groups = [];
	    var currentPages = [];
	
	    var getGridPageDimensions = function (pageData)
	    {
	        // Calculate the width, height and horizontal placement of this page
	        // Get dimensions at max zoom level, although any level should be fine
	        var pageDimenData = pageData.d[pageData.d.length - 1];
	        var heightToWidthRatio = pageDimenData.h / pageDimenData.w;
	
	        var pageWidth, pageHeight;
	
	        if (fixedHeightGrid)
	        {
	            pageWidth = (rowHeight - fixedPadding) / heightToWidthRatio;
	            pageHeight = rowHeight - fixedPadding;
	        }
	        else
	        {
	            pageWidth = gridPageWidth;
	            pageHeight = pageWidth * heightToWidthRatio;
	        }
	
	        return {
	            width: Math.round(pageWidth),
	            height: Math.round(pageHeight)
	        };
	    };
	
	    var rowDimensions = {
	        height: rowHeight,
	        width: viewportWidth
	    };
	
	    manifest.pages.forEach(function (page, pageIndex)
	    {
	        if (!showNonPagedPages && manifest.paged && !page.paged)
	            return;
	
	        // Calculate the width, height and horizontal placement of this page
	        var pageDimens = getGridPageDimensions(page);
	        var leftOffset = Math.floor(currentPages.length * (fixedPadding + gridPageWidth) + fixedPadding);
	
	        // Center the page if the height is fixed (otherwise, there is no horizontal padding)
	        if (fixedHeightGrid)
	        {
	            leftOffset += (gridPageWidth - pageDimens.width) / 2;
	        }
	
	        // TODO: Precompute page dimensions everywhere
	        currentPages.push({
	            index: pageIndex,
	            dimensions: pageDimens,
	            groupOffset: {
	                top: 0,
	                left: leftOffset
	            }
	        });
	
	        if (currentPages.length === pagesPerRow)
	        {
	            groups.push({
	                dimensions: rowDimensions,
	                pages: currentPages
	            });
	
	            currentPages = [];
	        }
	    });
	
	    if (currentPages.length > 0)
	    {
	        groups.push({
	            dimensions: rowDimensions,
	            pages: currentPages
	        });
	    }
	
	    return groups;
	}


/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = createSettingsView;
	
	function createSettingsView(sources)
	{
	    var obj = {};
	
	    sources.forEach(function (source)
	    {
	        registerMixin(obj, source);
	    });
	
	    return obj;
	}
	
	function registerMixin(obj, mixin)
	{
	    Object.keys(mixin).forEach(function (key)
	    {
	        Object.defineProperty(obj, key, {
	            get: function ()
	            {
	                return mixin[key];
	            },
	            set: function ()
	            {
	                // TODO: Make everything strict mode so this isn't needed
	                throw new TypeError('Cannot set settings.' + key);
	            }
	        });
	    });
	}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var extend = __webpack_require__(3).extend;
	
	module.exports = ValidationRunner;
	
	function ValidationRunner(options)
	{
	    this.whitelistedKeys = options.whitelistedKeys || [];
	    this.additionalProperties = options.additionalProperties || [];
	    this.validations = options.validations;
	}
	
	ValidationRunner.prototype.isValid = function (key, value, settings)
	{
	    // Get the validation index
	    var validationIndex = null;
	
	    this.validations.some(function (validation, index)
	    {
	        if (validation.key !== key)
	            return false;
	
	        validationIndex = index;
	        return true;
	    });
	
	    if (validationIndex === null)
	        return true;
	
	    // Run the validation
	    var dummyChanges = {};
	    dummyChanges[key] = value;
	    var proxier = createSettingsProxier(settings, dummyChanges, this);
	
	    return !this._runValidation(validationIndex, value, proxier);
	};
	
	ValidationRunner.prototype.validate = function (settings)
	{
	    this._validateOptions({}, settings);
	};
	
	ValidationRunner.prototype.getValidatedOptions = function (settings, options)
	{
	    var cloned = extend({}, options);
	    this._validateOptions(settings, cloned);
	    return cloned;
	};
	
	ValidationRunner.prototype._validateOptions = function (settings, options)
	{
	    var settingsProxier = createSettingsProxier(settings, options, this);
	    this._applyValidations(options, settingsProxier);
	};
	
	ValidationRunner.prototype._applyValidations = function (options, proxier)
	{
	    this.validations.forEach(function (validation, index)
	    {
	        if (!options.hasOwnProperty(validation.key))
	            return;
	
	        var input = options[validation.key];
	        var corrected = this._runValidation(index, input, proxier);
	
	        if (corrected)
	        {
	            if (!corrected.warningSuppressed)
	                emitWarning(validation.key, input, corrected.value);
	
	            options[validation.key] = corrected.value;
	        }
	    }, this);
	};
	
	ValidationRunner.prototype._runValidation = function (index, input, proxier)
	{
	    var validation = this.validations[index];
	
	    proxier.index = index;
	
	    var warningSuppressed = false;
	    var config = {
	        suppressWarning: function ()
	        {
	            warningSuppressed = true;
	        }
	    };
	
	    var outputValue = validation.validate(input, proxier.proxy, config);
	
	    if (outputValue === undefined || outputValue === input)
	        return null;
	
	    return {
	        value: outputValue,
	        warningSuppressed: warningSuppressed
	    };
	};
	
	/**
	 * The settings proxy wraps the settings object and ensures that
	 * only values which have previously been validated are accessed,
	 * throwing a TypeError otherwise.
	 *
	 * FIXME(wabain): Is it worth keeping this? When I wrote it I had
	 * multiple validation stages and it was a lot harder to keep track
	 * of everything, so this was more valuable.
	 */
	function createSettingsProxier(settings, options, runner)
	{
	    var proxier = {
	        proxy: {},
	        index: null
	    };
	
	    var lookup = lookupValue.bind(null, settings, options);
	
	    var properties = {};
	
	    runner.whitelistedKeys.forEach(function (whitelisted)
	    {
	        properties[whitelisted] = {
	            get: lookup.bind(null, whitelisted)
	        };
	    });
	
	    runner.additionalProperties.forEach(function (additional)
	    {
	        properties[additional.key] = {
	            get: additional.get
	        };
	    });
	
	    runner.validations.forEach(function (validation, validationIndex)
	    {
	        properties[validation.key] = {
	            get: function ()
	            {
	                if (validationIndex < proxier.index)
	                    return lookup(validation.key);
	
	                var currentKey = runner.validations[proxier.index].key;
	                throw new TypeError('Cannot access setting ' + validation.key + ' while validating ' + currentKey);
	            }
	        };
	    });
	
	    Object.defineProperties(proxier.proxy, properties);
	
	    return proxier;
	}
	
	function emitWarning(key, original, corrected)
	{
	    console.warn('Invalid value for ' + key + ': ' + original + '. Using ' + corrected + ' instead.');
	}
	
	function lookupValue(base, extension, key)
	{
	    if (key in extension)
	        return extension[key];
	
	    return base[key];
	}


/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = Viewport;
	
	function Viewport(outer, options)
	{
	    options = options || {};
	
	    this.intersectionTolerance = options.intersectionTolerance || 0;
	    this.maxExtent = options.maxExtent || 2000;
	
	    this.outer = outer;
	
	    this._top = this._left = this._width = this._height = this._innerDimensions = null;
	
	    this.invalidate();
	}
	
	Viewport.prototype.intersectsRegion = function (region)
	{
	    return this.hasHorizontalOverlap(region) && this.hasVerticalOverlap(region);
	};
	
	Viewport.prototype.hasVerticalOverlap = function (region)
	{
	    var top = this.top - this.intersectionTolerance;
	    var bottom = this.bottom + this.intersectionTolerance;
	
	    return (
	        fallsBetween(region.top, top, bottom) ||
	        fallsBetween(region.bottom, top, bottom) ||
	        (region.top <= top && region.bottom >= bottom)
	    );
	};
	
	Viewport.prototype.hasHorizontalOverlap = function (region)
	{
	    var left = this.left - this.intersectionTolerance;
	    var right = this.right + this.intersectionTolerance;
	
	    return (
	        fallsBetween(region.left, left, right) ||
	        fallsBetween(region.right, left, right) ||
	        (region.left <= left && region.right >= right)
	    );
	};
	
	Viewport.prototype.invalidate = function ()
	{
	    // FIXME: Should this check the inner dimensions as well?
	    this._width = clampMax(this.outer.clientWidth, this.maxExtent);
	    this._height = clampMax(this.outer.clientHeight, this.maxExtent);
	
	    this._top = this.outer.scrollTop;
	    this._left = this.outer.scrollLeft;
	};
	
	Viewport.prototype.setInnerDimensions = function (dimensions)
	{
	    this._innerDimensions = dimensions;
	
	    if (dimensions)
	    {
	        this._top = clamp(this._top, 0, dimensions.height - this._height);
	        this._left = clamp(this._left, 0, dimensions.width - this._width);
	    }
	};
	
	Object.defineProperties(Viewport.prototype, {
	    top: getCoordinateDescriptor('top', 'height'),
	    left: getCoordinateDescriptor('left', 'width'),
	
	    width: getDimensionDescriptor('width'),
	    height: getDimensionDescriptor('height'),
	
	    bottom: {
	        get: function ()
	        {
	            return this._top + this._height;
	        }
	    },
	    right: {
	        get: function ()
	        {
	            return this._left + this._width;
	        }
	    }
	});
	
	function getCoordinateDescriptor(coord, associatedDimension)
	{
	    var privateProp = '_' + coord;
	    var source = 'scroll' + coord.charAt(0).toUpperCase() + coord.slice(1);
	
	    return {
	        get: function ()
	        {
	            return this[privateProp];
	        },
	        set: function (newValue)
	        {
	            var normalized;
	
	            if (this._innerDimensions)
	            {
	                var maxAllowed = this._innerDimensions[associatedDimension] - this[associatedDimension];
	                normalized = clamp(newValue, 0, maxAllowed);
	            }
	            else
	            {
	                normalized = clampMin(newValue, 0);
	            }
	
	            this[privateProp] = this.outer[source] = normalized;
	        }
	    };
	}
	
	function getDimensionDescriptor(dimen)
	{
	    return {
	        get: function ()
	        {
	            return this['_' + dimen];
	        }
	    };
	}
	
	function fallsBetween(point, start, end)
	{
	    return point >= start && point <= end;
	}
	
	function clamp(value, min, max)
	{
	    return clampMin(clampMax(value, max), min);
	}
	
	function clampMin(value, min)
	{
	    return Math.max(value, min);
	}
	
	function clampMax(value, max)
	{
	    return Math.min(value, max);
	}


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/*
	
	Canvas plugin for diva.js
	Adds an adjustment icon next to each image
	
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	__webpack_require__(15);
	
	(function ($)
	{
	    module.exports = (function ()
	    {
	        var canvas = {},
	            map = {},
	            settings = {},
	            image,
	            sliders,
	            sliderMode;
	
	        // Set up some default settings (can be overridden the normal way)
	        var defaults = {
	            brightnessMax: 150,
	            brightnessMin: -100,
	            brightnessStep: 1,
	            contrastMax: 3,
	            contrastMin: -1,
	            contrastStep: 0.05,
	            localStoragePrefix: 'canvas-',
	            mobileWebkitMaxZoom: 2,
	            rgbMax: 50,
	            rgbMin: -50,
	            throbberFadeSpeed: 200,
	            throbberTimeout: 100,
	            buttons: [
	                'contrast',
	                'brightness',
	                'rotation',
	                'zoom'
	            ]
	        };
	
	        // Convert an angle from degrees to radians
	        var toRadians = function (angle)
	        {
	            return angle * Math.PI / 180;
	        };
	
	        // Determine the new center of the page after rotating by the given angle
	        var getNewCenter = function (currentCenter, angle)
	        {
	            var x = currentCenter.x - canvas.centerX;
	            // Take the negative because the rotation is counterclockwise
	            var y = -(currentCenter.y - canvas.centerY);
	
	            var theta = toRadians(sliders.rotation.previous - angle);
	            var newX = Math.cos(theta) * x - Math.sin(theta) * y + canvas.centerX;
	            var newY = -(Math.sin(theta) * x + Math.cos(theta) * y) + canvas.centerY;
	
	            return {'x': newX, 'y': newY};
	        };
	
	        // Rotates the image on the given canvas by the given angle
	        var rotateCanvas = function (aCanvas, angle)
	        {
	            var context = aCanvas.context;
	            var center = aCanvas.size / 2;
	            var startX = -(aCanvas.width / 2);
	            var startY = -(aCanvas.height / 2);
	
	            // Clear the canvas so that remnants of the old image don't show
	            context.clearRect(0, 0, aCanvas.size, aCanvas.size);
	
	            // Do the rotation
	            context.save();
	            context.translate(center, center);
	            context.rotate(toRadians(angle));
	            context.drawImage(image, startX, startY, aCanvas.width, aCanvas.height);
	            context.restore();
	
	            // Save the new pixel data so that it can later be adjusted in adjustLevels
	            aCanvas.data = context.getImageData(0, 0, aCanvas.size, aCanvas.size);
	        };
	
	        // Determine if we need to update the large canvas
	        var shouldAdjustLevels = function ()
	        {
	            var slider;
	
	            // Returns true if something has been changed
	            for (slider in sliders)
	            {
	                if (sliders[slider].current !== sliders[slider].previous)
	                {
	                    return true;
	                }
	            }
	
	            return false;
	        };
	
	        // Sets the "previous" value to the "current" value for every slider
	        var updatePreviousLevels = function ()
	        {
	            var slider;
	
	            for (slider in sliders)
	            {
	                sliders[slider].previous = sliders[slider].current;
	            }
	        };
	
	        // Update the thumbnail preview (called when a slider is moved/reset)
	        var updateMap = function ()
	        {
	            rotateCanvas(map, sliders.rotation.current);
	            adjustLevels(map);
	        };
	
	        // Update the large canvas (rotation, zooming, scrolling, pixel manipulation)
	        var updateCanvas = function ()
	        {
	            var angle = sliders.rotation.current;
	            var oldAngle = sliders.rotation.previous;
	            var zoomLevel = sliders.zoom.current;
	            var oldZoomLevel = sliders.zoom.previous;
	
	            // Scroll the user to the desired location
	            if (angle !== oldAngle || zoomLevel !== oldZoomLevel)
	            {
	                // First figure out the current center of the viewport
	                var leftScroll = $('#diva-canvas-wrapper').scrollLeft();
	                var topScroll = $('#diva-canvas-wrapper').scrollTop();
	                var leftOffset = settings.viewport.width / 2;
	                var topOffset = settings.viewport.height / 2;
	
	                // Then determine the new center (the same part of the image)
	                var newCenter = getNewCenter({x: leftScroll + leftOffset, y: topScroll + topOffset}, angle);
	
	                // Incorporate the zoom change ratio (would be 1 if no change)
	                var zoomChange = Math.pow(2, zoomLevel - oldZoomLevel);
	                var toLeftScroll = zoomChange * newCenter.x - leftOffset;
	                var toTopScroll = zoomChange * newCenter.y - topOffset;
	
	                // Rotate the large canvas
	                rotateCanvas(canvas, angle);
	
	                // Scroll to the new center
	                $('#diva-canvas-wrapper').scrollLeft(toLeftScroll);
	                $('#diva-canvas-wrapper').scrollTop(toTopScroll);
	            }
	
	            // Only call adjustLevels again if we really need to (expensive)
	            if (shouldAdjustLevels())
	            {
	                adjustLevels(canvas);
	                updatePreviousLevels();
	            }
	        };
	
	        // Copies the canvas' pixel array and returns the copy
	        var copyImageData = function (aCanvas)
	        {
	            var oldImageData = aCanvas.data;
	            var newImageData = aCanvas.context.createImageData(oldImageData);
	            var pixelArray = newImageData.data;
	            var i, length;
	
	            for (i = 0, length = pixelArray.length; i < length; i++)
	            {
	                pixelArray[i] = oldImageData.data[i];
	            }
	
	            return newImageData;
	        };
	
	        // Determines whether or not we need to adjust this level - very simple
	        var shouldAdjust = function (mode)
	        {
	            var thisChanged = sliders[mode].current !== sliders[mode].previous;
	            var thisNotDefault = sliders[mode].current !== sliders[mode].initial;
	
	            return thisChanged || thisNotDefault;
	        };
	
	        var adjustLevels = function (aCanvas)
	        {
	            // Copy the pixel array to avoid destructively modifying the original
	            var imageData = copyImageData(aCanvas);
	            var pixelArray = imageData.data;
	
	            // Store and calculate some scale factors and offsets
	            var brightness = sliders.brightness.current;
	            var contrast = sliders.contrast.current;
	
	            var brightMul = 1 + Math.min(settings.brightnessMax, Math.max(settings.brightnessMin, brightness)) / settings.brightnessMax;
	            var brightTimesContrast = brightMul * contrast;
	            var contrastOffset = 128 - (contrast * 128);
	
	            var redOffset = sliders.red.current;
	            var greenOffset = sliders.green.current;
	            var blueOffset = sliders.blue.current;
	
	            // Determine whether or not we need to adjust certain things
	            var adjustRed = shouldAdjust('red');
	            var adjustGreen = shouldAdjust('green');
	            var adjustBlue = shouldAdjust('blue');
	
	            var adjustBrightness = shouldAdjust('brightness');
	            var adjustContrast = shouldAdjust('contrast');
	            var adjustOthers = adjustBrightness || adjustContrast;
	
	            var x, y, width, height, offset, r, g, b;
	
	            for (x = 0, width = imageData.width; x < width; x++)
	            {
	                for (y = 0, height = imageData.height; y < height; y++)
	                {
	                    offset = (y * width + x) * 4;
	
	                    r = pixelArray[offset];
	                    g = pixelArray[offset + 1];
	                    b = pixelArray[offset + 2];
	
	                    // Only do something if the pixel is not black originally
	                    if (r + g + b > 0)
	                    {
	                        // Only adjust individual colour channels if necessary
	                        if (adjustRed && r)
	                            r += redOffset;
	
	                        if (adjustGreen && g)
	                            g += greenOffset;
	
	                        if (adjustBlue && b)
	                            b += blueOffset;
	
	                        // If we need to adjust brightness and/or contrast
	                        if (adjustOthers)
	                        {
	                            if (r)
	                                r = r * brightTimesContrast + contrastOffset;
	
	                            if (g)
	                                g = g * brightTimesContrast + contrastOffset;
	
	                            if (b)
	                                b = b * brightTimesContrast + contrastOffset;
	                        }
	
	                        pixelArray[offset] = r;
	                        pixelArray[offset + 1] = g;
	                        pixelArray[offset + 2] = b;
	                    }
	                }
	            }
	
	            aCanvas.context.clearRect(0, 0, width, height);
	            aCanvas.context.putImageData(imageData, 0, 0);
	        };
	
	        // Update the box in the preview showing where you currently are
	        var updateViewbox = function ()
	        {
	            // Determine the top left corner coordinates based on our current position
	            var cornerX = $('#diva-canvas-wrapper').scrollLeft() * map.scaleFactor;
	            var cornerY = $('#diva-canvas-wrapper').scrollTop() * map.scaleFactor;
	
	            // Subtract 4 to compensate for the borders
	            var height = Math.min(Math.round(settings.viewport.height * map.scaleFactor), settings.mapSize) - 4;
	            var width = Math.min(Math.round(settings.viewport.width * map.scaleFactor), settings.mapSize) - 4;
	
	            $('#diva-map-viewbox').height(height).width(width).css({top: cornerY, left: cornerX});
	        };
	
	        // Draw the thumbnail preview in the toolbar
	        var loadMap = function (image)
	        {
	            map.canvas = document.getElementById('diva-canvas-minimap');
	            map.size = settings.mapSize;
	            map.canvas.width = map.size;
	            map.canvas.height = map.size;
	
	            // Give it a black background
	            map.context = map.canvas.getContext('2d');
	            map.context.fillRect(0, 0, map.size, map.size);
	
	            // Determine the coordinates/dimensions of the preview
	            map.scaleFactor = settings.mapSize / canvas.size;
	            map.cornerX = canvas.cornerX * map.scaleFactor;
	            map.cornerY = canvas.cornerY * map.scaleFactor;
	            map.width = image.width * map.scaleFactor;
	            map.height = image.height * map.scaleFactor;
	
	            // Draw the image within the map (no adjustments) and save the pixel array
	            map.context.drawImage(image, map.cornerX, map.cornerY, map.width, map.height);
	            map.data = map.context.getImageData(0, 0, settings.mapSize, settings.mapSize);
	
	            // Show the viewbox, make it reflect where we currently are
	            $('#diva-map-viewbox').show();
	            updateViewbox();
	        };
	
	        // Load the image within the large and small canvases
	        var loadCanvas = function (imageURL, callback)
	        {
	            image = new Image();
	            image.crossOrigin = "anonymous";
	
	            image.onload = function ()
	            {
	                // Determine the size of the (square) canvas based on the hypoteneuse
	                canvas.size = Math.sqrt(image.width * image.width + image.height * image.height);
	
	                // Resize the canvas if necessary
	                canvas.canvas = document.getElementById('diva-canvas');
	                canvas.canvas.width = canvas.size;
	                canvas.canvas.height = canvas.size;
	                canvas.cornerX = (canvas.size - image.width) / 2;
	                canvas.cornerY = (canvas.size - image.height) / 2;
	                canvas.width = image.width;
	                canvas.height = image.height;
	                canvas.centerX = canvas.size / 2;
	                canvas.centerY = canvas.size / 2;
	
	                // Draw the image to the large canvas, and save the pixel array
	                canvas.context = canvas.canvas.getContext('2d');
	                canvas.context.drawImage(image, canvas.cornerX, canvas.cornerY, canvas.width, canvas.height);
	                try
	                {
	                    canvas.data = canvas.context.getImageData(0, 0, canvas.size, canvas.size);
	                }
	                catch (error)
	                {
	                    var canvasError = '<div id="diva-error" class="diva-error"><p><strong>Error</strong></p><p>' + error.message + '</p>';
	
	                    if (error.name === 'SecurityError')
	                    {
	                        canvasError += '<p>You may need to update your server configuration in order to use the image manipulation tools. ' +
	                        'For help, see the <a href="https://github.com/DDMAL/diva.js/wiki/The-API-and-Plugins#a-note-about-' +
	                        'canvas-and-cross-site-data" target="_blank">canvas cross-site data documentation</a>.</p>' +
	                        '</div>';
	                    }
	                    else
	                    {
	                        throw error;
	                    }
	
	                    canvasError += '</div>';
	                    $('#diva-canvas-backdrop').append(canvasError);
	                    hideThrobber();
	                }
	
	                // Only load the map the first time (when there is no callback)
	                if (callback === undefined) {
	                    loadMap(image);
	                }
	
	                // Update the map and the canvas if necessary
	                updateMap();
	                updateCanvas(canvas);
	
	                // Hide the throbber if it is visible
	                hideThrobber();
	
	                // If the callback function exists, execute it (for zooming)
	                if (typeof callback === 'function')
	                    callback.call(callback);
	            };
	
	            image.src = imageURL;
	
	            // make sure the load event fires for cached images too
	            if ( image.complete || image.complete === undefined ) {
	                image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
	                image.src = imageURL;
	            }
	        };
	
	        var updateSliderLabel = function ()
	        {
	            var thisSlider = sliders[sliderMode];
	            var value = thisSlider.current;
	            var stringValue = (thisSlider.transform) ? thisSlider.transform(value) : value;
	            $('#diva-canvas-value').html(stringValue);
	        };
	
	        var updateSliderValue = function ()
	        {
	            $('#diva-canvas-slider').val(sliders[sliderMode].current);
	        };
	
	        // Returns the URL for the image at the specified zoom level
	        var getImageURL = function (zoomLevel)
	        {
	            var width = settings.zoomWidthRatio * Math.pow(2, zoomLevel);
	
	            return settings.divaInstance.getPageImageURL(settings.selectedPageIndex, { width: width });
	        };
	
	        var showThrobber = function ()
	        {
	            // Only show the throbber if it will take a long time
	            if (sliders.zoom.current > 0 || settings.mobileWebkit)
	                $(settings.selector + 'throbber').addClass('canvas-throbber').show();
	        };
	
	        // Hides the loading indicator icon
	        var hideThrobber = function ()
	        {
	            $(settings.selector + 'throbber').removeClass('canvas-throbber').hide();
	        };
	
	        // If any modifications have been applied, save them to localStorage
	        var saveSettings = function ()
	        {
	            var sliderSettings = {};
	            var changed = false;
	            var storageKey = settings.localStoragePrefix + settings.filename;
	            var slider;
	
	            for (slider in sliders)
	            {
	                if (sliders[slider].previous !== sliders[slider].initial)
	                {
	                    sliderSettings[slider] = sliders[slider].previous;
	                    changed = true;
	                }
	            }
	
	            // If modifications need to be saved, update the canvas plugin icon
	            if (changed)
	            {
	                settings.pluginIcon.addClass('new');
	                storeObject(storageKey, sliderSettings);
	            }
	            else
	            {
	                settings.pluginIcon.removeClass('new');
	                localStorage.removeItem(storageKey);
	            }
	        };
	
	        // Handles zooming in when the zoom slider is changed and the change is applied
	        var updateZoom = function (newZoomLevel, callback)
	        {
	            settings.zoomLevel = newZoomLevel;
	
	            // Figure out the URL for the image at this new zoom level
	            var imageURL = getImageURL(newZoomLevel);
	
	            loadCanvas(imageURL, function ()
	            {
	                // Set the new scale factor and update the viewbox
	                map.scaleFactor = map.size / canvas.size;
	                updateViewbox();
	
	                saveSettings();
	            });
	        };
	
	        var bindCanvasKeyEvents = function (event)
	        {
	            var upArrowKey = 38,
	                downArrowKey = 40,
	                leftArrowKey = 37,
	                rightArrowKey = 39;
	
	            switch (event.keyCode)
	            {
	                case upArrowKey:
	                    // Up arrow - scroll up
	                    $('#diva-canvas-wrapper').scrollTop(document.getElementById('diva-canvas-wrapper').scrollTop - settings.arrowScrollAmount);
	                    return false;
	
	                case downArrowKey:
	                    // Down arrow - scroll down
	                    $('#diva-canvas-wrapper').scrollTop(document.getElementById('diva-canvas-wrapper').scrollTop + settings.arrowScrollAmount);
	                    return false;
	
	                case leftArrowKey:
	                    // Left arrow - scroll left
	                    $('#diva-canvas-wrapper').scrollLeft(document.getElementById('diva-canvas-wrapper').scrollLeft - settings.arrowScrollAmount);
	                    return false;
	
	                case rightArrowKey:
	                    // Right arrow - scroll right
	                    $('#diva-canvas-wrapper').scrollLeft(document.getElementById('diva-canvas-wrapper').scrollLeft + settings.arrowScrollAmount);
	                    return false;
	            }
	        };
	
	        // Serialize an object to JSON and save it in localStorage
	        var storeObject = function (key, value) {
	            localStorage.setItem(key, JSON.stringify(value));
	        };
	
	        // Load and deserialize a localStorage object
	        var loadStoredObject = function (key) {
	            var value = localStorage.getItem(key);
	            return value && JSON.parse(value);
	        };
	
	        var retval =
	        {
	            init: function (divaSettings, divaInstance)
	            {
	                // If the browser does not support canvas, do nothing
	                // And, disable this plugin
	                var canvasSupported = !!window.HTMLCanvasElement;
	                if (!canvasSupported)
	                    return false;
	
	                // Override all the configurable settings defined under canvasPlugin
	                $.extend(settings, defaults, divaSettings.canvasPlugin);
	
	                settings.divaInstance = divaInstance;
	                settings.inCanvas = false;
	                settings.iipServerURL = divaSettings.iipServerURL;
	                settings.imageDir = divaSettings.imageDir;
	                settings.selector = divaSettings.selector;
	                settings.mobileWebkit = divaSettings.mobileWebkit;
	                settings.arrowScrollAmount = divaSettings.arrowScrollAmount;
	
	                // Set up the settings for the sliders/icons
	                sliders = {
	                    'contrast': {
	                        'initial': 1,
	                        'min': settings.contrastMin,
	                        'max': settings.contrastMax,
	                        'step': settings.contrastStep,
	                        'transform': function (value) {
	                            return value.toFixed(2);
	                        },
	                        'title': 'Change the contrast'
	                    },
	                    'brightness': {
	                        'initial': 0,
	                        'min': settings.brightnessMin,
	                        'max': settings.brightnessMax,
	                        'step': settings.brightnessStep,
	                        'title': 'Adjust the brightness'
	                    },
	                    'rotation': {
	                        'initial': 0,
	                        'min': 0,
	                        'max': 359,
	                        'step': 1,
	                        'transform': function (value) {
	                            return value + '&deg;';
	                        },
	                        'title': 'Rotate the image'
	                    },
	                    'zoom': {
	                        // Default, min and max values updated within setupHook
	                        'initial': 0,
	                        'min': 0,
	                        'max': 0,
	                        'step': 1,
	                        'title': 'Adjust the zoom level'
	                    },
	                    'red': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the red channel'
	                    },
	                    'green': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the green channel'
	                    },
	                    'blue': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the blue channel'
	                    }
	                };
	
	                // Copy the "default" value into "value" and "previous" for each slider
	                var resetSliders = function ()
	                {
	                    var defaultValue, thisSlider, slider;
	                    for (slider in sliders)
	                    {
	                        thisSlider = sliders[slider];
	                        defaultValue = thisSlider.initial;
	                        thisSlider.current = defaultValue;
	                        thisSlider.previous = defaultValue;
	                    }
	                };
	
	                resetSliders();
	
	                // Create the DOM elements if they haven't already been created
	                if ($('#diva-canvas-backdrop').length)
	                {
	                    // Return true to keep the plugin enabled
	                    return true;
	                }
	
	                var canvasButtonsList = [];
	                var buttonHTML, button, buttonTitle, i;
	
	                for (i in settings.buttons)
	                {
	                    button = settings.buttons[i];
	                    buttonTitle = sliders[button].title;
	                    buttonHTML = '<div class="' + button + '" title="' + buttonTitle + '"></div>';
	                    canvasButtonsList.push(buttonHTML);
	                }
	                var canvasButtons = canvasButtonsList.join('');
	
	                var canvasTools = '<div id="diva-canvas-tools">' +
	                    '<div id="diva-canvas-toolbar">' +
	                        '<div id="diva-canvas-close" title="Return to the document viewer"></div>' +
	                        '<div id="diva-canvas-minimise" title="Minimise the toolbar"></div>' +
	                        '<span id="diva-canvas-info">Test</span>' +
	                    '</div>' +
	                    '<div id="diva-canvas-toolwindow">' +
	                        '<div id="diva-map-viewbox"></div>' +
	                        '<canvas id="diva-canvas-minimap"></canvas>' +
	                        '<div id="diva-canvas-buttons">' +
	                            canvasButtons +
	                        '</div>' +
	                        '<div id="diva-canvas-pane">' +
	                            '<p id="diva-canvas-tooltip">' +
	                                '<span id="diva-canvas-mode">contrast</span>: ' +
	                                '<span id="diva-canvas-value">0</span> ' +
	                                '<span id="diva-canvas-reset" class="link">(Reset)</span>' +
	                            '</p>' +
	                            '<input type="range" id="diva-canvas-slider"></input>' +
	                        '</div>' +
	                        '<br />' +
	                        '<div class="action-buttons">' +
	                            '<a href="#" id="diva-canvas-reset-all">Reset all</a>' +
	                            '<a href="#" id="diva-canvas-apply">Apply</a>' +
	                        '</div>' +
	                    '</div>' +
	                '</div>';
	                var canvasWrapper = '<div id="diva-canvas-wrapper">' +
	                    '<canvas id="diva-canvas"></canvas>' +
	                '</div>';
	                var canvasString = '<div id="diva-canvas-backdrop">' +
	                    canvasTools +
	                    canvasWrapper +
	                '</div>';
	
	                $('body').append(canvasString);
	
	                // Save the size of the map, as defined in the CSS
	                settings.mapSize = $('#diva-canvas-minimap').width();
	
	                // Adjust the slider when something is clicked, and make that the current mode
	                $('#diva-canvas-buttons div').click(function ()
	                {
	                    $('#diva-canvas-buttons .clicked').removeClass('clicked');
	                    updateSlider($(this).attr('class'));
	                });
	
	                var updateSlider = function (newMode)
	                {
	                    sliderMode = newMode;
	                    var sliderData = sliders[sliderMode];
	
	                    $('#diva-canvas-buttons .' + sliderMode).addClass('clicked');
	
	                    $('#diva-canvas-mode').text(sliderMode);
	
	                    var newValue = sliderData.current;
	                    var newValueString = (sliderData.transform) ? sliderData.transform(newValue) : newValue;
	
	                    var slider = document.getElementById('diva-canvas-slider');
	                    slider.min = sliderData.min;
	                    slider.max = sliderData.max;
	                    slider.step = sliderData.step;
	                    $('#diva-canvas-slider').val(newValue);
	                    $('#diva-canvas-value').html(newValueString);
	                };
	
	                updateSlider('contrast');
	
	                // Create the slider
	                $('#diva-canvas-slider').on('input', function(e){
	                    sliders[sliderMode].current = parseFloat(this.value);
	                    updateSliderLabel();
	                    updateMap();
	                });
	
	                // Reset all the sliders to the default value
	                $('#diva-canvas-reset-all').click(function ()
	                {
	                    var slider;
	
	                    for (slider in sliders)
	                    {
	                        sliders[slider].current = sliders[slider].initial;
	                    }
	
	                    // Change the value of the label
	                    updateSliderLabel();
	                    updateSliderValue();
	
	                    // Update the preview
	                    updateMap();
	                });
	
	                // Reset the current slider to the default value
	                $('#diva-canvas-reset').click(function ()
	                {
	                    // Update the current value and the slider
	                    sliders[sliderMode].current = sliders[sliderMode].initial;
	                    updateSliderLabel();
	                    updateSliderValue();
	
	                    // Update the preview
	                    updateMap();
	                });
	
	                // Update the large canvas when the apply button is clicked
	                $('#diva-canvas-apply').click(function ()
	                {
	                    if (shouldAdjustLevels())
	                    {
	                        showThrobber();
	
	                        setTimeout(function ()
	                        {
	                            if (sliders.zoom.current !== sliders.zoom.previous)
	                            {
	                                updateZoom(sliders.zoom.current);
	                            }
	                            else
	                            {
	                                updateCanvas();
	                                hideThrobber();
	
	                                // Save modifications to localSettings (also done in updateZoom callback)
	                                saveSettings();
	                            }
	                        }, settings.throbberTimeout);
	                    }
	                });
	
	                // Handle exiting canvas mode
	                $('#diva-canvas-close').click(function ()
	                {
	                    $('body').removeClass('overflow-hidden');
	
	                    // Clear the canvases and hide things
	                    // This needs to be improved - not done properly?
	                    canvas.context.clearRect(0, 0, canvas.size, canvas.size);
	                    map.context.clearRect(0, 0, map.size, map.size);
	                    $('#diva-canvas-wrapper').scrollTop(0).scrollLeft(0);
	                    $('#diva-canvas-backdrop').hide();
	                    $('#diva-map-viewbox').hide();
	                    hideThrobber();
	
	                    // Re-enable scrolling of diva when it is in the background
	                    divaInstance.enableScrollable();
	                    $(document).off('keydown', bindCanvasKeyEvents);
	
	                    // Reset everything
	                    resetSliders();
	                    updateSliderLabel();
	                    updateSliderValue();
	                    $('#diva-canvas-buttons .clicked').removeClass('clicked');
	                    updateSlider('contrast');
	
	                    diva.Events.publish("CanvasViewDidHide");
	                });
	
	                // Hide the toolbar when the minimise icon is clicked
	                $('#diva-canvas-minimise').click(function ()
	                {
	                    $('#diva-canvas-toolwindow').slideToggle('fast');
	                });
	
	                // Adjust the size of the canvas when the browser window is resized
	                $(window).resize(function ()
	                {
	                    settings.viewport = {
	                        height: window.innerHeight - divaSettings.scrollbarWidth,
	                        width: window.innerWidth - divaSettings.scrollbarWidth
	                    };
	
	                    // Always update the settings but only redraw if in canvas
	                    if (settings.inCanvas)
	                        updateViewbox();
	                });
	
	                // Update the viewbox when the large canvas is scrolled
	                $('#diva-canvas-wrapper').scroll(function ()
	                {
	                    if (settings.inCanvas)
	                        updateViewbox();
	                });
	
	                // Handle clicking/dragging of the viewbox (should scroll the large canvas)
	                $('#diva-canvas-minimap, #diva-map-viewbox').mouseup(function (event)
	                {
	                    // Consider caching this eventually (can't be done in init though)
	                    var offset = $('#diva-canvas-minimap').offset();
	
	                    var scaledX = (event.pageX - offset.left) / map.scaleFactor;
	                    var scaledY = (event.pageY - offset.top) / map.scaleFactor;
	
	                    $('#diva-canvas-wrapper').scrollTop(scaledY - settings.viewport.height / 2);
	                    $('#diva-canvas-wrapper').scrollLeft(scaledX - settings.viewport.width / 2);
	                });
	
	                // Enable drag scroll
	                $('#diva-canvas').mousedown(function ()
	                {
	                    $(this).addClass('grabbing');
	                }).mouseup(function ()
	                {
	                    $(this).removeClass('grabbing');
	                });
	
	                // touch events
	                $('#diva-canvas-wrapper').kinetic();
	
	                // mouse events
	                $('#diva-canvas-wrapper').dragscrollable({
	                    acceptPropagatedEvent: true
	                });
	
	                diva.Events.subscribe('ObjectDidLoad', this.setupHook, divaSettings.ID);
	                diva.Events.subscribe('ViewerDidTerminate', this.destroy, divaSettings.ID);
	                diva.Events.subscribe('PageDidLoad', this.onPageLoad, divaSettings.ID);
	
	                return true;
	            },
	
	            pluginName: 'canvas',
	
	            titleText: 'View the image on a canvas and adjust various settings',
	
	            setupHook: function(divaSettings)
	            {
	                settings.viewport = {
	                    height: window.innerHeight - divaSettings.scrollbarWidth,
	                    width: window.innerWidth - divaSettings.scrollbarWidth
	                };
	
	                // Save the min and max zoom level, and update the zoom slider
	                settings.minZoomLevel = divaSettings.minZoomLevel;
	                settings.maxZoomLevel = divaSettings.maxZoomLevel;
	
	                // If we're on the iPad, limit the max zoom level to 2
	                // Can't do canvas elements that are > 5 megapixels (issue #112)
	                if (settings.mobileWebkit)
	                    settings.maxZoomLevel = Math.min(settings.maxZoomLevel, settings.mobileWebkitMaxZoom);
	
	                sliders.zoom.min = settings.minZoomLevel;
	                sliders.zoom.max = settings.maxZoomLevel;
	            },
	
	            handleClick: function(event, divaSettings, divaInstance, selectedPageIndex)
	            {
	                // loadCanvas() calls all the other necessary functions to load
	                var filename = divaInstance.getFilenames()[selectedPageIndex];
	
	                // TODO: Move rationale for -1 from Wiki (TLDR an old IIP bug)
	                var width = divaInstance
	                    .getPageDimensions(selectedPageIndex)
	                    .width - 1;
	
	                var zoomLevel = divaSettings.zoomLevel;
	                var slider;
	
	                settings.zoomWidthRatio = width / Math.pow(2, zoomLevel);
	                settings.pluginIcon = $(this);
	
	                settings.manifest = divaSettings.manifest;
	                settings.selectedPageIndex = selectedPageIndex;
	
	                // Limit the max zoom level if we're on the iPad
	                if (settings.mobileWebkit) {
	                    zoomLevel = Math.min(settings.maxZoomLevel, zoomLevel);
	                }
	
	                settings.filename = filename;
	                sliders.zoom.initial = zoomLevel;
	                sliders.zoom.current = zoomLevel;
	
	                // Find the settings stored in localStorage, if they exist
	                var sliderSettings = loadStoredObject(settings.localStoragePrefix + settings.filename);
	                if (sliderSettings)
	                {
	                    for (slider in sliderSettings)
	                    {
	                        sliders[slider].current = sliderSettings[slider];
	
	                        // If the current slider's value has changed, update it
	                        if (slider === sliderMode)
	                        {
	                            updateSliderLabel();
	                            updateSliderValue();
	                        }
	
	                        if (slider === 'zoom')
	                        {
	                            zoomLevel = sliderSettings[slider];
	                        }
	                    }
	                }
	
	                sliders.zoom.previous = zoomLevel;
	
	                // Prevent scroll in body, and show the canvas backdrop
	                $('body').addClass('overflow-hidden');
	                $('#diva-canvas-backdrop').show();
	
	                // Disable scrolling on main diva instance
	                divaInstance.disableScrollable();
	                // Enable canvas scrolling
	                $(document).keydown(bindCanvasKeyEvents);
	
	                // Set this to true so events can be captured
	                settings.inCanvas = true;
	
	                var imageURL = getImageURL(zoomLevel);
	
	                // Change the title of the page
	                // FIXME: This is legacy behaviour. Should this be a filename/label?
	                $('#diva-canvas-info').text('Page ' + (selectedPageIndex + 1));
	
	                showThrobber();
	
	                diva.Events.publish('CanvasViewDidActivate', [selectedPageIndex]);
	
	                loadCanvas(imageURL);
	            },
	
	            onPageLoad: function(pageIndex, filename, selector)
	            {
	                // If something exists for this page in localStorage, then change icon color
	                var storageKey = settings.localStoragePrefix + filename;
	
	                if (localStorage.getItem(storageKey) !== null)
	                {
	                    $(selector).find('.diva-canvas-icon').addClass('new');
	                }
	            },
	
	            destroy: function(divaSettings, divaInstance)
	            {
	                $('#diva-canvas-backdrop').remove();
	            }
	        };
	
	        // this returns an object with all of the necessary hooks and callbacks
	        // embedded.
	        return retval;
	
	    })();
	})(jQuery);


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Download plugin for diva.js
	Allows you to download images served by IIPImage or IIIF compatible image servers
	*/
	
	var jQuery = __webpack_require__(3);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                settings.divaInstance = divaInstance;
	                return true;
	            },
	            pluginName: 'download',
	            titleText: 'Download image at the given zoom level',
	            handleClick: function(event, divaSettings, divaInstance, pageIndex)
	            {
	                // TODO: Move rationale for -1 from Wiki (TLDR an old IIP bug)
	                var width = divaInstance
	                        .getPageDimensions(pageIndex)
	                        .width - 1;
	
	                var image = settings.divaInstance.getPageImageURL(pageIndex, { width: width });
	
	                window.open(image);
	            }
	        };
	
	        return retval;
	    })();
	})(jQuery);


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Highlight plugin for diva.js
	Allows you to highlight regions of a page image
	*/
	
	var jQuery = __webpack_require__(3);
	var elt = __webpack_require__(8);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var highlightManager = new HighlightManager(divaInstance);
	                divaSettings.parentObject.data('highlightManager', highlightManager);
	
	                var currentHighlight;
	
	                /*
	                    Reset the highlights object and removes all highlights from the document.
	                */
	                divaInstance.resetHighlights = function()
	                {
	                    highlightManager.clear();
	                };
	
	                /*
	                    Resets the highlights for a single page.
	                */
	                divaInstance.removeHighlightsOnPage = function(pageIdx)
	                {
	                    highlightManager.removeHighlightsOnPage(pageIdx);
	                };
	
	                /*
	                    Highlights regions on multiple pages.
	                    @param pageIdxs An array of page index numbers
	                    @param regions  An array of regions
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                */
	                divaInstance.highlightOnPages = function(pageIdxs, regions, colour, divClass)
	                {
	                    var j = pageIdxs.length;
	                    while (j--)
	                    {
	                        divaInstance.highlightOnPage(pageIdxs[j], regions[j], colour, divClass);
	                    }
	                };
	
	                /*
	                    Highlights regions on a page.
	                    @param pageIdx  A page index number
	                    @param regions  An array of regions. Use {'width':i, 'height':i, 'ulx':i, 'uly': i, 'divID': str} for each region.
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                    @param divClass (optional) A class to identify a group of highlighted regions on a specific page by
	                */
	                divaInstance.highlightOnPage = function(pageIdx, regions, colour, divClass)
	                {
	                    if (colour === undefined)
	                    {
	                        colour = 'rgba(255, 0, 0, 0.2)';
	                    }
	
	                    if (divClass === undefined)
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight';
	                    }
	                    else
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight ' + divClass;
	                    }
	
	                    highlightManager.addHighlight({
	                        page: pageIdx,
	                        regions: regions,
	                        colour: colour,
	                        divClass: divClass
	                    });
	
	                    return true;
	                };
	
	                /*
	                    Jumps to a highlight somewhere in the document.
	                    @param divID The ID of the div to jump to. This ID must be attached to the div using .highlightOnPage(s) as the highlight may not be currently appended to the DOM.
	                */
	                divaInstance.gotoHighlight = function(divID)
	                {
	                    var result = highlightManager.getHighlightByRegionId(divID);
	
	                    if (result)
	                        return gotoDiv(result.highlight.page, result.region);
	
	                    console.warn("Diva just tried to find a highlight that doesn't exist.");
	                    return false;
	                };
	
	                /**
	                * Moves the diva pane to (page) and makes a darker border on (thisDiv)
	                */
	                var gotoDiv = function(page, thisDiv)
	                {
	                    //gets center of the div
	                    var centerYOfDiv = parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2;
	                    var centerXOfDiv = parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2;
	
	                    var desiredY = divaInstance.translateFromMaxZoomLevel(centerYOfDiv);
	                    var desiredX = divaInstance.translateFromMaxZoomLevel(centerXOfDiv);
	
	                    //navigates to the page
	                    page = parseInt(page, 10);
	                    divaInstance.gotoPageByIndex(page);
	                    var viewportObject = divaInstance.getSettings().viewportObject;
	                    var currentTop = viewportObject.scrollTop() + desiredY - (viewportObject.height() / 2) + divaSettings.verticalPadding;
	                    var currentLeft = viewportObject.scrollLeft() + desiredX - (viewportObject.width() / 2) + divaSettings.horizontalPadding;
	
	                    //changes the scroll location to center on the div as much as is possible
	                    viewportObject.scrollTop(currentTop);
	                    viewportObject.scrollLeft(currentLeft);
	
	                    currentHighlight = {
	                        region: thisDiv,
	                        page: page
	                    };
	
	                    diva.Events.publish("SelectedHighlightChanged", [thisDiv.id, currentHighlight.page]);
	
	                    //selects the highlight
	                    updateCurrentHighlight(divaInstance, currentHighlight);
	                    return thisDiv.id;
	                };
	
	                var getDivCenter = function(thisDiv)
	                {
	                    if (divaSettings.verticallyOriented) return divaInstance.translateFromMaxZoomLevel(parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2);
	                    else return divaInstance.translateFromMaxZoomLevel(parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2);
	                };
	
	                /*
	                    Jumps to the next highlight along the primary axis of the document.
	                */
	                var findAdjacentHighlight = function(forward)
	                {
	                    var centerOfTargetDiv;
	                    var highlightFound = false;
	                    var centerOfCurrentDiv;
	                    var currentPage;
	                    var regionArr, arrIndex;
	                    var pageDims;
	                    var centerOfDiv, targetDiv;
	
	                    var thisDiv;
	                    var compFunction;
	
	                    // If currentHighlight does not already exists,
	                    // just pretend we're starting at the northwest corner of diva-inner
	                    if (!currentHighlight)
	                    {
	                        centerOfCurrentDiv = 0;
	                        currentPage = 0;
	                    }
	                    else {
	                        currentPage = currentHighlight.page;
	
	                        //find the center of the current div
	                        centerOfCurrentDiv = getDivCenter(currentHighlight.region);
	                    }
	
	                    //if we do have a current highlight, try to find the next one in the same page
	
	                    regionArr = highlightManager.getHighlightRegions(currentPage);
	                    arrIndex = regionArr.length;
	                    pageDims = divaInstance.getPageDimensionsAtZoomLevel(currentPage, divaInstance.getZoomLevel());
	
	                    //initialize the center of the div to the maximum possible value
	                    if(forward) centerOfTargetDiv = (divaSettings.verticallyOriented) ? pageDims.height : pageDims.width;
	                    else centerOfTargetDiv = 0;
	
	                    if(forward)
	                    {
	                        compFunction = function(thisC, curC, targetC)
	                        {
	                            return (thisC > curC && thisC < targetC);
	                        };
	                    }
	                    else
	                    {
	                        compFunction = function(thisC, curC, targetC)
	                        {
	                            return (thisC < curC && thisC > targetC);
	                        };
	                    }
	
	                    while(arrIndex--)
	                    {
	                        thisDiv = regionArr[arrIndex];
	                        centerOfDiv = getDivCenter(thisDiv);
	
	                        //if this div is farther along the main axis but closer than the current closest
	                        if (compFunction(centerOfDiv, centerOfCurrentDiv, centerOfTargetDiv))
	                        {
	                            //update targetDiv
	                            highlightFound = true;
	                            centerOfTargetDiv = centerOfDiv;
	                            targetDiv = thisDiv;
	                        }
	                    }
	
	                    //if a highlight was found on the current page that was next; this can get overwritten but we're still good
	                    if (highlightFound) return gotoDiv(currentPage, targetDiv);
	                    //if it wasn't found, continue on...
	
	                    //find the minimum div on the next page with highlights and loop around if necessary
	
	                    //find the next page in the pageArr; this will be in order
	                    var pageArr = highlightManager.getHighlightedPages();
	                    var curIdx = pageArr.indexOf(currentPage.toString());
	
	                    var targetPage;
	
	                    if(forward)
	                    {
	                        while (!targetPage || !divaInstance.isPageIndexValid (targetPage))
	                        {
	                            //default to first page, move to next if possible
	                            if (curIdx == pageArr.length - 1) targetPage = pageArr[0];
	                            else targetPage = pageArr[++curIdx];
	                        }
	                    }
	
	                    else
	                    {
	                        while (!targetPage || !divaInstance.isPageIndexValid (targetPage))
	                        {
	                            //default to last page, move to previous if possible
	                            if (curIdx === 0) targetPage = pageArr[pageArr.length - 1];
	                            else targetPage = pageArr[--curIdx];
	                        }
	                    }
	
	                    //reset regionArr and centerOfTargetDiv for the new page we're testing
	                    regionArr = highlightManager.getHighlightRegions(targetPage);
	                    arrIndex = regionArr.length;
	                    pageDims = divaInstance.getPageDimensionsAtZoomLevel(targetPage, divaInstance.getMaxZoomLevel());
	
	                    if(forward) centerOfTargetDiv = (divaSettings.verticallyOriented) ? pageDims.height : pageDims.width;
	                    else centerOfTargetDiv = 0;
	
	                    //find the minimum this time
	                    if(forward)
	                    {
	                        compFunction = function(thisC, targetC)
	                        {
	                            return (thisC < targetC);
	                        };
	                    }
	                    else
	                    {
	                        compFunction = function(thisC, targetC)
	                        {
	                            return (thisC > targetC);
	                        };
	                    }
	
	                    while(arrIndex--)
	                    {
	                        thisDiv = regionArr[arrIndex];
	                        centerOfDiv = getDivCenter(thisDiv);
	                        if (compFunction(centerOfDiv, centerOfTargetDiv))
	                        {
	                            highlightFound = true;
	                            centerOfTargetDiv = centerOfDiv;
	                            targetDiv = thisDiv;
	                        }
	                    }
	
	                    //we've found it this time, as there'll be a region in the full regionArr to be the minimum
	                    return gotoDiv(targetPage, targetDiv);
	                };
	
	                /*
	                    Jumps to the next highlight along the primary axis of the document.
	                */
	                divaInstance.gotoNextHighlight = function()
	                {
	                    if (highlightManager.getHighlightCount() > 0)
	                        return findAdjacentHighlight(true);
	                    else
	                        return false;
	                };
	
	                /*
	                    Jumps to the previous highlight along the primary axis of the document.
	                */
	                divaInstance.gotoPreviousHighlight = function()
	                {
	                    if (highlightManager.getHighlightCount() > 0)
	                        return findAdjacentHighlight(false);
	                    else
	                        return false;
	                };
	
	                diva.Events.subscribe('ViewerWillTerminate', this.destroy, divaSettings.ID);
	
	                return true;
	            },
	            destroy: function (divaSettings)
	            {
	                var highlightManager = divaSettings.parentObject.data('highlightManager');
	                highlightManager.clear();
	                divaSettings.parentObject.removeData('highlightManager');
	            },
	            pluginName: 'highlight',
	            titleText: 'Highlight regions of pages',
	
	            // Exposed export
	            HighlightManager: HighlightManager
	        };
	        return retval;
	    })();
	})(jQuery);
	
	/** Manages the addition and removal of the page overlays which display the highlights */
	function HighlightManager(divaInstance, getCurrentHighlight)
	{
	    this._divaInstance = divaInstance;
	    this._overlays = {};
	    this._getCurrentHighlight = getCurrentHighlight;
	}
	
	HighlightManager.prototype.getHighlightCount = function ()
	{
	    var count = 0;
	    Object.keys(this._overlays).forEach(function (key)
	    {
	        count += this._overlays[key].highlight.regions.length;
	    }, this);
	
	    return count;
	};
	
	HighlightManager.prototype.getHighlightRegions = function (pageIndex)
	{
	    if (!this._overlays[pageIndex])
	        return [];
	
	    return this._overlays[pageIndex].highlight.regions;
	};
	
	HighlightManager.prototype.getHighlightedPages = function ()
	{
	    // FIXME: Conceptually awkward that these are strings
	    return Object.keys(this._overlays);
	};
	
	HighlightManager.prototype.getHighlightByRegionId = function (id)
	{
	    for (var i in this._overlays)
	    {
	        if (!this._overlays.hasOwnProperty(i))
	            continue;
	
	        var regions = this._overlays[i].highlight.regions;
	        for (var j in regions)
	        {
	            if (!regions.hasOwnProperty(j))
	                continue;
	
	            if (regions[j].divID === id)
	            {
	                return {
	                    highlight: this._overlays[i].highlight,
	                    region: regions[j]
	                };
	            }
	        }
	    }
	
	    return null;
	};
	
	HighlightManager.prototype.addHighlight = function (highlight)
	{
	    var existingOverlay = this._overlays[highlight.page];
	
	    if (existingOverlay)
	        this._divaInstance.__removePageOverlay(existingOverlay);
	
	    var overlay = new HighlightPageOverlay(highlight, this._divaInstance, this._getCurrentHighlight);
	    this._overlays[highlight.page] = overlay;
	    this._divaInstance.__addPageOverlay(overlay);
	};
	
	HighlightManager.prototype.removeHighlightsOnPage = function (pageIndex)
	{
	    if (!this._overlays[pageIndex])
	        return;
	
	    this._divaInstance.__removePageOverlay(this._overlays[pageIndex]);
	    delete this._overlays[pageIndex];
	};
	
	HighlightManager.prototype.clear = function ()
	{
	    for (var i in this._overlays)
	    {
	        if (!this._overlays.hasOwnProperty(i))
	            continue;
	
	        this._divaInstance.__removePageOverlay(this._overlays[i]);
	    }
	
	    this._overlays = {};
	};
	
	/**
	 When a new page is loaded, this overlay will be called with the
	 page index for the page. It looks at the 'highlights' data object
	 set on the diva parent element, and determines whether
	 highlights exist for that page.
	
	 If so, the overlay will create and render elements for every
	 highlighted box.
	
	 @param highlight
	 @param divaInstance
	 @param getCurrentHighlight (optional)
	 */
	function HighlightPageOverlay(highlight, divaInstance, getCurrentHighlight)
	{
	    this.page = highlight.page;
	    this.highlight = highlight;
	    this._highlightRegions = [];
	    this._divaInstance = divaInstance;
	    this._getCurrentHighlight = getCurrentHighlight;
	}
	
	HighlightPageOverlay.prototype.mount = function ()
	{
	    var divaSettings = this._divaInstance.getSettings();
	
	    var highlight = this.highlight;
	    var regions = highlight.regions;
	    var colour = highlight.colour;
	    var divClass = highlight.divClass;
	
	    var j = regions.length;
	    while (j--)
	    {
	        var region = regions[j];
	
	        // FIXME: Use CSS class instead of inline style
	        var box = elt('div', {
	            class: divClass,
	            style: {
	                background: colour,
	                border: "1px solid #555",
	                position: "absolute",
	                zIndex: 100
	            }
	        });
	
	        if (region.divID !== undefined)
	        {
	            box.setAttribute('data-highlight-id', region.divID);
	        }
	
	        // Used by IIIFHighlight
	        if (region.name !== undefined)
	        {
	            box.setAttribute('data-name', region.name);
	        }
	
	        this._highlightRegions.push({
	            element: box,
	            region: region
	        });
	    }
	
	    this.refresh();
	
	    var frag = document.createDocumentFragment();
	    this._highlightRegions.forEach(function (highlight)
	    {
	        frag.appendChild(highlight.element);
	    });
	
	    divaSettings.innerElement.appendChild(frag);
	
	    if (this._getCurrentHighlight)
	        updateCurrentHighlight(this._divaInstance, this._getCurrentHighlight());
	
	    diva.Events.publish("HighlightCompleted", [this.page, this._divaInstance.getFilenames()[this.page]]);
	};
	
	HighlightPageOverlay.prototype.unmount = function ()
	{
	    var innerElement = this._divaInstance.getSettings().innerElement;
	
	    this._highlightRegions.forEach(function (highlight)
	    {
	        innerElement.removeChild(highlight.element);
	    });
	
	    this._highlightRegions = [];
	};
	
	// FIXME: Updating a box per highlight region might be too expensive
	// Maybe stick all the elements in a container and then scale it using CSS transforms?
	HighlightPageOverlay.prototype.refresh = function ()
	{
	    var maxZoom = this._divaInstance.getMaxZoomLevel();
	
	    var maxZoomWidth = this._divaInstance.getPageDimensionsAtZoomLevel(this.page, maxZoom).width;
	    var currentWidth = this._divaInstance.getPageDimensions(this.page).width;
	    var zoomDifference = Math.log(maxZoomWidth / currentWidth) / Math.log(2);
	
	    var pageOffset = this._divaInstance.getPageOffset(this.page, {
	        excludePadding: true,
	        incorporateViewport: true
	    });
	
	    this._highlightRegions.forEach(function (highlight)
	    {
	        var region = highlight.region;
	
	        elt.setAttributes(highlight.element, {
	            style: {
	                width: incorporateZoom(region.width, zoomDifference) + "px",
	                height: incorporateZoom(region.height, zoomDifference) + "px",
	                top: pageOffset.top + incorporateZoom(region.uly, zoomDifference) + "px",
	                left: pageOffset.left + incorporateZoom(region.ulx, zoomDifference) + "px"
	            }
	        });
	    });
	};
	
	function incorporateZoom(position, zoomDifference)
	{
	    return position / Math.pow(2, zoomDifference);
	}
	
	function updateCurrentHighlight(divaInstance, currentHighlight)
	{
	    var classString = divaInstance.getInstanceId() + "selected-highlight";
	    var classElem = document.getElementsByClassName(classString);
	    var idx;
	    var box;
	    var boxes;
	
	    for (idx = 0; idx < classElem.length; idx++)
	    {
	        box = classElem[idx];
	        if (box.id !== currentHighlight.id)
	        {
	            box.className = box.className.replace(' '+classString, '');
	            box.style.border = "1px solid #555";
	        }
	    }
	
	    if (divaInstance.isPageInViewport(currentHighlight.page))
	    {
	        boxes = document.querySelectorAll("*[data-highlight-id=" + currentHighlight.id + "]");
	        for(idx = 0; idx < boxes.length; idx++)
	        {
	            box = boxes[idx];
	            box.className = box.className + " " + classString;
	            box.style.border = "2px solid #000";
	        }
	    }
	}


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/*
	IIIF Highlight plugin for diva.js
	Allows you to highlight regions of a page image based off of annotations in a IIIF Manifest
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	var HighlightManager = __webpack_require__(46).HighlightManager;
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var highlightManager = new HighlightManager(divaInstance);
	                divaSettings.parentObject.data('highlightManager', highlightManager);
	
	                settings.highlightedPages = [];
	
	                /*
	                    Reset the highlights object and removes all highlights from the document.
	                */
	                divaInstance.resetHighlights = function()
	                {
	                    highlightManager.clear();
	                };
	
	                /*
	                    Resets the highlights for a single page.
	                */
	                divaInstance.removeHighlightsOnPage = function(pageIdx)
	                {
	                    highlightManager.removeHighlightsOnPage(pageIdx);
	                };
	
	                divaInstance.hideHighlights = function()
	                {
	                    settings.highlightsVisible = false;
	                    $(divaSettings.innerElement).addClass('annotations-hidden');
	                };
	
	                divaInstance.showHighlights = function()
	                {
	                    settings.highlightsVisible = true;
	                    $(divaSettings.innerElement).removeClass('annotations-hidden');
	                };
	
	                /*
	                    Highlights regions on multiple pages.
	                    @param pageIdxs An array of page index numbers
	                    @param regions  An array of regions
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                */
	                divaInstance.highlightOnPages = function(pageIdxs, regions, colour, divClass)
	                {
	                    var j = pageIdxs.length;
	                    while (j--)
	                    {
	                        divaInstance.highlightOnPage(pageIdxs[j], regions[j], colour, divClass);
	                    }
	                };
	
	                /*
	                    Highlights regions on a page.
	                    @param pageIdx  A page index number
	                    @param regions  An array of regions. Use {'width':i, 'height':i, 'ulx':i, 'uly': i, 'divID': str} for each region.
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                    @param divClass (optional) A class to identify a group of highlighted regions on a specific page by
	                */
	                divaInstance.highlightOnPage = function(pageIdx, regions, colour, divClass)
	                {
	                    if (colour === undefined)
	                    {
	                        colour = 'rgba(255, 0, 0, 0.2)';
	                    }
	
	                    if (divClass === undefined)
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight';
	                    }
	                    else
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight ' + divClass;
	                    }
	
	                    highlightManager.addHighlight({
	                        page: pageIdx,
	                        regions: regions,
	                        colour: colour,
	                        divClass: divClass
	                    });
	
	                    return true;
	                };
	
	                                /*
	                    Jumps to a highlight somewhere in the document.
	                    @param divID The ID of the div to jump to. This ID must be attached to the div using .highlightOnPage(s) as the highlight may not be appended to the DOM.
	                */
	                divaInstance.gotoHighlight = function(divID)
	                {
	                    var result = highlightManager.getHighlightByRegionId(divID);
	
	                    if (result)
	                        return gotoDiv(result.highlight.page, result.region);
	
	                    console.warn("Diva just tried to find a highlight that doesn't exist.");
	                    return false;
	                };
	
	                /**
	                 * Moves the diva pane to (page)
	                 */
	                var gotoDiv = function(page, thisDiv)
	                {
	                    //gets center of the div
	                    var centerYOfDiv = parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2;
	                    var centerXOfDiv = parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2;
	
	                    var desiredY = divaInstance.translateFromMaxZoomLevel(centerYOfDiv);
	                    var desiredX = divaInstance.translateFromMaxZoomLevel(centerXOfDiv);
	
	                    //navigates to the page
	                    page = parseInt(page, 10);
	                    divaInstance.gotoPageByIndex(page);
	                    var viewportObject = divaInstance.getSettings().viewportObject;
	                    var currentTop = viewportObject.scrollTop() + desiredY - (viewportObject.height() / 2) + divaSettings.verticalPadding;
	                    var currentLeft = viewportObject.scrollLeft() + desiredX - (viewportObject.width() / 2) + divaSettings.horizontalPadding;
	
	                    //changes the scroll location to center on the div as much as is possible
	                    viewportObject.scrollTop(currentTop);
	                    viewportObject.scrollLeft(currentLeft);
	                };
	
	                var showAnnotations = function(canvasIndex)
	                {
	                    return function(data, status, jqXHR)
	                    {
	                        var canvasAnnotations = data;
	                        var numAnnotations = data.length;
	
	                        //convert annotations in annotations object to diva highlight objects
	                        var regions = [];
	
	                        //loop over annotations in a single canvas
	                        for (var k = 0; k < numAnnotations; k++)
	                        {
	                            var currentAnnotation = canvasAnnotations[k];
	                            // get text content
	                            var text = currentAnnotation.resource.chars;
	
	                            // get x,y,w,h (slice string from '#xywh=' to end)
	                            var onString = currentAnnotation.on;
	                            var coordString = onString.slice(onString.indexOf('#xywh=') + 6);
	                            var coordinates = coordString.split(',');
	
	                            var region = {
	                                ulx: parseInt(coordinates[0], 10),
	                                uly: parseInt(coordinates[1], 10),
	                                width: parseInt(coordinates[2], 10),
	                                height: parseInt(coordinates[3], 10),
	                                name: text
	                            };
	
	                            regions.push(region);
	                        }
	
	                        divaInstance.highlightOnPage(canvasIndex, regions);
	                        //flag this page's annotations as having been retrieved
	                        settings.highlightedPages.push(canvasIndex);
	                    };
	                };
	
	                var getAnnotationsList = function(pageIndex)
	                {
	                    //if page has annotationList
	                    var canvases = settings.manifest.sequences[0].canvases;
	
	                    if (canvases[pageIndex].hasOwnProperty('otherContent'))
	                    {
	                        var otherContent = canvases[pageIndex].otherContent;
	
	                        for (var j = 0; j < otherContent.length; j++)
	                        {
	                            if (otherContent[j]['@type'] === 'sc:AnnotationList')
	                            {
	                                // canvas has annotations. get the annotations:
	                                $.ajax({
	                                    url: otherContent[j]['@id'],
	                                    cache: true,
	                                    dataType: 'json',
	                                    success: showAnnotations(pageIndex)
	                                });
	                            }
	                        }
	                    }
	                };
	
	                var setManifest = function(manifest)
	                {
	                    settings.manifest = manifest;
	                };
	
	                diva.Events.subscribe('ManifestDidLoad', setManifest, divaSettings.ID);
	
	                diva.Events.subscribe('PageWillLoad', function(pageIndex)
	                {
	                    if (!settings.highlightsVisible)
	                    {
	                        return;
	                    }
	
	                    //if highlights for this page have already been checked/loaded, return
	                    for (var i = 0; i < settings.highlightedPages.length; i++)
	                    {
	                        if (settings.highlightedPages[i] === pageIndex)
	                        {
	                            return;
	                        }
	                    }
	
	                    getAnnotationsList(pageIndex, settings.manifest);
	                }, divaSettings.ID);
	
	                var activeOverlays = [];
	
	                //on mouseover, show the annotation text
	                divaSettings.innerObject.on('mouseenter', '.' + divaSettings.ID + 'highlight', function(e)
	                {
	                    var annotationElement = e.target;
	                    var name = annotationElement.dataset.name;
	                    var textOverlay = document.createElement('div');
	
	                    textOverlay.style.top = (annotationElement.offsetTop + annotationElement.offsetHeight - 1) + 'px';
	                    textOverlay.style.left = annotationElement.style.left;
	                    textOverlay.style.background = '#fff';
	                    textOverlay.style.border = '1px solid #555';
	                    textOverlay.style.position = 'absolute';
	                    textOverlay.style.zIndex = 101;
	                    textOverlay.className = 'annotation-overlay';
	                    textOverlay.textContent = name;
	
	                    annotationElement.parentNode.appendChild(textOverlay);
	                    activeOverlays.push(textOverlay);
	                });
	
	                divaSettings.innerObject.on('mouseleave', '.' + divaSettings.ID + 'highlight', function(e)
	                {
	                    while (activeOverlays.length)
	                    {
	                        var textOverlay = activeOverlays.pop();
	                        textOverlay.parentNode.removeChild(textOverlay);
	                    }
	                });
	
	                diva.Events.subscribe('ViewerDidLoad', function(){
	                    //button to toggle annotations
	                    $('#' + divaSettings.ID + 'page-nav').before('<div id="' + divaSettings.ID + 'annotations-icon" class="diva-button diva-annotations-icon" title="Turn annotations on or off"></div>');
	
	                    $(divaSettings.selector + 'annotations-icon').addClass('annotations-icon-active');
	
	                    $('#' + divaSettings.ID + 'annotations-icon').on('click', function(e)
	                    {
	                        //toggle visibility of annotations
	                        if (settings.highlightsVisible)
	                        {
	                            divaInstance.hideHighlights();
	                            $(divaSettings.selector + 'annotations-icon').removeClass('annotations-icon-active');
	                        }
	                        else
	                        {
	                            divaInstance.showHighlights();
	                            $(divaSettings.selector + 'annotations-icon').addClass('annotations-icon-active');
	                        }
	                    });
	                }, divaSettings.ID);
	
	                //enable annotations by default
	                settings.highlightsVisible = true;
	
	                return true;
	            },
	            destroy: function (divaSettings, divaInstance)
	            {
	                divaSettings.parentObject.removeData('highlights');
	            },
	            pluginName: 'IIIFHighlight',
	            titleText: 'Highlight regions of pages'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// IIIF Metadata plugin for diva.js
	// Displays object metadata from a IIIF manifest
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var _displayMetadata = function(manifest)
	                {
	                    var showMetadata = function(label, value)
	                    {
	                        var labelProper = label.charAt(0).toUpperCase() + label.slice(1);
	                        var labelFormatted = labelProper.replace('_', ' ');
	
	                        if (value.match(/^https?:\/\//))
	                        {
	                            value = '<a href="' + value + '" target="_blank">' + value + '</a>';
	                        }
	
	                        return '<div class="metadata-row"><span class="metadata-label">' + labelFormatted + ':</span> <span class="metadata-value">' +
	                            value  + '</span></div>';
	                    };
	
	                    var getDataForLanguage = function(data, language)
	                    {
	                        for (var i = 0; i < data.length; i++)
	                        {
	                            if (data[i]['@language'] === language)
	                            {
	                                return data[i]['@value'];
	                            }
	                        }
	                    };
	
	                    /**
	                     * Shows metadata from label names (if the metadata exists).
	                     * @param names {Array} - An array of strings representing field names to display.
	                     */
	                    var showMetadataFromLabelNames = function(names)
	                    {
	                        var elements = '';
	
	                        for (var i = 0; i < names.length; i++)
	                        {
	                            var field = names[i];
	
	                            if (manifest.hasOwnProperty(field))
	                            {
	                                if (manifest[field].constructor === Array)
	                                {
	                                    //multiple languages
	                                    var localizedData = getDataForLanguage(manifest[field], 'en');
	                                    elements += showMetadata(field, localizedData);
	                                }
	                                else
	                                {
	                                    elements += showMetadata(field, manifest[field]);
	                                }
	                            }
	                        }
	
	                        return elements;
	                    };
	
	                    var metadataElement = '<div id="' + divaSettings.ID + 'metadata" class="diva-modal">';
	                    metadataElement += showMetadataFromLabelNames(['label']);
	
	                    if (manifest.hasOwnProperty('metadata'))
	                    {
	                        var metadataField = manifest.metadata;
	
	                        for (var i = 0; i < metadataField.length; i++)
	                        {
	                            if (metadataField[i].value.constructor === Array)
	                            {
	                                var canonicalData = getDataForLanguage(metadataField[i].value, 'en');
	                                metadataElement += showMetadata(metadataField[i].label, canonicalData);
	                            }
	                            else
	                            {
	                                metadataElement += showMetadata(metadataField[i].label, metadataField[i].value);
	                            }
	                        }
	                    }
	
	                    metadataElement += showMetadataFromLabelNames([
	                        'description',
	                        'within',
	                        'see_also',
	                        'license',
	                        'attribution'
	                    ]);
	
	                    metadataElement += '</div>';
	
	                    divaSettings.parentObject.prepend(metadataElement);
	                    $(divaSettings.selector + 'metadata').hide();
	                };
	
	                //subscribe to ManifestDidLoad event, get the manifest
	                diva.Events.subscribe('ManifestDidLoad', _displayMetadata, divaSettings.ID);
	
	                divaSettings.parentObject.prepend('<div style="text-align: center; clear: both"><a href="#" id="' + divaSettings.ID + 'metadata-link" class="diva-metadata-link">Details</a></div>');
	                // $(divaSettings.selector + 'title').append('<div><a href="#" id="' + divaSettings.ID + 'metadata-link" class="diva-metadata-link">Details</a></div>');
	
	                $(divaSettings.selector + 'metadata-link').on('click', function(e)
	                {
	                    $(divaSettings.selector + 'metadata').fadeToggle('fast');
	                });
	
	                return true;
	            },
	            destroy: function (divaSettings, divaInstance)
	            {
	            },
	            pluginName: 'IIIFMetadata',
	            titleText: 'Show metadata from a IIIF manifest'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Diva.JS pagealias plugin
	Author: Andrew Horwitz
	
	Lets pages be set up with custom aliases to allow for sections with different 
	numbering schemas.
	
	Diva needs to be instantiated with one or both of the following settings:
	
	1) a pageAliases dictionary attribute, structured as {(0-indexed page index): 
	(aliased page index)}. For example, a document with three forward pages may be 
	constructed as:
	
	    {0: 'i', 1: 'ii', 2: 'iii'}
	
	This object does not need to have a complete list of possible page indices. 
	
	2) a pageAliasFunction function that takes in a 0-indexed integer value (the 
	original page index) and returns either the aliased page index or the boolean
	value "false". For example, the default mapping from 0-index to 1-index may be 
	constructed as:
	
	    pageAliasFunction: function(originalPageIndex)
	    {
	        return originalPageIndex + 1;
	    }
	
	
	This plugin is solely for cosmetic purposes; it will replace the "Page _ of XX" 
	counter and add functions that run in parallel with their non-aliased 
	equivalents instead of replacing them. When one of the aliased functions is 
	called, the  plugin will first try to find the page alias in the pageAliases 
	attribute. If this fails, the plugin will then pass the original page index into
	the pageAliasFunction function. If this function returns a boolean "false" (NOT 
	a number 0 or an undefined), the plugin will revert to the default page index.
	
	The plugin may also be instantiated with the 'divaSettings.newTotalPages' 
	attribute, which will replace the "Page 1 of __" counter.
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                if (divaSettings.pageAliases === undefined) 
	                {
	                    divaSettings.pageAliases = {};
	                }
	
	                if (divaSettings.pageAliasFunction === undefined)
	                {
	                    divaSettings.pageAliasFunction = function(){return false;};
	                } 
	
	                /*
	                    Main function. Will return the first of these three that 
	                        resolves to boolean true:
	                    -Explicit alias as defined in pageAliases
	                    -Result of pageAliasFunction
	                    -originalPageIndex + 1 (to simulate the original mapping)
	
	                    Else the function will return false.
	                */
	                divaInstance.getAliasForPageIndex = function(originalPageIndex)
	                {
	                    return divaSettings.pageAliases[originalPageIndex] || divaSettings.pageAliasFunction(originalPageIndex) || originalPageIndex + 1;
	                };
	
	                /*
	                    Returns the first page index found for a given aliased number or false if not found.
	                    This may cause issues if a specific alias is found for multiple page indices; use getPageIndicesForAlias and reimplement functions as necessary if this is the case.
	                */
	                divaInstance.getPageIndexForAlias = function(aliasedNumber)
	                {
	                    for(var idx = 0; idx < divaSettings.numPages; idx++)
	                    {
	                        if(divaInstance.getAliasForPageIndex(idx) == aliasedNumber)
	                        {
	                            return idx;
	                        }
	                    }
	                    return false;
	                };
	
	                //Returns array of page indices for a given aliased number. Returns an empty array if none are found.
	                divaInstance.getPageIndicesForAlias = function(aliasedNumber)
	                {
	                    var indexArr = [];
	                    for(var idx = 0; idx < divaSettings.numPages; idx++)
	                    {
	                        if(divaInstance.getAliasForPageIndex(idx) == aliasedNumber)
	                        {
	                            indexArr.push(idx);
	                        }
	                    }
	                    return indexArr;
	                };
	
	
	                //Maps the current page index to getAliasForPageIndex
	                divaInstance.getCurrentAliasedPageIndex = function()
	                {
	                    return divaInstance.getAliasForPageIndex(divaSettings.currentPageIndex);
	                };
	
	                //Wrapper for gotoPageByIndex, keeping the aliased numbers in mind
	                divaInstance.gotoPageByAliasedNumber = function(aliasedNumber, xAnchor, yAnchor)
	                {
	                    return divaInstance.gotoPageByIndex(divaInstance.getPageIndexForAlias(aliasedNumber), xAnchor, yAnchor);
	                };
	
	                //this function overwrites updateCurrentPage from the main diva file to update page numbers on VisiblePAgeDidChange
	                var updateCurrentAliasedPage = function ()
	                {
	                    document.getElementById(this.getSettings().ID + 'current-page').textContent = this.getCurrentAliasedPageIndex();
	                };
	
	                //various changes that need to be made once viewer is loaded
	                var initialChanges = function ()
	                {
	                    //changes total pages value in GUI
	                    var tempSettings = this.getSettings();
	                    var newTotalPages = tempSettings.numPages;
	                    if (tempSettings.newTotalPages !== undefined)
	                    {
	                        newTotalPages = tempSettings.newTotalPages;
	                    }
	
	                    else if (tempSettings.totalPageOffset !== undefined)
	                    {
	                        newTotalPages = newTotalPages + tempSettings.totalPageOffset;
	                    }
	
	                    //actually changes values
	                    document.getElementById(this.getSettings().ID + 'num-pages').textContent = newTotalPages;
	                    document.getElementById(this.getSettings().ID + 'current-page').textContent = this.getCurrentAliasedPageIndex();
	                    
	                    //resubscribes our new update function
	                    diva.Events.unsubscribe(["VisiblePageDidChange", tempSettings.toolbar.updateCurrentPage, divaSettings.ID]);
	                    diva.Events.subscribe("VisiblePageDidChange", updateCurrentAliasedPage, divaSettings.ID);
	                };
	
	                diva.Events.subscribe("ViewerDidLoad", initialChanges, divaSettings.ID);
	            },
	            pluginName: 'pagealias',
	            titleText: 'Re-aliases page indexes'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA3MmQwZGE5MjE3ZDllYTI5YjJlYiIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcmVnaXN0ZXItYnVpbHRpbi1wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9kaXZhLWdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwiLFwiY29tbW9uanNcIjpcImpxdWVyeVwiLFwiY29tbW9uanMyXCI6XCJqcXVlcnlcIn0iLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3V0aWxzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2luLXJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2F1dG9zY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2RpdmEuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3V0aWxzL2VsdC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvdXRpbHMvaGFzaC1wYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2FjdGl2ZS1kaXZhLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2ltYWdlLW1hbmlmZXN0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYXJzZS1paWlmLW1hbmlmZXN0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy90b29sYmFyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy92aWV3ZXItY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvdXRpbHMvanF1ZXJ5LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3V0aWxzL2dldC1zY3JvbGxiYXItd2lkdGguanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2dlc3R1cmUtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9kb2N1bWVudC1oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLm1heGJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9iYXNlaXRlcmF0ZWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC5fc3RyaW5ndG9wYXRoL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLl9zdHJpbmd0b3BhdGgvfi9sb2Rhc2guX2Jhc2V0b3N0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGFnZS10b29scy1vdmVybGF5LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9ncmlkLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhZ2Utb3ZlcmxheS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWJ1Zy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9+L21zL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9jb21wb3NpdGUtaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2RvY3VtZW50LWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvaW1hZ2UtY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2ltYWdlLXJlcXVlc3QtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvaW50ZXJwb2xhdGUtYW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9ib29rLWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL3BhZ2UtZGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL3NpbmdsZXMtbGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvZ3JpZC1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3NldHRpbmdzLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3ZhbGlkYXRpb24tcnVubmVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy92aWV3cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2lucy9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BsdWdpbnMvZG93bmxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BsdWdpbnMvaGlnaGxpZ2h0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtaGlnaGxpZ2h0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BsdWdpbnMvcGFnZWFsaWFzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCLHdCQUF1QjtBQUN2QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbERBLGdEOzs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEIsdUJBQXNCO0FBQ3RCLHVCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCLDBCQUF5QjtBQUN6Qiw0QkFBMkIsUUFBUSwwREFBMEQ7QUFDN0Y7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCLDRCQUEyQixTQUFTO0FBQ3BDLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLG9EQUFtRCxvREFBb0Q7QUFDdkc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0QsbUJBQW1COztBQUV2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDOzs7Ozs7O0FDMVBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXVELEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQThFO0FBQzlFLDhFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQsc0VBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBeUU7QUFDekUsMEVBQXlFO0FBQ3pFLDREQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBeUU7QUFDekUsMEVBQXlFO0FBQ3pFLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsaURBQWlEO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiwwQkFBMEI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDJCQUEyQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLEVBQUM7Ozs7Ozs7QUNqa0NEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDOUZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7Ozs7O0FDdEVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFNBQVM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0Esc0JBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3ZQQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1EQUFrRCxpQkFBaUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0UkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNkNBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDL3JCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELDJEQUEyRDtBQUM5RyxpREFBZ0QsMkRBQTJEOztBQUUzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCw2QkFBNkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsbUNBQW1DO0FBQzFGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBb0QsNkJBQTZCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2OUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUMsb0VBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxjQUFjOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsaURBQWdEO0FBQ2hEO0FBQ0EsOEJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTtBQUNiLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE9BQU07O0FBRU4sRUFBQyxZQUFZOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OztBQ2p0QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlMQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRCxzQkFBc0I7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsNkJBQTZCO0FBQ3hDO0FBQ0EsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBLG9CQUFtQixTQUFTLEdBQUcsU0FBUztBQUN4QztBQUNBLGtDQUFpQyxZQUFZLEVBQUU7QUFDL0MsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxNQUFNO0FBQ2pCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsYUFBYTtBQUN4QixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsRUFBRTtBQUNiLFlBQVcsU0FBUztBQUNwQixZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE1BQU07QUFDakIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsYUFBYTtBQUN4QixZQUFXLFNBQVM7QUFDcEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLGtCQUFrQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGFBQWE7QUFDeEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBLGtCQUFpQixRQUFRLE9BQU8sU0FBUyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsMkJBQTBCLGdCQUFnQixTQUFTLEdBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxPQUFNLE9BQU8sU0FBUyxFQUFFO0FBQ3hCLE9BQU0sT0FBTyxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDL21FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNydUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDeEpBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMEMsaUNBQWlDO0FBQzNFLHlCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOzs7Ozs7O0FDN0VBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7Ozs7Ozs7QUNyR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1DQUFrQyw4QkFBOEI7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNULE1BQUs7O0FBRUwsb0JBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWlELHFCQUFxQjtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNua0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7Ozs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQiw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcE1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUF5QixnQkFBZ0I7QUFDekM7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLFdBQVc7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYyxPQUFPO0FBQ3JCLGdCQUFlLDJDQUEyQztBQUMxRCxnQkFBZSwrQkFBK0I7QUFDOUMsZ0JBQWUsMkJBQTJCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7Ozs7Ozs7QUNoU0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbEhBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsRkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOzs7Ozs7O0FDdkNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1REFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcktBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSzs7QUFFTDtBQUNBOzs7Ozs7O0FDNUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7Ozs7Ozs7QUNqR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSztBQUNMOzs7Ozs7O0FDOUJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbktBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hKQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkIscUJBQW9CO0FBQ3BCLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQThDLHFEQUFxRDs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWdELFdBQVc7QUFDM0Q7QUFDQSx1REFBc0QsWUFBWTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFFQUFvRSw0QkFBNEI7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVGQUFzRixlQUFlO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlEO0FBQ2pELDBCQUF5QjtBQUN6QjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTCxFQUFDOzs7Ozs7O0FDdDhCRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQThFLGVBQWU7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTCxFQUFDOzs7Ozs7O0FDcENEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUE4RCx1REFBdUQ7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrRkFBaUY7QUFDakY7QUFDQTs7QUFFQTs7QUFFQSx5REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOWpCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBOEQsdURBQXVEO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsc0NBQXNDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUM7Ozs7Ozs7QUN2U0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1GQUFrRjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQzs7Ozs7OztBQy9IRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1REFBc0Q7QUFDdEQsc0JBQXFCO0FBQ3JCOztBQUVBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBZ0U7QUFDaEUsa0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0dBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUMiLCJmaWxlIjoiZGl2YS5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wianF1ZXJ5XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImRpdmFcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImRpdmFcIl0gPSBmYWN0b3J5KHJvb3RbXCJqUXVlcnlcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDcyZDBkYTkyMTdkOWVhMjliMmViXG4gKiovIiwidmFyIGRpdmEgPSByZXF1aXJlKCcuL2RpdmEtZ2xvYmFsJyk7XG5cbmRpdmEucmVnaXN0ZXJQbHVnaW4ocmVxdWlyZSgnLi9wbHVnaW5zL2F1dG9zY3JvbGwnKSk7XG5kaXZhLnJlZ2lzdGVyUGx1Z2luKHJlcXVpcmUoJy4vcGx1Z2lucy9jYW52YXMnKSk7XG5kaXZhLnJlZ2lzdGVyUGx1Z2luKHJlcXVpcmUoJy4vcGx1Z2lucy9kb3dubG9hZCcpKTtcbmRpdmEucmVnaXN0ZXJQbHVnaW4ocmVxdWlyZSgnLi9wbHVnaW5zL2hpZ2hsaWdodCcpKTtcbmRpdmEucmVnaXN0ZXJQbHVnaW4ocmVxdWlyZSgnLi9wbHVnaW5zL2lpaWYtaGlnaGxpZ2h0JykpO1xuZGl2YS5yZWdpc3RlclBsdWdpbihyZXF1aXJlKCcuL3BsdWdpbnMvaWlpZi1tZXRhZGF0YScpKTtcbmRpdmEucmVnaXN0ZXJQbHVnaW4ocmVxdWlyZSgnLi9wbHVnaW5zL3BhZ2VhbGlhcycpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvcmVnaXN0ZXItYnVpbHRpbi1wbHVnaW5zLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnRzJyk7XG52YXIgUGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL3BsdWdpbi1yZWdpc3RyeScpO1xuXG52YXIgZGl2YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIEV2ZW50czogbmV3IEV2ZW50cygpLFxuXG4gICAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIChwbHVnaW4pXG4gICAge1xuICAgICAgICBQbHVnaW5SZWdpc3RyeS5yZWdpc3RlcihwbHVnaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRGl2YSBpbnN0YW5jZSBhdCB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7RGl2YX1cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgaWYgKGRpdmEuZmluZChlbGVtZW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGl2YSBpcyBhbHJlYWR5IGluaXRpYWxpemVkIG9uICcgKyByZXByRWxlbShlbGVtZW50KSk7XG5cbiAgICAgICAgdmFyICRlbGVtID0gJChlbGVtZW50KTtcbiAgICAgICAgJGVsZW0uZGl2YShvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gJGVsZW0uZGF0YSgnZGl2YScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIERpdmEgaW5zdGFuY2UgYXR0YWNoZWQgdG8gdGhlXG4gICAgICogZWxlbWVudCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7RGl2YXxudWxsfVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChlbGVtZW50KVxuICAgIHtcbiAgICAgICAgcmV0dXJuICQoZWxlbWVudCkuZGF0YSgnZGl2YScpIHx8IG51bGw7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmVwckVsZW0oZWxlbSlcbntcbiAgICB2YXIgaWQgPSBlbGVtLmlkID8gJyMnICsgZWxlbS5pZCA6IGVsZW0uaWQ7XG4gICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZSA/ICcuJyArIGVsZW0uY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLmpvaW4oJy4nKSA6ICcnO1xuXG4gICAgcmV0dXJuIChpZCA/IGlkIDogZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICsgY2xhc3Nlcztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvZGl2YS1nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwiLFwiY29tbW9uanNcIjpcImpxdWVyeVwiLFwiY29tbW9uanMyXCI6XCJqcXVlcnlcIn1cbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IEV2ZW50cztcblxuLyoqXG4gKiAgICAgIEV2ZW50cy4gUHViL1N1YiBzeXN0ZW0gZm9yIExvb3NlbHkgQ291cGxlZCBsb2dpYy5cbiAqICAgICAgQmFzZWQgb24gUGV0ZXIgSGlnZ2lucycgcG9ydCBmcm9tIERvam8gdG8galF1ZXJ5XG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9waGlnZ2luczQyL2Jsb29keS1qcXVlcnktcGx1Z2lucy9ibG9iL21hc3Rlci9wdWJzdWIuanNcbiAqXG4gKiAgICAgIFJlLWFkYXB0ZWQgdG8gdmFuaWxsYSBKYXZhc2NyaXB0XG4gKlxuICogICAgICBAY2xhc3MgRXZlbnRzXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpXG57XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbn1cblxuLyoqXG4gKiAgICAgIGRpdmEuRXZlbnRzLnB1Ymxpc2hcbiAqICAgICAgZS5nLjogZGl2YS5FdmVudHMucHVibGlzaChcIlBhZ2VEaWRMb2FkXCIsIFtwYWdlSW5kZXgsIGZpbGVuYW1lLCBwYWdlU2VsZWN0b3JdLCB0aGlzKTtcbiAqXG4gKiAgICAgIEBjbGFzcyBFdmVudHNcbiAqICAgICAgQG1ldGhvZCBwdWJsaXNoXG4gKiAgICAgIEBwYXJhbSB0b3BpYyB7U3RyaW5nfVxuICogICAgICBAcGFyYW0gYXJncyAge0FycmF5fVxuICogICAgICBAcGFyYW0gc2NvcGUge09iamVjdD19IE9wdGlvbmFsIC0gU3Vic2NyaWJlZCBmdW5jdGlvbnMgd2lsbCBiZSBleGVjdXRlZCB3aXRoIHRoZSBzdXBwbGllZCBvYmplY3QgYXMgYHRoaXNgLlxuICogICAgICAgICAgSXQgaXMgbmVjZXNzYXJ5IHRvIHN1cHBseSB0aGlzIGFyZ3VtZW50IHdpdGggdGhlIHNlbGYgdmFyaWFibGUgd2hlbiB3aXRoaW4gYSBEaXZhIGluc3RhbmNlLlxuICogICAgICAgICAgVGhlIHNjb3BlIGFyZ3VtZW50IGlzIG1hdGNoZWQgd2l0aCB0aGUgaW5zdGFuY2UgSUQgb2Ygc3Vic2NyaWJlcnMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhleVxuICogICAgICAgICAgICAgIHNob3VsZCBiZSBleGVjdXRlZC4gKFNlZSBpbnN0YW5jZUlEIGFyZ3VtZW50IG9mIHN1YnNjcmliZS4pXG4gKi9cbkV2ZW50cy5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICh0b3BpYywgYXJncywgc2NvcGUpXG57XG4gICAgaWYgKHRoaXMuX2NhY2hlW3RvcGljXSlcbiAgICB7XG4gICAgICAgIHZhciB0aGlzVG9waWMgPSB0aGlzLl9jYWNoZVt0b3BpY107XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzVG9waWMuZ2xvYmFsICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRoaXNUb3BpY0dsb2JhbCA9IHRoaXNUb3BpYy5nbG9iYWw7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsQ291bnQgPSB0aGlzVG9waWNHbG9iYWwubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBnbG9iYWxDb3VudDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXNUb3BpY0dsb2JhbFtpXS5hcHBseShzY29wZSB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY29wZSAmJiB0eXBlb2Ygc2NvcGUuZ2V0SW5zdGFuY2VJZCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGdldCBwdWJsaXNoZXIgaW5zdGFuY2UgSUQgZnJvbSBzY29wZSBhcmcsIGNvbXBhcmUsIGFuZCBleGVjdXRlIGlmIG1hdGNoXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VJRCA9IHNjb3BlLmdldEluc3RhbmNlSWQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlW3RvcGljXVtpbnN0YW5jZUlEXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1RvcGljSW5zdGFuY2UgPSB0aGlzLl9jYWNoZVt0b3BpY11baW5zdGFuY2VJRF07XG4gICAgICAgICAgICAgICAgdmFyIHNjb3BlZENvdW50ID0gdGhpc1RvcGljSW5zdGFuY2UubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqIDwgc2NvcGVkQ291bnQ7IGorKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNUb3BpY0luc3RhbmNlW2pdLmFwcGx5KHNjb3BlLCBhcmdzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlXG4gKiAgICAgIGUuZy46IGRpdmEuRXZlbnRzLnN1YnNjcmliZShcIlBhZ2VEaWRMb2FkXCIsIGhpZ2hsaWdodCwgc2V0dGluZ3MuSUQpXG4gKlxuICogICAgICBAY2xhc3MgRXZlbnRzXG4gKiAgICAgIEBtZXRob2Qgc3Vic2NyaWJlXG4gKiAgICAgIEBwYXJhbSB0b3BpYyB7U3RyaW5nfVxuICogICAgICBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufVxuICogICAgICBAcGFyYW0gaW5zdGFuY2VJRCB7U3RyaW5nPX0gT3B0aW9uYWwgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBJRCBvZiBhIERpdmEgaW5zdGFuY2U7IGlmIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrIG9ubHkgZmlyZXMgZm9yIGV2ZW50cyBwdWJsaXNoZWQgZnJvbSB0aGF0IGluc3RhbmNlLlxuICogICAgICBAcmV0dXJuIEV2ZW50IGhhbmRsZXIge0FycmF5fVxuICovXG5FdmVudHMucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh0b3BpYywgY2FsbGJhY2ssIGluc3RhbmNlSUQpXG57XG4gICAgaWYgKCF0aGlzLl9jYWNoZVt0b3BpY10pXG4gICAge1xuICAgICAgICB0aGlzLl9jYWNoZVt0b3BpY10gPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlSUQgPT09ICdzdHJpbmcnKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVt0b3BpY11baW5zdGFuY2VJRF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW3RvcGljXVtpbnN0YW5jZUlEXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVbdG9waWNdW2luc3RhbmNlSURdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlW3RvcGljXS5nbG9iYWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW3RvcGljXS5nbG9iYWwgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlW3RvcGljXS5nbG9iYWwucHVzaChjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZSA9IGluc3RhbmNlSUQgPyBbdG9waWMsIGNhbGxiYWNrLCBpbnN0YW5jZUlEXSA6IFt0b3BpYywgY2FsbGJhY2tdO1xuXG4gICAgcmV0dXJuIGhhbmRsZTtcbn07XG5cbi8qKlxuICogICAgICBkaXZhLkV2ZW50cy51bnN1YnNjcmliZVxuICogICAgICBlLmcuOiB2YXIgaGFuZGxlID0gRXZlbnRzLnN1YnNjcmliZShcIlBhZ2VEaWRMb2FkXCIsIGhpZ2hsaWdodCk7XG4gKiAgICAgICAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKGhhbmRsZSk7XG4gKlxuICogICAgICBAY2xhc3MgRXZlbnRzXG4gKiAgICAgIEBtZXRob2QgdW5zdWJzY3JpYmVcbiAqICAgICAgQHBhcmFtIGhhbmRsZSB7QXJyYXl9XG4gKiAgICAgIEBwYXJhbSBjb21wbGV0ZWx5IHtCb29sZWFuPX0gLSBVbnN1YnNjcmliZSBhbGwgZXZlbnRzIGZvciBhIGdpdmVuIHRvcGljLlxuICogICAgICBAcmV0dXJuIHN1Y2Nlc3Mge0Jvb2xlYW59XG4gKi9cbkV2ZW50cy5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoaGFuZGxlLCBjb21wbGV0ZWx5KVxue1xuICAgIHZhciB0ID0gaGFuZGxlWzBdO1xuXG4gICAgaWYgKHRoaXMuX2NhY2hlW3RdKVxuICAgIHtcbiAgICAgICAgdmFyIHRvcGljQXJyYXk7XG4gICAgICAgIHZhciBpbnN0YW5jZUlEID0gaGFuZGxlLmxlbmd0aCA9PT0gMyA/IGhhbmRsZVsyXSA6ICdnbG9iYWwnO1xuXG4gICAgICAgIHRvcGljQXJyYXkgPSB0aGlzLl9jYWNoZVt0XVtpbnN0YW5jZUlEXTtcblxuICAgICAgICBpZiAoIXRvcGljQXJyYXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wbGV0ZWx5KVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVbdF1baW5zdGFuY2VJRF07XG4gICAgICAgICAgICByZXR1cm4gdG9waWNBcnJheS5sZW5ndGggPiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSB0b3BpY0FycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRvcGljQXJyYXlbaV0gPT09IGhhbmRsZVsxXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVt0XVtpbnN0YW5jZUlEXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqICAgICAgZGl2YS5FdmVudHMudW5zdWJzY3JpYmVBbGxcbiAqICAgICAgZS5nLjogZGl2YS5FdmVudHMudW5zdWJzY3JpYmVBbGwoJ2dsb2JhbCcpO1xuICpcbiAqICAgICAgQGNsYXNzIEV2ZW50c1xuICogICAgICBAcGFyYW0gaW5zdGFuY2VJRCB7U3RyaW5nPX0gT3B0aW9uYWwgLSBpbnN0YW5jZSBJRCB0byByZW1vdmUgc3Vic2NyaWJlcnMgZnJvbSBvciAnZ2xvYmFsJyAoaWYgb21pdHRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVycyBpbiBhbGwgc2NvcGVzIHJlbW92ZWQpXG4gKiAgICAgIEBtZXRob2QgdW5zdWJzY3JpYmVBbGxcbiAqL1xuRXZlbnRzLnByb3RvdHlwZS51bnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlEKVxue1xuICAgIGlmIChpbnN0YW5jZUlEKVxuICAgIHtcbiAgICAgICAgdmFyIHRvcGljcyA9IE9iamVjdC5rZXlzKHRoaXMuX2NhY2hlKTtcbiAgICAgICAgdmFyIGkgPSB0b3BpY3MubGVuZ3RoO1xuICAgICAgICB2YXIgdG9waWM7XG5cbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdG9waWMgPSB0b3BpY3NbaV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2FjaGVbdG9waWNdW2luc3RhbmNlSURdICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVbdG9waWNdW2luc3RhbmNlSURdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvdXRpbHMvZXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICogVGhlIGdsb2JhbCBwbHVnaW4gcmVnaXN0cnkuXG4gKi9cblxudmFyIHBsdWdpbnMgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChwbHVnaW4pXG4gICAge1xuICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICB9LFxuICAgIGdldEFsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3BsdWdpbi1yZWdpc3RyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG5EaXZhLkpTIGF1dG9zY3JvbGwgcGx1Z2luXG5BdXRob3I6IEFuZHJldyBIb3J3aXR6XG5cbkxldHMgRGl2YSBzY3JvbGwgaW4gdGhlIHByaW1hcnkgZGlyZWN0aW9uIChhcyBkZXRlcm1pbmVkIGJ5XG5zZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQpIGF1dG9tYXRpY2FsbHkgYXQgYSBnaXZlbi9jaGFuZ2VhYmxlIHJhdGUuXG5cblJlbGV2YW50IHNldHRpbmdzOlxuICAgIC1zY3JvbGxTcGVlZDogcGl4ZWxzIHBlciBzZWNvbmQgKGRlZmF1bHRzIHRvIDEwKVxuICAgIC1kaXNhYmxlTWFudWFsU2Nyb2xsOiBkaXNhYmxlcyBtYW51YWwgc2Nyb2xsIHdoaWxlIGF1dG9tYXRpYyBzY3JvbGwgaXMgb24gKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgIC1jdXJyZW50bHlBdXRvU2Nyb2xsaW5nOiB3aGV0aGVyIG9yIG5vdCBhdXRvc2Nyb2xsIGlzIGN1cnJlbnRseSBvblxuICAgIC1hdXRvU2Nyb2xsUmVmcmVzaDogbXMgYmV0d2VlbiBzY3JvbGxpbmcgYWN0aW9uc1xuICAgIC1kaXNhYmxlQXV0b3Njcm9sbFByZWZzOiBkaXNhYmxlcyB0aGUgYXV0b3Njcm9sbCBwcmVmZXJlbmNlcyBwYW5lbFxuXG5SZWxldmFudCBtZXRob2RzOlxuICAgIC1zdGFydFNjcm9sbGluZywgc3RvcFNjcm9sbGluZywgdG9nZ2xlU2Nyb2xsaW5nXG4gICAgLWNoYW5nZVJlZnJlc2gsIGNoYW5nZVNjcm9sbFNwZWVkIChzZXR0ZXJzIGZvciByZXNwZWN0aXZlIG9wdGlvbnMpXG4gICAgLWRpc2FibGVNYW51YWxTY3JvbGwsIGVuYWJsZU1hbnVhbFNjcm9sbFxuKi9cblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIGRpdmEgPSByZXF1aXJlKCcuLi9kaXZhJyk7XG5cbihmdW5jdGlvbiAoJClcbntcbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbHNQZXJTY3JvbGw7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FibGVNYW51YWxTY3JvbGw7XG4gICAgICAgICAgICAgICAgdmFyIGF1dG9TY3JvbGxSZWZyZXNoO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0QXV0b1JlZnJlc2g7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFNwZWVkO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbG9nMTAoeClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGgubG9nKDEwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2Uuc3RhcnRTY3JvbGxpbmcgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLmN1cnJlbnRseUF1dG9TY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIllvdSBhcmUgdHJ5aW5nIHRvIHN0YXJ0IGF1dG9zY3JvbGxpbmcsIGJ1dCBpdCBpcyBhbHJlYWR5IHNjcm9sbGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXRvZ2dsZVwiKS50ZXh0KFwiVHVybiBvZmZcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlTWFudWFsU2Nyb2xsKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZGlzYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydFNjcm9sbGluZ0ludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciByZXN0YXJ0U2Nyb2xsaW5nSW50ZXJ2YWwgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGRpdmFTZXR0aW5ncy5hdXRvU2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbFRvcChkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Quc2Nyb2xsVG9wKCkgKyBwaXhlbHNQZXJTY3JvbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYXV0b1Njcm9sbFJlZnJlc2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoKSArIHBpeGVsc1BlclNjcm9sbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhdXRvU2Nyb2xsUmVmcmVzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnN0b3BTY3JvbGxpbmcgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJZb3UgYXJlIHRyeWluZyB0byBzdG9wIGF1dG9zY3JvbGxpbmcsIGJ1dCBpdCBpcyBub3QgY3VycmVudGx5IGFjdGl2ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXRvZ2dsZVwiKS50ZXh0KFwiVHVybiBvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVNYW51YWxTY3JvbGwpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5lbmFibGVTY3JvbGxhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGRpdmFTZXR0aW5ncy5hdXRvU2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UudG9nZ2xlU2Nyb2xsaW5nID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnN0b3BTY3JvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5jaGFuZ2VSZWZyZXNoID0gZnVuY3Rpb24obmV3UmVmcmVzaClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxSZWZyZXNoID0gbmV3UmVmcmVzaDtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGl4ZWxzUGVyU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5jaGFuZ2VTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uKG5ld1NwZWVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsU3BlZWQgPSBuZXdTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGl4ZWxzUGVyU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC1wcHNcIikudmFsKGxvZzEwKHNjcm9sbFNwZWVkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGFydFNjcm9sbGluZ0ludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVBpeGVsc1BlclNjcm9sbCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxSZWZyZXNoID0gZGVmYXVsdEF1dG9SZWZyZXNoO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNQZXJTY3JvbGwgPSBzY3JvbGxTcGVlZCAvICgxMDAwIC8gYXV0b1Njcm9sbFJlZnJlc2gpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkIGJlIG1pbmltdW0gb2Ygb25lIG90aGVyd2lzZSBpdCB3b24ndCBjaGFuZ2UgdGhlIGFjdHVhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXIgY2FuIGNoYW5nZSBhdXRvc2Nyb2xscmVmcmVzaCBvciBzY3JvbGxzcGVlZDsgdGhpcyBtYXkgb3ZlcndyaXRlIGF1dG9TY3JvbGxSZWZyZXNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbHNQZXJTY3JvbGwgPCAxKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsUmVmcmVzaCA9IGF1dG9TY3JvbGxSZWZyZXNoICogKDEgLyBwaXhlbHNQZXJTY3JvbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzUGVyU2Nyb2xsID0gc2Nyb2xsU3BlZWQgLyAoMTAwMCAvIGF1dG9TY3JvbGxSZWZyZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZGlzYWJsZU1hbnVhbFNjcm9sbCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVNYW51YWxTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLmN1cnJlbnRseUF1dG9TY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5kaXNhYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5lbmFibGVNYW51YWxTY3JvbGwgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlTWFudWFsU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmVuYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5hdXRvU2Nyb2xsSW50ZXJ2YWwgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgZGlzYWJsZU1hbnVhbFNjcm9sbCA9IGRpdmFTZXR0aW5ncy5kaXNhYmxlTWFudWFsU2Nyb2xsIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxSZWZyZXNoID0gZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxSZWZyZXNoIHx8IDUwO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBdXRvUmVmcmVzaCA9IGF1dG9TY3JvbGxSZWZyZXNoO1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmNoYW5nZVNjcm9sbFNwZWVkKChkaXZhU2V0dGluZ3Muc2Nyb2xsU3BlZWQgfHwgMTApKTtcblxuICAgICAgICAgICAgICAgICQod2luZG93KS5vbigna2V5dXAnLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSAzMilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnRvZ2dsZVNjcm9sbGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRpdmFTZXR0aW5ncy5kaXNhYmxlQXV0b3Njcm9sbFByZWZzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldFBvc2l0aW9uID0gZnVuY3Rpb24oaXNGdWxsc2NyZWVuKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLmluRnVsbHNjcmVlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHNjcmVlblRvb2xzID0gJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAndG9vbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9vbHNNYXJnaW4gPSBmdWxsc2NyZWVuVG9vbHMuY3NzKCdyaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmpxT2JqLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyaWdodCc6IHRvb2xzTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RvcCc6IGZ1bGxzY3JlZW5Ub29scy5vZmZzZXQoKS50b3AgKyBmdWxsc2NyZWVuVG9vbHMub3V0ZXJIZWlnaHQoKSArIDE1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuanFPYmouY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0JzogJCh3aW5kb3cpLndpZHRoKCkgLSAoZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0Lm9mZnNldCgpLmxlZnQgKyBkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Qub3V0ZXJXaWR0aCgpKSArIGRpdmFTZXR0aW5ncy5zY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1yaWdodCc6ICcuNmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmpxT2JqLm9mZnNldCh7J3RvcCc6IGRpdmFTZXR0aW5ncy52aWV3cG9ydE9iamVjdC5vZmZzZXQoKS50b3AgKyAxfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdNb2RlRGlkU3dpdGNoJywgc2V0UG9zaXRpb24sIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJEaWRMb2FkJywgZnVuY3Rpb24ocylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9zY3JvbGxQcmVmc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXByZWZzJyBjbGFzcz0nZGl2YS1hdXRvc2Nyb2xsLXByZWZzIGRpdmEtcG9wdXAnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxiPkF1dG9zY3JvbGxpbmcgb3B0aW9uczo8L2I+PGJyPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtcHJlZnMtdGV4dCc+U3BlZWQ6PC9zcGFuPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxpbnB1dCB0eXBlPSdyYW5nZScgaWQ9J1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXBwcycgY2xhc3M9J2RpdmEtYXV0b3Njcm9sbC1wcHMgZGl2YS1hdXRvc2Nyb2xsLXByZWZzLWlucHV0JyB2YWx1ZT0nXCIgKyBsb2cxMChzY3JvbGxTcGVlZCkgKyBcIicgbWluPScwJyBtYXg9JzMnIHN0ZXA9JzAuMSc+PGJyPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtcHJlZnMtdGV4dCc+QWxsb3cgbWFudWFsIHNjcm9sbDo8L3NwYW4+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGlucHV0IHR5cGU9J2NoZWNrYm94JyBpZD0nXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtbWFudWFsJyBjbGFzcz0nZGl2YS1hdXRvc2Nyb2xsLW1hbnVhbCBkaXZhLWF1dG9zY3JvbGwtcHJlZnMtaW5wdXQnIGNoZWNrZWQ9J2NoZWNrZWQnPjxicj5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8YnV0dG9uIGlkPSdcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC10b2dnbGUnIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtcHJlZnMtdG9nZ2xlIGRpdmEtYXV0b3Njcm9sbC1wcmVmcy1pbnB1dCc+IFR1cm4gb24gPC9idXR0b24+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcInBhZ2UtbmF2XCIpLmJlZm9yZShcIjxkaXYgaWQ9J1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLWljb24nIGNsYXNzPSdkaXZhLWJ1dHRvbiBkaXZhLWF1dG9zY3JvbGwtaWNvbicgdGl0bGU9J0V4cGFuZCBhdXRvc2Nyb2xsIG9wdGlvbnMnPjwvZGl2PlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCJib2R5XCIpLnByZXBlbmQoYXV0b3Njcm9sbFByZWZzU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC1wcHNcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmNoYW5nZVNjcm9sbFNwZWVkKE1hdGgucG93KDEwLCBlLnRhcmdldC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtbWFudWFsXCIpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldC5jaGVja2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZW5hYmxlTWFudWFsU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZGlzYWJsZU1hbnVhbFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtdG9nZ2xlXCIpLm9uKCdjbGljaycsIGRpdmFJbnN0YW5jZS50b2dnbGVTY3JvbGxpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLWljb25cIikub24oJ2NsaWNrJywgZnVuY3Rpb24oZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5qcU9iaiA9ICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtcHJlZnNcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuanFPYmouY3NzKCdkaXNwbGF5JykgPT09ICdub25lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmpxT2JqLmNzcyh7J2Rpc3BsYXknOiAnYmxvY2snfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UG9zaXRpb24oZGl2YVNldHRpbmdzLmluRnVsbHNjcmVlbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuanFPYmouY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGl2YVNldHRpbmdzLklEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ2F1dG9zY3JvbGwnLFxuICAgICAgICAgICAgdGl0bGVUZXh0OiAnQXV0b21hdGljYWxseSBzY3JvbGxzIHBhZ2UgYWxvbmcgcHJpbWFyeSBheGlzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH0pKCk7XG59KShqUXVlcnkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9wbHVnaW5zL2F1dG9zY3JvbGwuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuQ29weXJpZ2h0IChDKSAyMDExLTIwMTYgYnkgV2VuZHkgTGl1LCBFdmFuIE1hZ29uaSwgQW5kcmV3IEhhbmtpbnNvbiwgQW5kcmV3IEhvcndpdHosIExhdXJlbnQgUHVnaW5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcbnZhciBIYXNoUGFyYW1zID0gcmVxdWlyZSgnLi91dGlscy9oYXNoLXBhcmFtcycpO1xuXG52YXIgQWN0aXZlRGl2YUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2FjdGl2ZS1kaXZhLWNvbnRyb2xsZXInKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi9kaXZhLWdsb2JhbCcpO1xudmFyIEltYWdlTWFuaWZlc3QgPSByZXF1aXJlKCcuL2ltYWdlLW1hbmlmZXN0Jyk7XG52YXIgY3JlYXRlVG9vbGJhciA9IHJlcXVpcmUoJy4vdG9vbGJhcicpO1xudmFyIFZpZXdlckNvcmUgPSByZXF1aXJlKCcuL3ZpZXdlci1jb3JlJyk7XG5cbi8vIFN0YXJ0IHRoZSBhY3RpdmUgRGl2YSB0cmFja2VyXG4vLyBGSVhNRSh3YWJhaW4pOiBDb3VsZCBkZWZlciB0aGlzLCBpZiB0aGUgbG9naWMgaXNuJ3QganVzdCBnZXR0aW5nIHJlbW92ZWRcbnZhciBhY3RpdmVEaXZhID0gbmV3IEFjdGl2ZURpdmFDb250cm9sbGVyKCk7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcblxubW9kdWxlLmV4cG9ydHMgPSBkaXZhO1xuXG4vLyB0aGlzIHBhdHRlcm4gd2FzIHRha2VuIGZyb20gaHR0cDovL3d3dy52aXJnZW50ZWNoLmNvbS9ibG9nLzIwMDkvMTAvYnVpbGRpbmctb2JqZWN0LW9yaWVudGVkLWpxdWVyeS1wbHVnaW4uaHRtbFxuKGZ1bmN0aW9uICgkKVxue1xuICAgIHZhciBEaXZhID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpXG4gICAge1xuICAgICAgICAvLyBHbG9iYWwgaW5zdGFuY2UgdmFyaWFibGVzIChzZXQgd2F5IGRvd24gaW4gYGluaXRgKVxuICAgICAgICB2YXIgc2V0dGluZ3MsIHZpZXdlclN0YXRlLCBkaXZhU3RhdGU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBUaGVzZSBhcmUgZWxlbWVudHMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiB1cG9uIGluc3RhbnRpYXRpb25cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ERE1BTC9kaXZhLmpzL3dpa2kvU2V0dGluZ3MgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgYWRhcHRpdmVQYWRkaW5nOiAwLjA1LCAgICAgIC8vIFRoZSByYXRpbyBvZiBwYWRkaW5nIHRvIHRoZSBwYWdlIGRpbWVuc2lvblxuICAgICAgICAgICAgYXJyb3dTY3JvbGxBbW91bnQ6IDQwLCAgICAgIC8vIFRoZSBhbW91bnQgKGluIHBpeGVscykgdG8gc2Nyb2xsIGJ5IHdoZW4gdXNpbmcgYXJyb3cga2V5c1xuICAgICAgICAgICAgYmxvY2tNb2JpbGVNb3ZlOiBmYWxzZSwgICAgIC8vIFByZXZlbnQgbW92aW5nIG9yIHNjcm9sbGluZyB0aGUgcGFnZSBvbiBtb2JpbGUgZGV2aWNlc1xuICAgICAgICAgICAgb2JqZWN0RGF0YTogJycsICAgICAgICAgICAgIC8vIEEgSUlJRiBNYW5pZmVzdCBvciBhIEpTT04gZmlsZSBnZW5lcmF0ZWQgYnkgcHJvY2Vzcy5weSB0aGF0IHByb3ZpZGVzIHRoZSBvYmplY3QgZGltZW5zaW9uIGRhdGEsIG9yIGEgVVJMIHBvaW50aW5nIHRvIHN1Y2ggZGF0YSAtICpSRVFVSVJFRCpcbiAgICAgICAgICAgIGVuYWJsZUF1dG9UaXRsZTogdHJ1ZSwgICAgICAvLyBTaG93cyB0aGUgdGl0bGUgd2l0aGluIGEgZGl2IG9mIGlkIGRpdmEtdGl0bGVcbiAgICAgICAgICAgIGVuYWJsZUZpbGVuYW1lOiB0cnVlLCAgICAgICAvLyBVc2VzIGZpbGVuYW1lcyBhbmQgbm90IHBhZ2UgbnVtYmVycyBmb3IgbGlua3MgKGk9Ym1fMDAxLnRpZiwgbm90IHA9MSlcbiAgICAgICAgICAgIGVuYWJsZUZ1bGxzY3JlZW46IHRydWUsICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBmdWxsc2NyZWVuIGljb24gKG1vZGUgc3RpbGwgYXZhaWxhYmxlKVxuICAgICAgICAgICAgZW5hYmxlR290b1BhZ2U6IHRydWUsICAgICAgIC8vIEEgXCJnbyB0byBwYWdlXCIganVtcCBib3hcbiAgICAgICAgICAgIGVuYWJsZUdvdG9TdWdnZXN0aW9uczogdHJ1ZSwgLy8gQ29udHJvbHMgd2hldGhlciBzdWdnZXN0aW9ucyBhcmUgc2hvd24gdW5kZXIgdGhlIGlucHV0IGZpZWxkIHdoZW4gdGhlIHVzZXIgaXMgdHlwaW5nIGluIHRoZSAnZ28gdG8gcGFnZScgZm9ybVxuICAgICAgICAgICAgZW5hYmxlR3JpZEljb246IHRydWUsICAgICAgIC8vIEEgZ3JpZCB2aWV3IG9mIGFsbCB0aGUgcGFnZXNcbiAgICAgICAgICAgIGVuYWJsZUdyaWRDb250cm9sczogJ2J1dHRvbnMnLCAgLy8gU3BlY2lmeSBjb250cm9sIG9mIHBhZ2VzIHBlciBncmlkIHJvdyBpbiBHcmlkIHZpZXcuIFBvc3NpYmxlIHZhbHVlczogJ2J1dHRvbnMnICgrLy0pLCAnc2xpZGVyJy4gQW55IG90aGVyIHZhbHVlIGRpc2FibGVzIHRoZSBjb250cm9scy5cbiAgICAgICAgICAgIGVuYWJsZUltYWdlVGl0bGVzOiB0cnVlLCAgICAvLyBBZGRzIFwiUGFnZSB7bn1cIiB0aXRsZSB0byBwYWdlIGltYWdlcyBpZiB0cnVlXG4gICAgICAgICAgICBlbmFibGVLZXlTY3JvbGw6IHRydWUsICAgICAgLy8gQ2FwdHVyZXMgc2Nyb2xsaW5nIHVzaW5nIHRoZSBhcnJvdyBhbmQgcGFnZSB1cC9kb3duIGtleXMgcmVnYXJkbGVzcyBvZiBwYWdlIGZvY3VzLiBXaGVuIG9mZiwgZGVmZXJzIHRvIGRlZmF1bHQgYnJvd3NlciBzY3JvbGxpbmcgYmVoYXZpb3IuXG4gICAgICAgICAgICBlbmFibGVMaW5rSWNvbjogdHJ1ZSwgICAgICAgLy8gQ29udHJvbHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGxpbmsgaWNvblxuICAgICAgICAgICAgZW5hYmxlTm9uUGFnZWRWaXNpYmlsaXR5SWNvbjogdHJ1ZSwgLy8gQ29udHJvbHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGljb24gdG8gdG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIG5vbi1wYWdlZCBwYWdlcy4gKEF1dG9tYXRpY2FsbHkgaGlkZGVuIGlmIG5vICdub24tcGFnZWQnIHBhZ2VzKS5cbiAgICAgICAgICAgIGVuYWJsZVNwYWNlU2Nyb2xsOiBmYWxzZSwgICAvLyBTY3JvbGxpbmcgZG93biBieSBwcmVzc2luZyB0aGUgc3BhY2Uga2V5XG4gICAgICAgICAgICBlbmFibGVUb29sYmFyOiB0cnVlLCAgICAgICAgLy8gRW5hYmxlcyB0aGUgdG9vbGJhci4gTm90ZSB0aGF0IGRpc2FibGluZyB0aGlzIG1lYW5zIHlvdSBoYXZlIHRvIGhhbmRsZSBhbGwgY29udHJvbHMgeW91cnNlbGYuXG4gICAgICAgICAgICBlbmFibGVab29tQ29udHJvbHM6ICdidXR0b25zJywgLy8gU3BlY2lmeSBjb250cm9scyBmb3Igem9vbWluZyBpbiBhbmQgb3V0LiBQb3NzaWJsZSB2YWx1ZXM6ICdidXR0b25zJyAoKy8tKSwgJ3NsaWRlcicuIEFueSBvdGhlciB2YWx1ZSBkaXNhYmxlcyB0aGUgY29udHJvbHMuXG4gICAgICAgICAgICBmaWxsUGFyZW50SGVpZ2h0OiB0cnVlLCAgICAgLy8gVXNlIGEgZmxleGJveCBsYXlvdXQgdG8gYWxsb3cgRGl2YSB0byBmaWxsIGl0cyBwYXJlbnQncyBoZWlnaHRcbiAgICAgICAgICAgIGZpeGVkUGFkZGluZzogMTAsICAgICAgICAgICAvLyBGYWxsYmFjayBpZiBhZGFwdGl2ZSBwYWRkaW5nIGlzIHNldCB0byAwXG4gICAgICAgICAgICBmaXhlZEhlaWdodEdyaWQ6IHRydWUsICAgICAgLy8gU28gZWFjaCBwYWdlIGluIGdyaWQgdmlldyBoYXMgdGhlIHNhbWUgaGVpZ2h0IChvbmx5IHdpZHRocyBkaWZmZXIpXG4gICAgICAgICAgICBnb0RpcmVjdGx5VG86IDAsICAgICAgICAgICAgLy8gRGVmYXVsdCBpbml0aWFsIHBhZ2UgdG8gc2hvdyAoMC1pbmRleGVkKVxuICAgICAgICAgICAgaGFzaFBhcmFtU3VmZml4OiBudWxsLCAgICAgIC8vIFVzZWQgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgZG9jdW1lbnQgdmlld2VycyBvbiBhIHBhZ2VcbiAgICAgICAgICAgIGlpcFNlcnZlclVSTDogJycsICAgICAgICAgICAvLyBUaGUgVVJMIHRvIHRoZSBJSVBJbWFnZSBpbnN0YWxsYXRpb24sIGluY2x1ZGluZyB0aGUgYD9GSUY9YCAtICpSRVFVSVJFRCosIHVubGVzcyB1c2luZyBJSUlGXG4gICAgICAgICAgICBpbkZ1bGxzY3JlZW46IGZhbHNlLCAgICAgICAgLy8gU2V0IHRvIHRydWUgdG8gbG9hZCBmdWxsc2NyZWVuIG1vZGUgaW5pdGlhbGx5XG4gICAgICAgICAgICBpbkJvb2tMYXlvdXQ6IGZhbHNlLCAgICAgICAvLyBTZXQgdG8gdHJ1ZSB0byB2aWV3IHRoZSBkb2N1bWVudCB3aXRoIGZhY2luZyBwYWdlcyBpbiBkb2N1bWVudCBtb2RlXG4gICAgICAgICAgICBpbkdyaWQ6IGZhbHNlLCAgICAgICAgICAgICAgLy8gU2V0IHRvIHRydWUgdG8gbG9hZCBncmlkIHZpZXcgaW5pdGlhbGx5XG4gICAgICAgICAgICBpbWFnZURpcjogJycsICAgICAgICAgICAgICAgLy8gSW1hZ2UgZGlyZWN0b3J5LCBlaXRoZXIgYWJzb2x1dGUgcGF0aCBvciByZWxhdGl2ZSB0byBJSVAncyBGSUxFU1lTVEVNX1BSRUZJWCAtICpSRVFVSVJFRCosIHVubGVzcyB1c2luZyBJSUlGXG4gICAgICAgICAgICBtYXhQYWdlc1BlclJvdzogOCwgICAgICAgICAgLy8gTWF4aW11bSBudW1iZXIgb2YgcGFnZXMgcGVyIHJvdyBpbiBncmlkIHZpZXdcbiAgICAgICAgICAgIG1heFpvb21MZXZlbDogLTEsICAgICAgICAgICAvLyBPcHRpb25hbDsgZGVmYXVsdHMgdG8gdGhlIG1heCB6b29tIHJldHVybmVkIGluIHRoZSBKU09OIHJlc3BvbnNlXG4gICAgICAgICAgICBtaW5QYWdlc1BlclJvdzogMiwgICAgICAgICAgLy8gTWluaW11bSBwYWdlcyBwZXIgcm93IGluIGdyaWQgdmlldy4gUmVjb21tZW5kZWQgZGVmYXVsdC5cbiAgICAgICAgICAgIG1pblpvb21MZXZlbDogMCwgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byAwICh0aGUgbWluaW11bSB6b29tKVxuICAgICAgICAgICAgb25Hb3RvU3VibWl0OiBudWxsLCAgICAgICAgIC8vIFdoZW4gc2V0IHRvIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyBhIHBhZ2UgaW5kZXgsIHRoaXMgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhlICdnbyB0byBwYWdlJyBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgICAgIHBhZ2VMb2FkVGltZW91dDogMjAwLCAgICAgICAvLyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGxvYWRpbmcgcGFnZXNcbiAgICAgICAgICAgIHBhZ2VzUGVyUm93OiA1LCAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBudW1iZXIgb2YgcGFnZXMgcGVyIHJvdyBpbiBncmlkIHZpZXdcbiAgICAgICAgICAgIHJvd0xvYWRUaW1lb3V0OiA1MCwgICAgICAgICAvLyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGxvYWRpbmcgYSByb3dcbiAgICAgICAgICAgIHNob3dOb25QYWdlZFBhZ2VzOiBmYWxzZSwgICAvLyBXaGV0aGVyIHBhZ2VzIHRhZ2dlZCBhcyAnbm9uLXBhZ2VkJyAoaW4gSUlJRiBtYW5pZmVzdHMgb25seSkgc2hvdWxkIGJlIHZpc2libGUgYWZ0ZXIgaW5pdGlhbCBsb2FkXG4gICAgICAgICAgICB0aHJvYmJlclRpbWVvdXQ6IDEwMCwgICAgICAgLy8gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzaG93aW5nIHRocm9iYmVyXG4gICAgICAgICAgICB0aWxlSGVpZ2h0OiAyNTYsICAgICAgICAgICAgLy8gVGhlIGhlaWdodCBvZiBlYWNoIHRpbGUsIGluIHBpeGVsczsgdXN1YWxseSAyNTZcbiAgICAgICAgICAgIHRpbGVXaWR0aDogMjU2LCAgICAgICAgICAgICAvLyBUaGUgd2lkdGggb2YgZWFjaCB0aWxlLCBpbiBwaXhlbHM7IHVzdWFsbHkgMjU2XG4gICAgICAgICAgICB0b29sYmFyUGFyZW50T2JqZWN0OiBudWxsLCAgLy8gVGhlIHRvb2xiYXIgcGFyZW50IG9iamVjdC5cbiAgICAgICAgICAgIHZlcnRpY2FsbHlPcmllbnRlZDogdHJ1ZSwgICAvLyBEZXRlcm1pbmVzIHZlcnRpY2FsIHZzLiBob3Jpem9udGFsIG9yaWVudGF0aW9uXG4gICAgICAgICAgICB2aWV3cG9ydE1hcmdpbjogMjAwLCAgICAgICAgLy8gUHJldGVuZCB0aWxlcyArLy0gMjAwcHggYXdheSBmcm9tIHZpZXdwb3J0IGFyZSBpblxuICAgICAgICAgICAgem9vbUxldmVsOiAyICAgICAgICAgICAgICAgIC8vIFRoZSBpbml0aWFsIHpvb20gbGV2ZWwgKHVzZWQgdG8gc3RvcmUgdGhlIGN1cnJlbnQgem9vbSBsZXZlbClcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgcGFnZSBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGZpbGVuYW1lOyBtdXN0IGNhbGxlZCBhZnRlciBzZXR0aW5nIHNldHRpbmdzLm1hbmlmZXN0XG4gICAgICAgIHZhciBnZXRQYWdlSW5kZXggPSBmdW5jdGlvbiAoZmlsZW5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQYWdlSW5kZXhGb3JNYW5pZmVzdChzZXR0aW5ncy5tYW5pZmVzdCwgZmlsZW5hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRQYWdlSW5kZXhGb3JNYW5pZmVzdCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgZmlsZW5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIG5wID0gbWFuaWZlc3QucGFnZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnA7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobWFuaWZlc3QucGFnZXNbaV0uZiA9PT0gZmlsZW5hbWUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayBpZiBhIHBhZ2UgaW5kZXggaXMgdmFsaWRcbiAgICAgICAgdmFyIGlzUGFnZVZhbGlkID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0LmlzUGFnZVZhbGlkKHBhZ2VJbmRleCwgc2V0dGluZ3Muc2hvd05vblBhZ2VkUGFnZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZWxvYWRWaWV3ZXIgPSBmdW5jdGlvbiAobmV3T3B0aW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnJlbG9hZChuZXdPcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiB0aGUgY2hhbmdlIHZpZXcgaWNvbiBpcyBjbGlja2VkXG4gICAgICAgIHZhciBjaGFuZ2VWaWV3ID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uVmlldylcbiAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoIChkZXN0aW5hdGlvblZpZXcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluR3JpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJvb2tMYXlvdXQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5HcmlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQm9va0xheW91dDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2dyaWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluR3JpZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL3RvZ2dsZXMgYmV0d2VlbiBvcmllbnRhdGlvbnNcbiAgICAgICAgdmFyIHRvZ2dsZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsbHlPcmllbnRlZCA9ICFzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQ7XG5cbiAgICAgICAgICAgIC8vaWYgaW4gZ3JpZCwgc3dpdGNoIG91dCBvZiBncmlkXG4gICAgICAgICAgICByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgIGluR3JpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmVydGljYWxseU9yaWVudGVkOiB2ZXJ0aWNhbGx5T3JpZW50ZWQsXG4gICAgICAgICAgICAgICAgZ29EaXJlY3RseVRvOiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0OiBkaXZhU3RhdGUudmlld2VyQ29yZS5nZXRZT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0WE9mZnNldCgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2FsbHlPcmllbnRlZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiB0aGUgZnVsbHNjcmVlbiBpY29uIGlzIGNsaWNrZWRcbiAgICAgICAgdmFyIHRvZ2dsZUZ1bGxzY3JlZW4gPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgIGluRnVsbHNjcmVlbjogIXNldHRpbmdzLmluRnVsbHNjcmVlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFN0YXRlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHZpZXc7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkdyaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmlldyA9ICdnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmluQm9va0xheW91dClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gJ2InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZpZXcgPSAnZCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBkaXZhU3RhdGUudmlld2VyQ29yZS5nZXRDdXJyZW50TGF5b3V0KCk7XG4gICAgICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGxheW91dC5nZXRQYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCB2aWV3ZXJTdGF0ZS52aWV3cG9ydCk7XG5cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAnZic6IHNldHRpbmdzLmluRnVsbHNjcmVlbixcbiAgICAgICAgICAgICAgICAndic6IHZpZXcsXG4gICAgICAgICAgICAgICAgJ3onOiBzZXR0aW5ncy56b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgJ24nOiBzZXR0aW5ncy5wYWdlc1BlclJvdyxcbiAgICAgICAgICAgICAgICAnaSc6IHNldHRpbmdzLmVuYWJsZUZpbGVuYW1lID8gc2V0dGluZ3MubWFuaWZlc3QucGFnZXNbc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleF0uZiA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICdwJzogc2V0dGluZ3MuZW5hYmxlRmlsZW5hbWUgPyBmYWxzZSA6IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICd5JzogcGFnZU9mZnNldCA/IHBhZ2VPZmZzZXQueSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICd4JzogcGFnZU9mZnNldCA/IHBhZ2VPZmZzZXQueCA6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldExvYWRPcHRpb25zRm9yU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIG1hbmlmZXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBtYW5pZmVzdCA9IG1hbmlmZXN0IHx8IHNldHRpbmdzLm1hbmlmZXN0O1xuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICgndicgaW4gc3RhdGUpID8gZ2V0Vmlld1N0YXRlKHN0YXRlLnYpIDoge307XG5cbiAgICAgICAgICAgIGlmICgnZicgaW4gc3RhdGUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pbkZ1bGxzY3JlZW4gPSBzdGF0ZS5mO1xuXG4gICAgICAgICAgICBpZiAoJ3onIGluIHN0YXRlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuem9vbUxldmVsID0gc3RhdGUuejtcblxuICAgICAgICAgICAgaWYgKCduJyBpbiBzdGF0ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2VzUGVyUm93ID0gc3RhdGUubjtcblxuICAgICAgICAgICAgLy8gT25seSBjaGFuZ2Ugc3BlY2lmeSB0aGUgcGFnZSBpZiBzdGF0ZS5pIG9yIHN0YXRlLnAgaXMgdmFsaWRcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSBnZXRQYWdlSW5kZXhGb3JNYW5pZmVzdChtYW5pZmVzdCwgc3RhdGUuaSk7XG5cbiAgICAgICAgICAgIGlmICghKHBhZ2VJbmRleCA+PSAwICYmIHBhZ2VJbmRleCA8IG1hbmlmZXN0LnBhZ2VzLmxlbmd0aCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGFnZUluZGV4ID0gc3RhdGUucCAtIDE7XG5cbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJseSBOYU5cbiAgICAgICAgICAgICAgICBpZiAoIShwYWdlSW5kZXggPj0gMCAmJiBwYWdlSW5kZXggPCBtYW5pZmVzdC5wYWdlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXggPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFnZUluZGV4ICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gcGFyc2VJbnQoc3RhdGUueCwgMTApO1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IHBhcnNlSW50KHN0YXRlLnksIDEwKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZ29EaXJlY3RseVRvID0gcGFnZUluZGV4O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9yaXpvbnRhbE9mZnNldCA9IGhvcml6b250YWxPZmZzZXQ7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy52ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0VVJMSGFzaCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBoYXNoUGFyYW1zID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHZhciBoYXNoU3RyaW5nQnVpbGRlciA9IFtdO1xuICAgICAgICAgICAgdmFyIHBhcmFtO1xuXG4gICAgICAgICAgICBmb3IgKHBhcmFtIGluIGhhc2hQYXJhbXMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc2hQYXJhbXNbcGFyYW1dICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgaGFzaFN0cmluZ0J1aWxkZXIucHVzaChwYXJhbSArIHNldHRpbmdzLmhhc2hQYXJhbVN1ZmZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChoYXNoUGFyYW1zW3BhcmFtXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGFzaFN0cmluZ0J1aWxkZXIuam9pbignJicpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIFVSTCB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQgdmlld2VyIChzbyBpdCBzaG91bGQgYmUgYW4gZXhhY3QgcmVwbGljYSlcbiAgICAgICAgdmFyIGdldEN1cnJlbnRVUkwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgJyMnICsgZ2V0VVJMSGFzaCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRWaWV3U3RhdGUgPSBmdW5jdGlvbih2aWV3KVxuICAgICAgICB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZpZXcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkdyaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5Cb29rTGF5b3V0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkdyaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5Cb29rTGF5b3V0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluR3JpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQm9va0xheW91dDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzaG93RXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5zaG93RXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFqYXhFcnJvciA9IGZ1bmN0aW9uKGpxeGhyLCBzdGF0dXMsIGVycm9yKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBTaG93IGEgYmFzaWMgZXJyb3IgbWVzc2FnZSB3aXRoaW4gdGhlIGRvY3VtZW50IHZpZXdlciBwYW5lXG4gICAgICAgICAgICAvLyBGSVhNRTogTWFrZSB0aGlzIG1vcmUgZW5kLXVzZXIgZnJpZW5kbHkuIFdoYXQgYWJvdXQgNDA0J3MgZXRjP1xuXG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gWydJbnZhbGlkIG9iamVjdERhdGEgc2V0dGluZy4gRXJyb3IgY29kZTogJyArIGpxeGhyLnN0YXR1cyArICcgJyArIGVycm9yXTtcblxuICAgICAgICAgICAgLy8gRGV0ZWN0IGFuZCBoYW5kbGUgQ09SUyBlcnJvcnNcbiAgICAgICAgICAgIHZhciBkYXRhSGFzQWJzb2x1dGVQYXRoID0gc2V0dGluZ3Mub2JqZWN0RGF0YS5sYXN0SW5kZXhPZignaHR0cCcsIDApID09PSAwO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUhhc0Fic29sdXRlUGF0aCAmJiBlcnJvciA9PT0gJycpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb25Ib3N0ID0gc2V0dGluZ3Mub2JqZWN0RGF0YS5yZXBsYWNlKC9odHRwcz86XFwvXFwvL2ksIFwiXCIpLnNwbGl0KC9bLz8jXS8pWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uLmhvc3RuYW1lICE9PSBqc29uSG9zdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWx0KCdwJywgJ0F0dGVtcHRlZCB0byBhY2Nlc3MgY3Jvc3Mtb3JpZ2luIGRhdGEgd2l0aG91dCBDT1JTLicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWx0KCdwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIHVwZGF0ZSB5b3VyIHNlcnZlciBjb25maWd1cmF0aW9uIHRvIHN1cHBvcnQgQ09SUy4gRm9yIGhlbHAsIHNlZSB0aGUgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHQoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICdodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy93aWtpL0luc3RhbGxhdGlvbiNhLW5vdGUtYWJvdXQtY3Jvc3Mtc2l0ZS1yZXF1ZXN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ19ibGFuaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAnY3Jvc3Mtc2l0ZSByZXF1ZXN0IGRvY3VtZW50YXRpb24uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNob3dFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb2FkT2JqZWN0RGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZURhdGEsIGhhc2hTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlzSUlJRiwgbWFuaWZlc3Q7XG5cbiAgICAgICAgICAgIC8vIHBhcnNlIElJSUYgbWFuaWZlc3QgaWYgaXQgaXMgYW4gSUlJRiBtYW5pZmVzdC4gVE9ETyBpbXByb3ZlIElJSUYgZGV0ZWN0aW9uIG1ldGhvZFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5oYXNPd25Qcm9wZXJ0eSgnQGNvbnRleHQnKSAmJiAocmVzcG9uc2VEYXRhWydAY29udGV4dCddLmluZGV4T2YoJ2lpaWYnKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICByZXNwb25zZURhdGFbJ0Bjb250ZXh0J10uaW5kZXhPZignc2hhcmVkLWNhbnZhcycpICE9PSAtMSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaXNJSUlGID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgTWFuaWZlc3REaWRMb2FkIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFdoeSBpcyB0aGlzIHRyaWdnZXJlZCBiZWZvcmUgdGhlIG1hbmlmZXN0IGlzIHBhcnNlZD9cbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5wdWJsaXNoKCdNYW5pZmVzdERpZExvYWQnLCBbcmVzcG9uc2VEYXRhXSwgc2VsZik7XG5cbiAgICAgICAgICAgICAgICBtYW5pZmVzdCA9IEltYWdlTWFuaWZlc3QuZnJvbUlJSUYocmVzcG9uc2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBJSVAgc3VwcG9ydCBpcyBub3cgZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVzYWdlIG9mIElJUCBtYW5pZmVzdHMgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgc3dpdGNoaW5nIHRvIElJSUYgbWFuaWZlc3RzLiBWaXNpdCBodHRwOi8vaWlpZi5pby8gZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuXG4gICAgICAgICAgICAgICAgaXNJSUlGID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3QgPSBJbWFnZU1hbmlmZXN0LmZyb21MZWdhY3lNYW5pZmVzdChyZXNwb25zZURhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgaWlwU2VydmVyVVJMOiBzZXR0aW5ncy5paXBTZXJ2ZXJVUkwsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGlyOiBzZXR0aW5ncy5pbWFnZURpclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbG9hZE9wdGlvbnMgPSBoYXNoU3RhdGUgPyBnZXRMb2FkT3B0aW9uc0ZvclN0YXRlKGhhc2hTdGF0ZSwgbWFuaWZlc3QpIDoge307XG5cbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnNldE1hbmlmZXN0KG1hbmlmZXN0LCBpc0lJSUYsIGxvYWRPcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogUGFyc2UgdGhlIGhhc2ggcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgdXNlZCBieSBnZXRTdGF0ZSBhbmQgc2V0U3RhdGUgKi9cbiAgICAgICAgdmFyIGdldEhhc2hQYXJhbVN0YXRlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0ge307XG5cbiAgICAgICAgICAgIFsnZicsICd2JywgJ3onLCAnbicsICdpJywgJ3AnLCAneScsICd4J10uZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gSGFzaFBhcmFtcy5nZXQocGFyYW0gKyBzZXR0aW5ncy5oYXNoUGFyYW1TdWZmaXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gYGZhbHNlYCBpcyByZXR1cm5lZCBpZiB0aGUgdmFsdWUgaXMgbWlzc2luZ1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW3BhcmFtXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIERvIHNvbWUgYXdrd2FyZCBzcGVjaWFsLWNhc2luZywgc2luY2UgdGhpcyBmb3JtYXQgaXMga2luZCBvZiB3ZWlyZC5cblxuICAgICAgICAgICAgLy8gRm9yIGluRnVsbHNjcmVlbiAoZiksIHRydWUgYW5kIGZhbHNlIHN0cmluZ3Mgc2hvdWxkIGJlIGludGVycHJldGVkXG4gICAgICAgICAgICAvLyBhcyBib29sZWFucy5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mID09PSAndHJ1ZScpXG4gICAgICAgICAgICAgICAgc3RhdGUuZiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5mID09PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgIHN0YXRlLmYgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBudW1lcmljYWwgdmFsdWVzIHRvIGludGVnZXJzLCBpZiBwcm92aWRlZFxuICAgICAgICAgICAgWyd6JywgJ24nLCAncCcsICd4JywgJ3knXS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0gaW4gc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW3BhcmFtXSA9IHBhcnNlSW50KHN0YXRlW3BhcmFtXSwgMTApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2hlY2tMb2FkZWQgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdmlld2VyU3RhdGUubG9hZGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSB2aWV3ZXIgaXMgbm90IGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQuIFRoaXMgaXMgbGlrZWx5IGJlY2F1c2UgaXQgaXMgc3RpbGwgZG93bmxvYWRpbmcgZGF0YS4gVG8gZml4IHRoaXMsIG9ubHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGlmIHRoZSBpc1JlYWR5KCkgbWV0aG9kIHJldHVybnMgdHJ1ZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBmaWxsIHRoZSBoZWlnaHQsIHVzZSBhIHdyYXBwZXIgZGl2IGRpc3BsYXllZCB1c2luZyBhIGZsZXhib3ggbGF5b3V0XG4gICAgICAgICAgICB2YXIgd3JhcHBlckVsZW1lbnQgPSBlbHQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJkaXZhLXdyYXBwZXJcIiArIChvcHRpb25zLmZpbGxQYXJlbnRIZWlnaHQgPyBcIiBkaXZhLXdyYXBwZXItZmxleGJveFwiIDogXCJcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyRWxlbWVudCk7XG4gICAgICAgICAgICBvcHRpb25zLnRvb2xiYXJQYXJlbnRPYmplY3QgPSBvcHRpb25zLnRvb2xiYXJQYXJlbnRPYmplY3QgfHwgJCh3cmFwcGVyRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHZhciB2aWV3ZXJDb3JlID0gbmV3IFZpZXdlckNvcmUod3JhcHBlckVsZW1lbnQsIG9wdGlvbnMsIHNlbGYpO1xuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZSA9IHZpZXdlckNvcmUuZ2V0SW50ZXJuYWxTdGF0ZSgpO1xuICAgICAgICAgICAgc2V0dGluZ3MgPSB2aWV3ZXJDb3JlLmdldFNldHRpbmdzKCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgSUQgdG8gdGhlIHdyYXBwZXIgZWxlbWVudCBub3cgdGhhdCB0aGUgSUQgaGFzIGJlZW4gZ2VuZXJhdGVkIGJ5IHRoZSB2aWV3ZXIgY29yZVxuICAgICAgICAgICAgd3JhcHBlckVsZW1lbnQuaWQgPSBzZXR0aW5ncy5JRCArICd3cmFwcGVyJztcblxuICAgICAgICAgICAgZGl2YVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHZpZXdlckNvcmU6IHZpZXdlckNvcmUsXG4gICAgICAgICAgICAgICAgdG9vbGJhcjogc2V0dGluZ3MuZW5hYmxlVG9vbGJhciA/IGNyZWF0ZVRvb2xiYXIoc2VsZikgOiBudWxsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgaGFzaFN0YXRlID0gZ2V0SGFzaFBhcmFtU3RhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5vYmplY3REYXRhID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZlciBleGVjdXRpb24gdW50aWwgaW5pdGlhbGl6YXRpb24gaGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRPYmplY3REYXRhKHNldHRpbmdzLm9iamVjdERhdGEsIGhhc2hTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdNYW5pZmVzdFJlcXVlc3QgPSAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHNldHRpbmdzLm9iamVjdERhdGEsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYWpheEVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2VEYXRhKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkT2JqZWN0RGF0YShyZXNwb25zZURhdGEsIGhhc2hTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBwZW5kaW5nIHJlcXVlc3Qgc28gdGhhdCBpdCBjYW4gYmUgY2FuY2VsbGVkIGluIHRoZSBldmVudCB0aGF0IERpdmEgbmVlZHMgdG8gYmUgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgdmlld2VyQ29yZS5zZXRQZW5kaW5nTWFuaWZlc3RSZXF1ZXN0KHBlbmRpbmdNYW5pZmVzdFJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qIFBVQkxJQyBGVU5DVElPTlNcbiAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgKi9cblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSB0aXRsZSBvZiB0aGUgZG9jdW1lbnQsIGJhc2VkIG9uIHRoZSBkaXJlY3RvcnkgbmFtZVxuICAgICAgICB0aGlzLmdldEl0ZW1UaXRsZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5pdGVtVGl0bGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR28gdG8gYSBwYXJ0aWN1bGFyIHBhZ2UgYnkgaXRzIHBhZ2UgbnVtYmVyICh3aXRoIGluZGV4aW5nIHN0YXJ0aW5nIGF0IDEpXG4gICAgICAgICAgICAvL3hBbmNob3IgbWF5IGVpdGhlciBiZSBcImxlZnRcIiwgXCJyaWdodFwiLCBvciBkZWZhdWx0IFwiY2VudGVyXCI7IHRoZSAoeEFuY2hvcikgc2lkZSBvZiB0aGUgcGFnZSB3aWxsIGJlIGFuY2hvcmVkIHRvIHRoZSAoeEFuY2hvcikgc2lkZSBvZiB0aGUgZGl2YS1vdXRlciBlbGVtZW50XG4gICAgICAgICAgICAvL3lBbmNob3IgbWF5IGVpdGhlciBiZSBcInRvcFwiLCBcImJvdHRvbVwiLCBvciBkZWZhdWx0IFwiY2VudGVyXCI7IHNhbWUgcHJvY2VzcyBhcyB4QW5jaG9yLlxuICAgICAgICAvLyByZXR1cm5zIFRydWUgaWYgdGhlIHBhZ2UgbnVtYmVyIHBhc3NlZCBpcyB2YWxpZDsgZmFsc2UgaWYgaXQgaXMgbm90LlxuICAgICAgICB0aGlzLmdvdG9QYWdlQnlOdW1iZXIgPSBmdW5jdGlvbiAocGFnZU51bWJlciwgeEFuY2hvciwgeUFuY2hvcilcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgdXNpbmcgZ290b1BhZ2VCeUluZGV4KHBhZ2VJbmRleCwgeEFuY2hvciwgeUFuY2hvcikgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gcGFyc2VJbnQocGFnZU51bWJlciwgMTApIC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgsIHhBbmNob3IsIHlBbmNob3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdvIHRvIGEgcGFydGljdWxhciBwYWdlICh3aXRoIGluZGV4aW5nIHN0YXJ0aW5nIGF0IDApXG4gICAgICAgICAgICAvL3hBbmNob3IgbWF5IGVpdGhlciBiZSBcImxlZnRcIiwgXCJyaWdodFwiLCBvciBkZWZhdWx0IFwiY2VudGVyXCI7IHRoZSAoeEFuY2hvcikgc2lkZSBvZiB0aGUgcGFnZSB3aWxsIGJlIGFuY2hvcmVkIHRvIHRoZSAoeEFuY2hvcikgc2lkZSBvZiB0aGUgZGl2YS1vdXRlciBlbGVtZW50XG4gICAgICAgICAgICAvL3lBbmNob3IgbWF5IGVpdGhlciBiZSBcInRvcFwiLCBcImJvdHRvbVwiLCBvciBkZWZhdWx0IFwiY2VudGVyXCI7IHNhbWUgcHJvY2VzcyBhcyB4QW5jaG9yLlxuICAgICAgICAvLyByZXR1cm5zIFRydWUgaWYgdGhlIHBhZ2UgaW5kZXggaXMgdmFsaWQ7IGZhbHNlIGlmIGl0IGlzIG5vdC5cbiAgICAgICAgdGhpcy5nb3RvUGFnZUJ5SW5kZXggPSBmdW5jdGlvbiAocGFnZUluZGV4LCB4QW5jaG9yLCB5QW5jaG9yKVxuICAgICAgICB7XG4gICAgICAgICAgICBwYWdlSW5kZXggPSBwYXJzZUludChwYWdlSW5kZXgsIDEwKTtcbiAgICAgICAgICAgIGlmIChpc1BhZ2VWYWxpZChwYWdlSW5kZXgpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0WE9mZnNldChwYWdlSW5kZXgsIHhBbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciB5T2Zmc2V0ID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0WU9mZnNldChwYWdlSW5kZXgsIHlBbmNob3IpO1xuXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIuZ290byhwYWdlSW5kZXgsIHlPZmZzZXQsIHhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TnVtYmVyT2ZQYWdlcyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tMb2FkZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5udW1QYWdlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgcGFnZSBkaW1lbnNpb25zIGluIHRoZSBjdXJyZW50IHZpZXcgYW5kIHpvb20gbGV2ZWxcbiAgICAgICAgdGhpcy5nZXRQYWdlRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tMb2FkZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldEN1cnJlbnRMYXlvdXQoKS5nZXRQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgYSBnaXZlbiBwYWdlIGluZGV4IGF0IGEgZ2l2ZW4gem9vbSBsZXZlbFxuICAgICAgICB0aGlzLmdldFBhZ2VEaW1lbnNpb25zQXRab29tTGV2ZWwgPSBmdW5jdGlvbiAocGFnZUlkeCwgem9vbUxldmVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrTG9hZGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoem9vbUxldmVsID4gc2V0dGluZ3MubWF4Wm9vbUxldmVsKVxuICAgICAgICAgICAgICAgIHpvb21MZXZlbCA9IHNldHRpbmdzLm1heFpvb21MZXZlbDtcblxuICAgICAgICAgICAgdmFyIHBnID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXNbcGFyc2VJbnQocGFnZUlkeCwgMTApXTtcbiAgICAgICAgICAgIHZhciBwZ0F0Wm9vbSA9IHBnLmRbcGFyc2VJbnQoem9vbUxldmVsLCAxMCldO1xuICAgICAgICAgICAgcmV0dXJuIHsnd2lkdGgnOiBwZ0F0Wm9vbS53LCAnaGVpZ2h0JzogcGdBdFpvb20uaH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiBhIGdpdmVuIHBhZ2UgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICAvLyBUaGUgY3VycmVudCBwYWdlIGluZGV4IHdpbGwgYmUgdXNlZCBpZiBubyBwYWdlSW5kZXggaXMgc3BlY2lmaWVkXG4gICAgICAgIC8vIEFsc28gd29ya3MgaW4gR3JpZCB2aWV3XG4gICAgICAgIHRoaXMuZ2V0UGFnZURpbWVuc2lvbnNBdEN1cnJlbnRab29tTGV2ZWwgPSBmdW5jdGlvbihwYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VJbmRleCA9IGlzUGFnZVZhbGlkKHBhZ2VJbmRleCkgPyBwYWdlSW5kZXggOiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4O1xuXG4gICAgICAgICAgICBpZiAoIWlzUGFnZVZhbGlkKHBhZ2VJbmRleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBhZ2UgSW5kZXgnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldEN1cnJlbnRMYXlvdXQoKS5nZXRQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgcGFnZSBhdCB0aGUgY3VycmVudCB6b29tIGxldmVsXG4gICAgICAgIC8vIEFsc28gd29ya3MgaW4gR3JpZCB2aWV3XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFBhZ2VEaW1lbnNpb25zQXRDdXJyZW50Wm9vbUxldmVsID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZURpbWVuc2lvbnNBdEN1cnJlbnRab29tTGV2ZWwoc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLmxvYWRlZDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEN1cnJlbnRQYWdlSW5kZXggPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEN1cnJlbnRQYWdlRmlsZW5hbWUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFuaWZlc3QucGFnZXNbc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleF0uZjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEN1cnJlbnRQYWdlTnVtYmVyID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgdXNpbmcgZ2V0Q3VycmVudFBhZ2VJbmRleCgpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXggKyAxO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGZpbGVuYW1lcyBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgdGhpcy5nZXRGaWxlbmFtZXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWVzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3MubnVtUGFnZXM7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZXNbaV0gPSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlc1tpXS5mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlsZW5hbWVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICB0aGlzLmdldFpvb21MZXZlbCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0cyB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgZW50aXJlIGRvY3VtZW50XG4gICAgICAgIHRoaXMuZ2V0TWF4Wm9vbUxldmVsID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1heFpvb21MZXZlbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXRzIHRoZSBtYXggem9vbSBsZXZlbCBmb3IgYSBnaXZlbiBwYWdlXG4gICAgICAgIHRoaXMuZ2V0TWF4Wm9vbUxldmVsRm9yUGFnZSA9IGZ1bmN0aW9uIChwYWdlSWR4KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrTG9hZGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzW3BhZ2VJZHhdLm07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRNaW5ab29tTGV2ZWwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWluWm9vbUxldmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgem9vbSBsZXZlbCAod2lsbCBjaGVjayBmb3IgdmFsaWRpdHkgZmlyc3QpXG4gICAgICAgIC8vIFJldHVybnMgZmFsc2UgaWYgdGhlIHpvb20gbGV2ZWwgaXMgaW52YWxpZCwgdHJ1ZSBvdGhlcndpc2VcbiAgICAgICAgdGhpcy5zZXRab29tTGV2ZWwgPSBmdW5jdGlvbiAoem9vbUxldmVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgICAgIGluR3JpZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnpvb20oem9vbUxldmVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEdyaWRQYWdlc1BlclJvdyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8od2FiYWluKTogQWRkIHRlc3QgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFnZXNQZXJSb3c7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRHcmlkUGFnZXNQZXJSb3cgPSBmdW5jdGlvbiAobmV3VmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8od2FiYWluKTogQWRkIHRlc3QgY2FzZVxuICAgICAgICAgICAgaWYgKCFkaXZhU3RhdGUudmlld2VyQ29yZS5pc1ZhbGlkT3B0aW9uKCdwYWdlc1BlclJvdycsIG5ld1ZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgIGluR3JpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYWdlc1BlclJvdzogbmV3VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFpvb20gaW4uIFdpbGwgcmV0dXJuIGZhbHNlIGlmIGl0J3MgYXQgdGhlIG1heGltdW0gem9vbVxuICAgICAgICB0aGlzLnpvb21JbiA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFpvb21MZXZlbChzZXR0aW5ncy56b29tTGV2ZWwgKyAxKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBab29tIG91dC4gV2lsbCByZXR1cm4gZmFsc2UgaWYgaXQncyBhdCB0aGUgbWluaW11bSB6b29tXG4gICAgICAgIHRoaXMuem9vbU91dCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFpvb21MZXZlbChzZXR0aW5ncy56b29tTGV2ZWwgLSAxKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayBpZiBzb21ldGhpbmcgKGUuZy4gYSBoaWdobGlnaHQgYm94IG9uIGEgcGFydGljdWxhciBwYWdlKSBpcyB2aXNpYmxlXG4gICAgICAgIHRoaXMuaXNSZWdpb25JblZpZXdwb3J0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgbGVmdE9mZnNldCwgdG9wT2Zmc2V0LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuXG4gICAgICAgICAgICBpZiAoIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCArIHRvcE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgKyBsZWZ0T2Zmc2V0O1xuXG4gICAgICAgICAgICByZXR1cm4gdmlld2VyU3RhdGUudmlld3BvcnQuaW50ZXJzZWN0c1JlZ2lvbih7XG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogbGVmdCArIHdpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1B1YmxpYyB3cmFwcGVyIGZvciBpc1BhZ2VWaXNpYmxlXG4gICAgICAgIC8vRGV0ZXJtaW5lcyBpZiBhIHBhZ2UgaXMgY3VycmVudGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLmlzUGFnZUluVmlld3BvcnQgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdmlld2VyU3RhdGUucmVuZGVyZXIuaXNQYWdlVmlzaWJsZShwYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUHVibGljIHdyYXBwZXIgZm9yIGlzUGFnZUxvYWRlZFxuICAgICAgICAvL0RldGVybWluZXMgaWYgYSBwYWdlIGlzIGN1cnJlbnRseSBpbiB0aGUgRE9NXG4gICAgICAgIHRoaXMuaXNQYWdlTG9hZGVkID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgdXNpbmcgaXNQYWdlSW5WaWV3cG9ydChwYWdlSW5kZXgpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNQYWdlSW5WaWV3cG9ydChwYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgdGhpcy50b2dnbGVGdWxsc2NyZWVuTW9kZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvZ2dsZUZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTaG93L0hpZGUgbm9uLXBhZ2VkIHBhZ2VzXG4gICAgICAgIHRoaXMudG9nZ2xlTm9uUGFnZWRQYWdlc1Zpc2liaWxpdHkgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZWxvYWRWaWV3ZXIoeyBzaG93Tm9uUGFnZWRQYWdlczogIXNldHRpbmdzLnNob3dOb25QYWdlZFBhZ2VzIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNob3cgbm9uLXBhZ2VkIHBhZ2VzXG4gICAgICAgIHRoaXMuc2hvd05vblBhZ2VkUGFnZXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZWxvYWRWaWV3ZXIoeyBzaG93Tm9uUGFnZWRQYWdlczogdHJ1ZSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIaWRlIG5vbi1wYWdlZCBwYWdlc1xuICAgICAgICB0aGlzLmhpZGVOb25QYWdlZFBhZ2VzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVsb2FkVmlld2VyKHsgc2hvd05vblBhZ2VkUGFnZXM6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENsb3NlIHRvb2xiYXIgcG9wdXBzXG4gICAgICAgIHRoaXMuY2xvc2VQb3B1cHMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudG9vbGJhci5jbG9zZVBvcHVwcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEVudGVyIGZ1bGxzY3JlZW4gbW9kZSBpZiBjdXJyZW50bHkgbm90IGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIGluIGZ1bGxzY3JlZW4gbW9kZSBpbml0aWFsbHksIHRydWUgb3RoZXJ3aXNlXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCB3b3JrIGV2ZW4gaWYgZW5hYmxlRnVsbHNjcmVlbiBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgdGhpcy5lbnRlckZ1bGxzY3JlZW5Nb2RlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5pbkZ1bGxzY3JlZW4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTGVhdmUgZnVsbHNjcmVlbiBtb2RlIGlmIGN1cnJlbnRseSBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGluIGZ1bGxzY3JlZW4gbW9kZSBpbnRpdGlhbGx5LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgdGhpcy5sZWF2ZUZ1bGxzY3JlZW5Nb2RlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmluRnVsbHNjcmVlbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0b2dnbGVGdWxsc2NyZWVuKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGFuZ2Ugdmlld3MuIFRha2VzICdkb2N1bWVudCcsICdib29rJywgb3IgJ2dyaWQnIHRvIHNwZWNpZnkgd2hpY2ggdmlldyB0byBzd2l0Y2ggaW50b1xuICAgICAgICB0aGlzLmNoYW5nZVZpZXcgPSBmdW5jdGlvbihkZXN0aW5hdGlvblZpZXcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VWaWV3KGRlc3RpbmF0aW9uVmlldyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRW50ZXIgZ3JpZCB2aWV3IGlmIGN1cnJlbnRseSBub3QgaW4gZ3JpZCB2aWV3XG4gICAgICAgIC8vIFJldHVybnMgZmFsc2UgaWYgaW4gZ3JpZCB2aWV3IGluaXRpYWxseSwgdHJ1ZSBvdGhlcndpc2VcbiAgICAgICAgdGhpcy5lbnRlckdyaWRWaWV3ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5pbkdyaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVmlldygnZ3JpZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTGVhdmUgZ3JpZCB2aWV3IGlmIGN1cnJlbnRseSBpbiBncmlkIHZpZXdcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGluIGdyaWQgdmlldyBpbml0aWFsbHksIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICB0aGlzLmxlYXZlR3JpZFZpZXcgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7IGluR3JpZDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBKdW1wIHRvIGEgcGFnZSBiYXNlZCBvbiBpdHMgZmlsZW5hbWVcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHN1Y2Nlc3NmdWwgYW5kIGZhbHNlIGlmIHRoZSBmaWxlbmFtZSBpcyBpbnZhbGlkXG4gICAgICAgIHRoaXMuZ290b1BhZ2VCeU5hbWUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHhBbmNob3IsIHlBbmNob3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSBnZXRQYWdlSW5kZXgoZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ290b1BhZ2VCeUluZGV4KHBhZ2VJbmRleCwgeEFuY2hvciwgeUFuY2hvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nb3RvUGFnZUJ5TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHhBbmNob3IsIHlBbmNob3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlcyA9IHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwYWdlc1tpXS5sLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsYWJlbC50b0xvd2VyQ2FzZSgpKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nb3RvUGFnZUJ5SW5kZXgoaSwgeEFuY2hvciwgeUFuY2hvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGxhYmVsIHdhcyBmb3VuZCwgdHJ5IHRvIHBhcnNlIGEgcGFnZSBudW1iZXJcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSBwYXJzZUludChsYWJlbCwgMTApIC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgsIHhBbmNob3IsIHlBbmNob3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCB0aGUgcGFnZSBpbmRleCAoMC1iYXNlZCkgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGZpbGVuYW1lXG4gICAgICAgIC8vIElmIHRoZSBwYWdlIGluZGV4IGRvZXNuJ3QgZXhpc3QsIHRoaXMgd2lsbCByZXR1cm4gLTFcbiAgICAgICAgdGhpcy5nZXRQYWdlSW5kZXggPSBmdW5jdGlvbiAoZmlsZW5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQYWdlSW5kZXgoZmlsZW5hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBVUkwgKGV4cG9zZXMgdGhlIHByaXZhdGUgbWV0aG9kKVxuICAgICAgICB0aGlzLmdldEN1cnJlbnRVUkwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFVSTCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgcGFnZSBpbmRleCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICB0aGlzLmlzUGFnZUluZGV4VmFsaWQgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaXNQYWdlVmFsaWQocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIGhhc2ggcGFydCBvbmx5IG9mIHRoZSBjdXJyZW50IFVSTCAod2l0aG91dCB0aGUgbGVhZGluZyAjKVxuICAgICAgICB0aGlzLmdldFVSTEhhc2ggPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VVJMSGFzaCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGlzIGRpdmEgaW5zdGFuY2UgKGZvciBzZXRTdGF0ZSlcbiAgICAgICAgdGhpcy5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdGF0ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsaWduIHRoaXMgZGl2YSBpbnN0YW5jZSB3aXRoIGEgc3RhdGUgb2JqZWN0IChhcyByZXR1cm5lZCBieSBnZXRTdGF0ZSlcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVsb2FkVmlld2VyKGdldExvYWRPcHRpb25zRm9yU3RhdGUoc3RhdGUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIGluc3RhbmNlIHNlbGVjdG9yIGZvciB0aGlzIGluc3RhbmNlLCBzaW5jZSBpdCdzIGF1dG8tZ2VuZXJhdGVkLlxuICAgICAgICB0aGlzLmdldEluc3RhbmNlU2VsZWN0b3IgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc2VsZWN0b3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBpbnN0YW5jZSBJRCAtLSBlc3NlbnRpYWxseSB0aGUgc2VsZWN0b3Igd2l0aG91dCB0aGUgbGVhZGluZyAnIycuXG4gICAgICAgIHRoaXMuZ2V0SW5zdGFuY2VJZCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5JRDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBUcmFuc2xhdGVzIGEgbWVhc3VyZW1lbnQgZnJvbSB0aGUgem9vbSBsZXZlbCBvbiB0aGUgbGFyZ2VzdCBzaXplXG4gICAgICAgICAgICB0byBvbmUgb24gdGhlIGN1cnJlbnQgem9vbSBsZXZlbC5cblxuICAgICAgICAgICAgRm9yIGV4YW1wbGUsIGEgcG9pbnQgMTAwMCBvbiBhbiBpbWFnZSB0aGF0IGlzIG9uIHpvb20gbGV2ZWwgMiBvZiA1XG4gICAgICAgICAgICB0cmFuc2xhdGVzIHRvIGEgcG9zaXRpb24gb2YgMTExLjExMS4uLiAoMTAwMCAvICg1IC0gMileMikuXG5cbiAgICAgICAgICAgIFdvcmtzIGZvciBhIHNpbmdsZSBwaXhlbCBjby1vcmRpbmF0ZSBvciBhIGRpbWVuc2lvbiAoZS5nLiwgdHJhbnNsYXRlcyBhIGJveFxuICAgICAgICAgICAgdGhhdCBpcyAxMDAwIHBpeGVscyB3aWRlIG9uIHRoZSBvcmlnaW5hbCB0byBvbmUgdGhhdCBpcyAxMTEuMTExIHBpeGVscyB3aWRlXG4gICAgICAgICAgICBvbiB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc2xhdGVGcm9tTWF4Wm9vbUxldmVsID0gZnVuY3Rpb24gKHBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgem9vbURpZmZlcmVuY2UgPSBzZXR0aW5ncy5tYXhab29tTGV2ZWwgLSBzZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gLyBNYXRoLnBvdygyLCB6b29tRGlmZmVyZW5jZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFRyYW5zbGF0ZXMgYSBtZWFzdXJlbWVudCBmcm9tIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgdG8gdGhlIHBvc2l0aW9uIG9uIHRoZVxuICAgICAgICAgICAgbGFyZ2VzdCB6b29tIGxldmVsLlxuXG4gICAgICAgICAgICBXb3JrcyBmb3IgYSBzaW5nbGUgcGl4ZWwgY28tb3JkaW5hdGUgb3IgYSBkaW1lbnNpb24gKGUuZy4sIHRyYW5zbGF0ZXMgYSBib3hcbiAgICAgICAgICAgIHRoYXQgaXMgMTExLjExMSBwaXhlbHMgd2lkZSBvbiB0aGUgY3VycmVudCBpbWFnZSB0byBvbmUgdGhhdCBpcyAxMDAwIHBpeGVscyB3aWRlXG4gICAgICAgICAgICBvbiB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc2xhdGVUb01heFpvb21MZXZlbCA9IGZ1bmN0aW9uIChwb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHpvb21EaWZmZXJlbmNlID0gc2V0dGluZ3MubWF4Wm9vbUxldmVsIC0gc2V0dGluZ3Muem9vbUxldmVsO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBkaWZmZXJlbmNlLCBpdCdzIGEgYm94IG9uIHRoZSBtYXggem9vbSBsZXZlbCBhbmRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoem9vbURpZmZlcmVuY2UgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gKiBNYXRoLnBvdygyLCB6b29tRGlmZmVyZW5jZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmUtZW5hYmxlcyBkb2N1bWVudCBkcmFnZ2luZywgc2Nyb2xsaW5nIChieSBrZXlib2FyZCBpZiBzZXQpLCBhbmQgem9vbWluZyBieSBkb3VibGUtY2xpY2tpbmdcbiAgICAgICAgdGhpcy5lbmFibGVTY3JvbGxhYmxlID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5lbmFibGVTY3JvbGxhYmxlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGlzYWJsZXMgZG9jdW1lbnQgZHJhZ2dpbmcsIHNjcm9sbGluZyAoYnkga2V5Ym9hcmQgaWYgc2V0KSwgYW5kIHpvb21pbmcgYnkgZG91YmxlLWNsaWNraW5nXG4gICAgICAgIHRoaXMuZGlzYWJsZVNjcm9sbGFibGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5kaXNhYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vQ2hhbmdlcyBiZXR3ZWVuIGhvcml6b250YWwgbGF5b3V0IGFuZCB2ZXJ0aWNhbCBsYXlvdXQuIFJldHVybnMgdHJ1ZSBpZiBkb2N1bWVudCBpcyBub3cgdmVydGljYWxseSBvcmllbnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICB0aGlzLnRvZ2dsZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRvZ2dsZU9yaWVudGF0aW9uKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9SZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vcnRod2VzdCBjb3JuZXJzIG9mIGRpdmEtaW5uZXIgYW5kIHBhZ2UgaW5kZXhcbiAgICAgICAgdGhpcy5nZXRQYWdlT2Zmc2V0ID0gZnVuY3Rpb24ocGFnZUluZGV4LCBvcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0UGFnZVJlZ2lvbihwYWdlSW5kZXgsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogcmVnaW9uLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiByZWdpb24ubGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL3Nob3J0Y3V0IHRvIGdldFBhZ2VPZmZzZXQgZm9yIGN1cnJlbnQgcGFnZVxuICAgICAgICB0aGlzLmdldEN1cnJlbnRQYWdlT2Zmc2V0ID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUmV0dXJucyB0aGUgcGFnZSBkaW1lbnNpb25zIG9mIGdpdmVuIHBhZ2UgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICB0aGlzLmdldFBhZ2VEaW1lbnNpb25zQXRDdXJyZW50R3JpZExldmVsID0gZnVuY3Rpb24ocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciB1c2luZyBnZXRQYWdlRGltZW5zaW9uc0F0Q3VycmVudFpvb21MZXZlbChwYWdlSW5kZXgpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZURpbWVuc2lvbnNBdEN1cnJlbnRab29tTGV2ZWwocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgR2l2ZW4gYSBwYWdlWCBhbmQgcGFnZVkgdmFsdWUgKGFzIGNvdWxkIGJlIHJldHJlaXZlZCBmcm9tIGEgalF1ZXJ5IGV2ZW50IG9iamVjdCksXG4gICAgICAgICAgICAgICAgcmV0dXJucyBlaXRoZXIgdGhlIHBhZ2UgdmlzaWJsZSBhdCB0aGF0ICh4LHkpIHBvc2l0aW9uIG9yIC0xIGlmIG5vIHBhZ2UgaXMuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFnZUluZGV4Rm9yUGFnZVhZVmFsdWVzID0gZnVuY3Rpb24ocGFnZVgsIHBhZ2VZKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL2dldCB0aGUgZm91ciBlZGdlcyBvZiB0aGUgb3V0ZXIgZWxlbWVudFxuICAgICAgICAgICAgdmFyIG91dGVyT2Zmc2V0ID0gdmlld2VyU3RhdGUub3V0ZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIG91dGVyVG9wID0gb3V0ZXJPZmZzZXQudG9wO1xuICAgICAgICAgICAgdmFyIG91dGVyTGVmdCA9IG91dGVyT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICB2YXIgb3V0ZXJCb3R0b20gPSBvdXRlck9mZnNldC5ib3R0b207XG4gICAgICAgICAgICB2YXIgb3V0ZXJSaWdodCA9IG91dGVyT2Zmc2V0LnJpZ2h0O1xuXG4gICAgICAgICAgICAvL2lmIHRoZSBjbGlja2VkIHBvc2l0aW9uIHdhcyBvdXRzaWRlIHRoZSBkaXZhLW91dGVyIG9iamVjdCwgaXQgd2FzIG5vdCBvbiBhIHZpc2libGUgcG9ydGlvbiBvZiBhIHBhZ2VcbiAgICAgICAgICAgIGlmIChwYWdlWCA8IG91dGVyTGVmdCB8fCBwYWdlWCA+IG91dGVyUmlnaHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXG4gICAgICAgICAgICBpZiAocGFnZVkgPCBvdXRlclRvcCB8fCBwYWdlWSA+IG91dGVyQm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICAgICAgLy9uYXZpZ2F0ZSB0aHJvdWdoIGFsbCBkaXZhIHBhZ2Ugb2JqZWN0c1xuICAgICAgICAgICAgdmFyIHBhZ2VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGl2YS1wYWdlJyk7XG4gICAgICAgICAgICB2YXIgY3VyUGFnZUlkeCA9IHBhZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJQYWdlSWR4LS0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIG9mZnNldCBmb3IgZWFjaCBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGN1clBhZ2UgPSBwYWdlc1tjdXJQYWdlSWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyT2Zmc2V0ID0gY3VyUGFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBwb2ludCBpcyBvdXRzaWRlIHRoZSBob3Jpem9udGFsIGJvdW5kYXJpZXMgb2YgdGhlIHBhZ2UsIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VYIDwgY3VyT2Zmc2V0LmxlZnQgfHwgcGFnZVggPiBjdXJPZmZzZXQucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLy9zYW1lIHdpdGggdmVydGljYWwgYm91bmRhcmllc1xuICAgICAgICAgICAgICAgIGlmIChwYWdlWSA8IGN1ck9mZnNldC50b3AgfHwgcGFnZVkgPiBjdXJPZmZzZXQuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIC8vaWYgd2UgbWFkZSBpdCB0aHJvdWdoIHRoZSBhYm92ZSB0d28sIHdlIGZvdW5kIHRoZSBwYWdlIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1clBhZ2UuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgd2UgbWFkZSBpdCB0aHJvdWdoIHRoYXQgZW50aXJlIHdoaWxlIGxvb3AsIHdlIGRpZG4ndCBjbGljayBvbiBhIHBhZ2VcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIFVSTCBmb3IgdGhlIGltYWdlIG9mIHRoZSBwYWdlIGF0IHRoZSBnaXZlbiBpbmRleC4gVGhlXG4gICAgICAgICAqIG9wdGlvbmFsIHNpemUgcGFyYW1ldGVyIHN1cHBvcnRzIHNldHRpbmcgdGhlIGltYWdlIHdpZHRoIG9yIGhlaWdodFxuICAgICAgICAgKiAoZGVmYXVsdCBpcyBmdWxsLXNpemVkKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFnZUltYWdlVVJMID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgc2l6ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0LmdldFBhZ2VJbWFnZVVSTChwYWdlSW5kZXgsIHNpemUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUHJldHR5IHNlbGYtZXhwbGFuYXRvcnkuXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbGx5T3JpZW50ZWQgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VPYmplY3QgPSBmdW5jdGlvbihvYmplY3REYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5yZW5kZXJlcilcbiAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMub2JqZWN0RGF0YSA9IG9iamVjdERhdGE7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0RGF0YSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZE9iamVjdERhdGEob2JqZWN0RGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnRocm9iYmVyVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAndGhyb2JiZXInKS5zaG93KCk7XG4gICAgICAgICAgICB9LCBzZXR0aW5ncy50aHJvYmJlclRpbWVvdXQpO1xuXG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogc2V0dGluZ3Mub2JqZWN0RGF0YSxcbiAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBhamF4RXJyb3IsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRPYmplY3REYXRhKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlzQWN0aXZlRGl2YSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaXNBY3RpdmVEaXZhID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVzdHJveXMgdGhpcyBpbnN0YW5jZSwgdGVsbHMgcGx1Z2lucyB0byBkbyB0aGUgc2FtZSAoZm9yIHRlc3RpbmcpXG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBcIlNlY3JldGx5XCIgZXhwb3NlIHRoZSBwYWdlIG92ZXJsYXkgQVBJIGZvciB0aGUgaGlnaGxpZ2h0IHBsdWdpblxuICAgICAgICB0aGlzLl9fYWRkUGFnZU92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcmxheSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGl2YVN0YXRlLnZpZXdlckNvcmUuYWRkUGFnZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX3JlbW92ZVBhZ2VPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnJlbW92ZVBhZ2VPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGwgdGhlIGluaXQgZnVuY3Rpb24gd2hlbiB0aGlzIG9iamVjdCBpcyBjcmVhdGVkLlxuICAgICAgICBpbml0KCk7XG4gICAgfTtcblxuICAgICQuZm4uZGl2YSA9IGZ1bmN0aW9uIChvcHRpb25zKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZGl2YVBhcmVudCA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBlYXJseSBpZiB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBwbHVnaW4gaW5zdGFuY2VcbiAgICAgICAgICAgIGlmIChkaXZhUGFyZW50LmRhdGEoJ2RpdmEnKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBpbiB0aGUgRE9NLCBzaW5jZSBpdCBjYXVzZXMgc29tZSBwcm9ibGVtc1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jb250YWlucyh0aGlzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpdmEgY291bGQgbm90IGJlIGluaXRpYWxpemVkIGJlY2F1c2UgdGhpcyBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgRE9NJyk7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW5zdGFudGlhdGUgdGhlIGRvY3VtZW50IHZpZXdlclxuICAgICAgICAgICAgdmFyIGRpdmEgPSBuZXcgRGl2YSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRpdmFQYXJlbnQuZGF0YSgnZGl2YScsIGRpdmEpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkoalF1ZXJ5KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvZGl2YS5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZWx0O1xubW9kdWxlLmV4cG9ydHMuc2V0QXR0cmlidXRlcyA9IHNldERPTUF0dHJpYnV0ZXM7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gY3JlYXRlIGEgRE9NIGVsZW1lbnQsIHNldCBhdHRyaWJ1dGVzIG9uIGl0LCBhbmRcbiAqIGFwcGVuZCBjaGlsZHJlbi4gQWxsIGFyZ3VtZW50cyB3aGljaCBhcmUgbm90IG9mIHByaW1pdGl2ZSB0eXBlLCBhcmUgbm90XG4gKiBhcnJheXMsIGFuZCBhcmUgbm90IERPTSBub2RlcyBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGUgaGFzaGVzIGFuZCBhcmVcbiAqIGhhbmRsZWQgYXMgZGVzY3JpYmVkIGZvciBzZXRET01BdHRyaWJ1dGVzLiBDaGlsZHJlbiBjYW4gZWl0aGVyIGJlIGEgRE9NXG4gKiBub2RlIG9yIGEgcHJpbWl0aXZlIHZhbHVlLCB3aGljaCBpcyBjb252ZXJ0ZWQgdG8gYSB0ZXh0IG5vZGUuIEFycmF5cyBhcmVcbiAqIGhhbmRsZWQgcmVjdXJzaXZlbHkuIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQuXG4gKlxuICogSW5zcGlyZWQgYnkgdGhlIFByb3NlTWlycm9yIGhlbHBlciBvZiB0aGUgc2FtZSBuYW1lLlxuICovXG5mdW5jdGlvbiBlbHQodGFnKVxue1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB3aGlsZSAoYXJncy5sZW5ndGgpXG4gICAge1xuICAgICAgICB2YXIgYXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBoYW5kbGVFbHRDb25zdHJ1Y3RvckFyZyhlbCwgYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVsdENvbnN0cnVjdG9yQXJnKGVsLCBhcmcpXG57XG4gICAgaWYgKGFyZyA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZyAhPT0gJ2Z1bmN0aW9uJylcbiAgICB7XG4gICAgICAgIC8vIENvZXJjZSB0byBzdHJpbmdcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXJnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlKVxuICAgIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpXG4gICAge1xuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGFyZy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaGFuZGxlRWx0Q29uc3RydWN0b3JBcmcoZWwsIGFyZ1tpXSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHNldERPTUF0dHJpYnV0ZXMoZWwsIGFyZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGVzIG9mIGEgRE9NIGVsZW1lbnQuIFRoZSBgc3R5bGVgIHByb3BlcnR5IGlzIHNwZWNpYWwtY2FzZWQgdG9cbiAqIGFjY2VwdCBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdob3NlIG93biBhdHRyaWJ1dGVzIGFyZSBhc3NpZ25lZCB0b1xuICogZWwuc3R5bGUuXG4gKi9cbmZ1bmN0aW9uIHNldERPTUF0dHJpYnV0ZXMoZWwsIGF0dHJpYnV0ZXMpXG57XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdHRyaWJ1dGVzKVxuICAgIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKHByb3AgPT09ICdzdHlsZScpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldFN0eWxlKGVsLCBhdHRyaWJ1dGVzLnN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoZWwsIHN0eWxlKVxue1xuICAgIGlmICghc3R5bGUpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmICh0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKVxuICAgIHtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgY3NzUHJvcCBpbiBzdHlsZSlcbiAgICB7XG4gICAgICAgIGlmICghc3R5bGUuaGFzT3duUHJvcGVydHkoY3NzUHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBlbC5zdHlsZVtjc3NQcm9wXSA9IHN0eWxlW2Nzc1Byb3BdO1xuICAgIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvdXRpbHMvZWx0LmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMuZ2V0ID0gZ2V0SGFzaFBhcmFtO1xubW9kdWxlLmV4cG9ydHMudXBkYXRlID0gdXBkYXRlSGFzaFBhcmFtO1xuXG4vLyBGb3IgZ2V0dGluZyB0aGUgI2tleSB2YWx1ZXMgZnJvbSB0aGUgVVJMLiBGb3Igc3BlY2lmeWluZyBhIHBhZ2UgYW5kIHpvb20gbGV2ZWxcbi8vIExvb2sgaW50byBjYWNoaW5nLCBiZWNhdXNlIHdlIG9ubHkgbmVlZCB0byBnZXQgdGhpcyBkdXJpbmcgdGhlIGluaXRpYWwgbG9hZFxuLy8gQWx0aG91Z2ggZm9yIHRoZSB0ZXN0cyBJIGd1ZXNzIHdlIHdvdWxkIG5lZWQgdG8gb3ZlcnJpZGUgY2FjaGluZyBzb21laG93XG5mdW5jdGlvbiBnZXRIYXNoUGFyYW0oa2V5KSB7XG4gICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICBpZiAoaGFzaCAhPT0gJycpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgc29tZXRoaW5nIHRoYXQgbG9va3MgbGlrZSBlaXRoZXIgJmtleT0gb3IgI2tleT1cbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAoaGFzaC5pbmRleE9mKCcmJyArIGtleSArICc9JykgPiAwKSA/IGhhc2guaW5kZXhPZignJicgKyBrZXkgKyAnPScpIDogaGFzaC5pbmRleE9mKCcjJyArIGtleSArICc9Jyk7XG5cbiAgICAgICAgLy8gSWYgc3RhcnRJbmRleCBpcyBzdGlsbCAtMSwgaXQgbWVhbnMgaXQgY2FuJ3QgZmluZCBlaXRoZXJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBsZW5ndGggb2YgdGhlIGtleSBwbHVzIHRoZSAmIGFuZCA9XG4gICAgICAgICAgICBzdGFydEluZGV4ICs9IGtleS5sZW5ndGggKyAyO1xuXG4gICAgICAgICAgICAvLyBFaXRoZXIgdG8gdGhlIG5leHQgYW1wZXJzYW5kIG9yIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gaGFzaC5pbmRleE9mKCcmJywgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggPiBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChoYXNoLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoaXMgaGFzaCBwYXJhbSBpcyB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2guc3Vic3RyaW5nKHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBrZXkgZG9lc24ndCBoYXZlIGEgdmFsdWUgSSB0aGlua1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgaXQgY2FuJ3QgZmluZCB0aGUga2V5XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaGFzaCBwYXJhbXMganVzdCByZXR1cm4gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSGFzaFBhcmFtKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGaXJzdCBtYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIHRvIGRvIGFueSB3b3JrIGF0IGFsbFxuICAgIHZhciBvcmlnaW5hbFZhbHVlID0gZ2V0SGFzaFBhcmFtKGtleSk7XG4gICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICBpZiAob3JpZ2luYWxWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgLy8gSXMgdGhlIGtleSBhbHJlYWR5IGluIHRoZSBVUkw/XG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxWYWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBpbiB0aGUgVVJMLiBKdXN0IGdldCByaWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IChoYXNoLmluZGV4T2YoJyYnICsga2V5ICsgJz0nKSA+IDApID8gaGFzaC5pbmRleE9mKCcmJyArIGtleSArICc9JykgOiBoYXNoLmluZGV4T2YoJyMnICsga2V5ICsgJz0nKTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBrZXkubGVuZ3RoICsgMiArIG9yaWdpbmFsVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgLy8gIyBpZiBpdCdzIHRoZSBmaXJzdCwgJiBvdGhlcndpc2VcbiAgICAgICAgICAgIHZhciBzdGFydFRoaW5nID0gKHN0YXJ0SW5kZXggPT09IDApID8gJyMnIDogJyYnO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaGFzaC5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCkgKyBzdGFydFRoaW5nICsga2V5ICsgJz0nICsgdmFsdWUgKyBoYXNoLnN1YnN0cmluZyhlbmRJbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXQncyBub3QgcHJlc2VudCAtIGFkZCBpdFxuICAgICAgICAgICAgaWYgKGhhc2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoJyMnICsga2V5ICsgJz0nICsgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgaXRcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShoYXNoICsgJyYnICsga2V5ICsgJz0nICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy91dGlscy9oYXNoLXBhcmFtcy5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLy9Vc2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBEaXZhIHdhcyBsYXN0IGNsaWNrZWQgb3Igd2hpY2ggRGl2YSB3YXMgbGFzdCBjbGlja2VkIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlXG52YXIgQWN0aXZlRGl2YUNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCQpXG57XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgYWN0aXZlO1xuXG4gICAgICAgIC8vZ2xvYmFsIGNsaWNrIGxpc3RlbmVyXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVwZGF0ZUFjdGl2ZSgkKGUudGFyZ2V0KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vcGFyYW1ldGVyIHNob3VsZCBhbHJlYWR5IGJlIGEgalF1ZXJ5IHNlbGVjdG9yXG4gICAgICAgIHZhciB1cGRhdGVBY3RpdmUgPSBmdW5jdGlvbiAodGFyZ2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbmVhcmVzdE91dGVyO1xuXG4gICAgICAgICAgICAvL3RoZXNlIHdpbGwgZmluZCAwIG9yIDEgb2JqZWN0cywgbmV2ZXIgbW9yZVxuICAgICAgICAgICAgdmFyIGZpbmRPdXRlciA9IHRhcmdldC5maW5kKCcuZGl2YS1vdXRlcicpO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3RPdXRlciA9IHRhcmdldC5jbG9zZXN0KCcuZGl2YS1vdXRlcicpO1xuICAgICAgICAgICAgdmFyIG91dGVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2RpdmEtb3V0ZXInKTtcbiAgICAgICAgICAgIHZhciBvdXRlckxlbiA9IG91dGVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaWR4O1xuXG4gICAgICAgICAgICAvL2NsaWNrZWQgb24gc29tZXRoaW5nIHRoYXQgd2FzIG5vdCBlaXRoZXIgYSBwYXJlbnQgb3Igc2libGluZyBvZiBhIGRpdmEtb3V0ZXJcbiAgICAgICAgICAgIGlmIChmaW5kT3V0ZXIubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZWFyZXN0T3V0ZXIgPSBmaW5kT3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NsaWNrZWQgb24gc29tZXRoaW5nIHRoYXQgd2FzIGEgY2hpbGQgb2YgYSBkaXZhLW91dGVyXG4gICAgICAgICAgICBlbHNlIGlmIChjbG9zZXN0T3V0ZXIubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZWFyZXN0T3V0ZXIgPSBjbG9zZXN0T3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NsaWNrZWQgb24gc29tZXRoaW5nIHRoYXQgd2FzIG5vdCBpbiBhbnkgRGl2YSB0cmVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9kZWFjdGl2YXRlIGV2ZXJ5dGhpbmcgYW5kIHJldHVyblxuICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgb3V0ZXJMZW47IGlkeCsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJChvdXRlcnNbaWR4XS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpLmRhdGEoJ2RpdmEnKS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pZiB3ZSBmb3VuZCBvbmUsIGFjdGl2YXRlIGl0Li4uXG4gICAgICAgICAgICBuZWFyZXN0T3V0ZXIucGFyZW50KCkucGFyZW50KCkuZGF0YSgnZGl2YScpLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICBhY3RpdmUgPSBuZWFyZXN0T3V0ZXIucGFyZW50KCk7XG5cbiAgICAgICAgICAgIC8vLi4uYW5kIGRlYWN0aXZhdGUgYWxsIHRoZSBvdGhlcnNcbiAgICAgICAgICAgIG91dGVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2RpdmEtb3V0ZXInKTtcbiAgICAgICAgICAgIGZvcihpZHggPSAwOyBpZHggPCBvdXRlckxlbjsgaWR4KyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9nZXRBdHRyaWJ1dGUgdG8gYXR0ciAtIGNvbXBhcmluZyBET00gZWxlbWVudCB0byBqUXVlcnkgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChvdXRlcnNbaWR4XS5nZXRBdHRyaWJ1dGUoJ2lkJykgIT0gbmVhcmVzdE91dGVyLmF0dHIoJ2lkJykpXG4gICAgICAgICAgICAgICAgICAgICQob3V0ZXJzW2lkeF0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KS5kYXRhKCdkaXZhJykuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vcHVibGljIGFjY2Vzc29yIGluIGNhc2UuIFdpbGwgcmV0dXJuIGEgalF1ZXJ5IHNlbGVjdG9yLlxuICAgICAgICB0aGlzLmdldEFjdGl2ZSA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZTtcbiAgICAgICAgfTtcbiAgICB9O1xufSkoalF1ZXJ5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBY3RpdmVEaXZhQ29udHJvbGxlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvYWN0aXZlLWRpdmEtY29udHJvbGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBqc2hpbnQgdW51c2VkOiB0cnVlICovXG5cbnZhciBwYXJzZUlJSUZNYW5pZmVzdCA9IHJlcXVpcmUoJy4vcGFyc2UtaWlpZi1tYW5pZmVzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlTWFuaWZlc3Q7XG5cbmZ1bmN0aW9uIEltYWdlTWFuaWZlc3QoZGF0YSwgdXJsQWRhcHRlcilcbntcbiAgICAvLyBTYXZlIGFsbCB0aGUgZGF0YSB3ZSBuZWVkXG4gICAgdGhpcy5wYWdlcyA9IGRhdGEucGdzO1xuICAgIHRoaXMubWF4Wm9vbSA9IGRhdGEubWF4X3pvb207XG4gICAgdGhpcy5tYXhSYXRpbyA9IGRhdGEuZGltcy5tYXhfcmF0aW87XG4gICAgdGhpcy5taW5SYXRpbyA9IGRhdGEuZGltcy5taW5fcmF0aW87XG4gICAgdGhpcy5pdGVtVGl0bGUgPSBkYXRhLml0ZW1fdGl0bGU7XG5cbiAgICAvLyBPbmx5IGdpdmVuIGZvciBJSUlGIG1hbmlmZXN0c1xuICAgIHRoaXMucGFnZWQgPSAhIWRhdGEucGFnZWQ7XG5cbiAgICAvLyBUaGVzZSBhcmUgYXJyYXlzLCB0aGUgaW5kZXggY29ycmVzcG9uZGluZyB0byB0aGUgem9vbSBsZXZlbFxuICAgIHRoaXMuX21heFdpZHRocyA9IGRhdGEuZGltcy5tYXhfdztcbiAgICB0aGlzLl9tYXhIZWlnaHRzID0gZGF0YS5kaW1zLm1heF9oO1xuICAgIHRoaXMuX2F2ZXJhZ2VXaWR0aHMgPSBkYXRhLmRpbXMuYV93aWQ7XG4gICAgdGhpcy5fYXZlcmFnZUhlaWdodHMgPSBkYXRhLmRpbXMuYV9oZWk7XG4gICAgdGhpcy5fdG90YWxIZWlnaHRzID0gZGF0YS5kaW1zLnRfaGVpO1xuICAgIHRoaXMuX3RvdGFsV2lkdGhzID0gZGF0YS5kaW1zLnRfd2lkO1xuXG4gICAgdGhpcy5fdXJsQWRhcHRlciA9IHVybEFkYXB0ZXI7XG59XG5cbkltYWdlTWFuaWZlc3QuZnJvbUlJSUYgPSBmdW5jdGlvbiAoaWlpZk1hbmlmZXN0KVxue1xuICAgIHZhciBkYXRhID0gcGFyc2VJSUlGTWFuaWZlc3QoaWlpZk1hbmlmZXN0KTtcbiAgICByZXR1cm4gbmV3IEltYWdlTWFuaWZlc3QoZGF0YSwgbmV3IElJSUZTb3VyY2VBZGFwdGVyKCkpO1xufTtcblxuSW1hZ2VNYW5pZmVzdC5mcm9tTGVnYWN5TWFuaWZlc3QgPSBmdW5jdGlvbiAoZGF0YSwgY29uZmlnKVxue1xuICAgIC8vIEZvciBJSVAgbWFuaWZlc3RzLCB1c2UgdGhlIHBhZ2UgbnVtYmVyIChpbmRleGVkIHN0YXJ0aW5nIGZyb20gMSkgYXMgYSBsYWJlbCBmb3IgZWFjaCBwYWdlXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEucGdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBkYXRhLnBnc1tpXS5sID0gKGkgKyAxKS50b1N0cmluZygpO1xuXG4gICAgcmV0dXJuIG5ldyBJbWFnZU1hbmlmZXN0KGRhdGEsIG5ldyBMZWdhY3lNYW5pZmVzdFNvdXJjZUFkYXB0ZXIoY29uZmlnKSk7XG59O1xuXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5pc1BhZ2VWYWxpZCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHNob3dOb25QYWdlZFBhZ2VzKVxue1xuICAgIGlmICghc2hvd05vblBhZ2VkUGFnZXMgJiYgdGhpcy5wYWdlZCAmJiAhdGhpcy5wYWdlc1twYWdlSW5kZXhdLnBhZ2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcGFnZUluZGV4ID49IDAgJiYgcGFnZUluZGV4IDwgdGhpcy5wYWdlcy5sZW5ndGg7XG59O1xuXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRNYXhQYWdlRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG57XG4gICAgdmFyIG1heERpbXMgPSB0aGlzLnBhZ2VzW3BhZ2VJbmRleF0uZFt0aGlzLm1heFpvb21dO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBtYXhEaW1zLmgsXG4gICAgICAgIHdpZHRoOiBtYXhEaW1zLndcbiAgICB9O1xufTtcblxuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0UGFnZURpbWVuc2lvbnNBdFpvb21MZXZlbCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHpvb21MZXZlbClcbntcbiAgICB2YXIgbWF4RGltcyA9IHRoaXMucGFnZXNbcGFnZUluZGV4XS5kW3RoaXMubWF4Wm9vbV07XG5cbiAgICB2YXIgc2NhbGVSYXRpbyA9IGdldFNjYWxlUmF0aW8odGhpcy5tYXhab29tLCB6b29tTGV2ZWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBtYXhEaW1zLmggKiBzY2FsZVJhdGlvLFxuICAgICAgICB3aWR0aDogbWF4RGltcy53ICogc2NhbGVSYXRpb1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBVUkwgZm9yIHRoZSBpbWFnZSBvZiB0aGUgZ2l2ZW4gcGFnZS4gVGhlIG9wdGlvbmFsIHNpemVcbiAqIHBhcmFtZXRlciBzdXBwb3J0cyBzZXR0aW5nIHRoZSBpbWFnZSB3aWR0aCBvciBoZWlnaHQgKGRlZmF1bHQgaXNcbiAqIGZ1bGwtc2l6ZWQpLlxuICovXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRQYWdlSW1hZ2VVUkwgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBzaXplKVxue1xuICAgIHJldHVybiB0aGlzLl91cmxBZGFwdGVyLmdldFBhZ2VJbWFnZVVSTCh0aGlzLCBwYWdlSW5kZXgsIHNpemUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgb2YgdGlsZSBvYmplY3RzIGZvciB0aGUgc3BlY2lmaWVkIHBhZ2UgYW5kIGludGVnZXIgem9vbSBsZXZlbFxuICovXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRQYWdlSW1hZ2VUaWxlcyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHpvb21MZXZlbCwgdGlsZURpbWVuc2lvbnMpXG57XG4gICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW3BhZ2VJbmRleF07XG5cbiAgICBpZiAoIWlzRmluaXRlKHpvb21MZXZlbCkgfHwgem9vbUxldmVsICUgMSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWm9vbSBsZXZlbCBtdXN0IGJlIGFuIGludGVnZXI6ICcgKyB6b29tTGV2ZWwpO1xuXG4gICAgdmFyIHJvd3MgPSBNYXRoLmNlaWwocGFnZS5kW3pvb21MZXZlbF0uaCAvIHRpbGVEaW1lbnNpb25zLmhlaWdodCk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLmNlaWwocGFnZS5kW3pvb21MZXZlbF0udyAvIHRpbGVEaW1lbnNpb25zLndpZHRoKTtcblxuICAgIHZhciB0aWxlcyA9IFtdO1xuXG4gICAgdmFyIHJvdywgY29sLCB1cmw7XG5cbiAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKVxuICAgIHtcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBjb2xzOyBjb2wrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsID0gdGhpcy5fdXJsQWRhcHRlci5nZXRUaWxlSW1hZ2VVUkwodGhpcywgcGFnZUluZGV4LCB7XG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvd3MsXG4gICAgICAgICAgICAgICAgY29sQ291bnQ6IGNvbHMsXG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiB6b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgdGlsZURpbWVuc2lvbnM6IHRpbGVEaW1lbnNpb25zXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRklYTUU6IERpbWVuc2lvbnMgc2hvdWxkIGFjY291bnQgZm9yIHBhcnRpYWwgdGlsZXMgKGUuZy4gdGhlXG4gICAgICAgICAgICAvLyBsYXN0IHJvdyBhbmQgY29sdW1uIGluIGEgdGlsZWQgaW1hZ2UpXG4gICAgICAgICAgICB0aWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWw6IHpvb21MZXZlbCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGlsZURpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGlsZURpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHJvdyAqIHRpbGVEaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sICogdGlsZURpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHpvb21MZXZlbDogem9vbUxldmVsLFxuICAgICAgICByb3dzOiByb3dzLFxuICAgICAgICBjb2xzOiBjb2xzLFxuICAgICAgICB0aWxlczogdGlsZXNcbiAgICB9O1xufTtcblxuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0TWF4V2lkdGggPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX21heFdpZHRocycpO1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0TWF4SGVpZ2h0ID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ19tYXhIZWlnaHRzJyk7XG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRBdmVyYWdlV2lkdGggPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX2F2ZXJhZ2VXaWR0aHMnKTtcbkltYWdlTWFuaWZlc3QucHJvdG90eXBlLmdldEF2ZXJhZ2VIZWlnaHQgPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX2F2ZXJhZ2VIZWlnaHRzJyk7XG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRUb3RhbFdpZHRoID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ190b3RhbFdpZHRocycpO1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0VG90YWxIZWlnaHQgPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX3RvdGFsSGVpZ2h0cycpO1xuXG5mdW5jdGlvbiB6b29tZWRQcm9wZXJ0eUdldHRlcihwcml2YXRlTmFtZSlcbntcbiAgICByZXR1cm4gZnVuY3Rpb24gKHpvb21MZXZlbClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVOYW1lXVt6b29tTGV2ZWxdO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlUmF0aW8oc291cmNlWm9vbUxldmVsLCB0YXJnZXRab29tTGV2ZWwpXG57XG4gICAgcmV0dXJuIDEgLyBNYXRoLnBvdygyLCBzb3VyY2Vab29tTGV2ZWwgLSB0YXJnZXRab29tTGV2ZWwpO1xufVxuXG5mdW5jdGlvbiBJSUlGU291cmNlQWRhcHRlcigpXG57XG4gICAgLy8gTm8tb3Bcbn1cblxuSUlJRlNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFBhZ2VJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBzaXplKVxue1xuICAgIHZhciBkaW1lbnM7XG5cbiAgICBpZiAoIXNpemUgfHwgKHNpemUud2lkdGggPT0gbnVsbCAmJiBzaXplLmhlaWdodCA9PSBudWxsKSlcbiAgICAgICAgZGltZW5zID0gJ2Z1bGwnO1xuICAgIGVsc2VcbiAgICAgICAgZGltZW5zID0gKHNpemUud2lkdGggPT0gbnVsbCA/ICcnIDogc2l6ZS53aWR0aCkgKyAnLCcgKyAoc2l6ZS5oZWlnaHQgPT0gbnVsbCA/ICcnIDogc2l6ZS5oZWlnaHQpO1xuXG4gICAgdmFyIHBhZ2UgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdO1xuICAgIHZhciBxdWFsaXR5ID0gKHBhZ2UuYXBpID4gMS4xKSA/ICdkZWZhdWx0JyA6ICduYXRpdmUnO1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSShwYWdlLnVybCArICdmdWxsLycgKyBkaW1lbnMgKyAnLzAvJyArIHF1YWxpdHkgKyAnLmpwZycpO1xufTtcblxuSUlJRlNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFRpbGVJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBwYXJhbXMpXG57XG4gICAgdmFyIHBhZ2UgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdO1xuXG4gICAgdmFyIGhlaWdodCwgd2lkdGg7XG5cbiAgICBpZiAocGFyYW1zLnJvdyA9PT0gcGFyYW1zLnJvd0NvdW50IC0gMSlcbiAgICAgICAgaGVpZ2h0ID0gcGFnZS5kW3BhcmFtcy56b29tTGV2ZWxdLmggLSAocGFyYW1zLnJvd0NvdW50IC0gMSkgKiBwYXJhbXMudGlsZURpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIGVsc2VcbiAgICAgICAgaGVpZ2h0ID0gcGFyYW1zLnRpbGVEaW1lbnNpb25zLmhlaWdodDtcblxuICAgIGlmIChwYXJhbXMuY29sID09PSBwYXJhbXMuY29sQ291bnQgLSAxKVxuICAgICAgICB3aWR0aCA9IHBhZ2UuZFtwYXJhbXMuem9vbUxldmVsXS53IC0gKHBhcmFtcy5jb2xDb3VudCAtIDEpICogcGFyYW1zLnRpbGVEaW1lbnNpb25zLndpZHRoO1xuICAgIGVsc2VcbiAgICAgICAgd2lkdGggPSBwYXJhbXMudGlsZURpbWVuc2lvbnMud2lkdGg7XG5cbiAgICB2YXIgem9vbURpZmZlcmVuY2UgPSBNYXRoLnBvdygyLCBtYW5pZmVzdC5tYXhab29tIC0gcGFyYW1zLnpvb21MZXZlbCk7XG5cbiAgICB2YXIgeCA9IHBhcmFtcy5jb2wgKiBwYXJhbXMudGlsZURpbWVuc2lvbnMud2lkdGggKiB6b29tRGlmZmVyZW5jZTtcbiAgICB2YXIgeSA9IHBhcmFtcy5yb3cgKiBwYXJhbXMudGlsZURpbWVuc2lvbnMuaGVpZ2h0ICogem9vbURpZmZlcmVuY2U7XG5cbiAgICBpZiAocGFnZS5oYXNPd25Qcm9wZXJ0eSgneG9mZnNldCcpKVxuICAgIHtcbiAgICAgICAgeCArPSBwYWdlLnhvZmZzZXQ7XG4gICAgICAgIHkgKz0gcGFnZS55b2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciByZWdpb24gPSBbeCwgeSwgd2lkdGggKiB6b29tRGlmZmVyZW5jZSwgaGVpZ2h0ICogem9vbURpZmZlcmVuY2VdLmpvaW4oJywnKTtcblxuICAgIHZhciBxdWFsaXR5ID0gKHBhZ2UuYXBpID4gMS4xKSA/ICdkZWZhdWx0JyA6ICduYXRpdmUnO1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSShwYWdlLnVybCArIHJlZ2lvbiArICcvJyArIHdpZHRoICsgJywnICsgaGVpZ2h0ICsgJy8wLycgKyBxdWFsaXR5ICsgJy5qcGcnKTtcbn07XG5cbmZ1bmN0aW9uIExlZ2FjeU1hbmlmZXN0U291cmNlQWRhcHRlcihjb25maWcpXG57XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xufVxuXG5MZWdhY3lNYW5pZmVzdFNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFBhZ2VJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBzaXplKVxue1xuICAgIC8vIFdpdGhvdXQgd2lkdGggb3IgaGVpZ2h0IHNwZWNpZmllZCwgSUlQSW1hZ2UgZGVmYXVsdHMgdG8gZnVsbC1zaXplXG4gICAgdmFyIGRpbWVucyA9ICcnO1xuXG4gICAgaWYgKHNpemUpXG4gICAge1xuICAgICAgICBpZiAoc2l6ZS53aWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgZGltZW5zICs9ICcmV0lEPScgKyBzaXplLndpZHRoO1xuXG4gICAgICAgIGlmIChzaXplLmhlaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgZGltZW5zICs9ICcmSEVJPScgKyBzaXplLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgZmlsZW5hbWUgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdLmY7XG5cbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmlpcFNlcnZlclVSTCArIFwiP0ZJRj1cIiArIHRoaXMuX2NvbmZpZy5pbWFnZURpciArICcvJyArIGZpbGVuYW1lICsgZGltZW5zICsgJyZDVlQ9SlBFRyc7XG59O1xuXG5MZWdhY3lNYW5pZmVzdFNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFRpbGVJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBwYXJhbXMpXG57XG4gICAgdmFyIHBhZ2UgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdO1xuICAgIHZhciByZXF1ZXN0ZWRab29tTGV2ZWwgPSBwYXJhbXMuem9vbUxldmVsICsgcGFnZS5tIC0gbWFuaWZlc3QubWF4Wm9vbTtcbiAgICB2YXIgaW5kZXggPSAocGFyYW1zLnJvdyAqIHBhcmFtcy5jb2xDb3VudCkgKyBwYXJhbXMuY29sO1xuICAgIHZhciBqdGwgPSByZXF1ZXN0ZWRab29tTGV2ZWwgKyAnLCcgKyBpbmRleDtcblxuICAgIHJldHVybiBlbmNvZGVVUkkodGhpcy5fY29uZmlnLmlpcFNlcnZlclVSTCArIFwiP0ZJRj1cIiArIHRoaXMuX2NvbmZpZy5pbWFnZURpciArICcvJyArIHBhZ2UuZiArICcmSlRMPScgKyBqdGwgKyAnJkNWVD1KUEVHJyk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9pbWFnZS1tYW5pZmVzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBqc2hpbnQgdW51c2VkOiB0cnVlICovXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VJSUlGTWFuaWZlc3Q7XG5cbi8qKlxuICogUGFyc2VzIGEgSUlJRiBQcmVzZW50YXRpb24gQVBJIE1hbmlmZXN0IGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgRGl2YS5qcy1mb3JtYXQgb2JqZWN0XG4gKiAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ERE1BTC9kaXZhLmpzL3dpa2kvRGV2ZWxvcG1lbnQtbm90ZXMjZGF0YS1yZWNlaXZlZC10aHJvdWdoLWFqYXgtcmVxdWVzdClcbiAqIChUaGlzIGlzIGEgY2xpZW50LXNpZGUgcmUtaW1wbGVtZW50YXRpb24gb2YgZ2VuZXJhdGVfanNvbi5weSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuaWZlc3QgLSBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgdmFsaWQgSUlJRiBtYW5pZmVzdFxuICogQHJldHVybnMge09iamVjdH0gZGl2YVNlcnZpY2VCbG9jayAtIHRoZSBkYXRhIG5lZWRlZCBieSBEaXZhIHRvIHNob3cgYSB2aWV3IG9mIGEgc2luZ2xlIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSUlJRk1hbmlmZXN0KG1hbmlmZXN0KVxue1xuXG4gICAgdmFyIGluY29ycG9yYXRlWm9vbSA9IGZ1bmN0aW9uIChpbWFnZURpbWVuc2lvbiwgem9vbURpZmZlcmVuY2UpXG4gICAge1xuICAgICAgICByZXR1cm4gaW1hZ2VEaW1lbnNpb24gLyAoTWF0aC5wb3coMiwgem9vbURpZmZlcmVuY2UpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE1heFpvb21MZXZlbCA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgdmFyIGxhcmdlc3REaW1lbnNpb24gPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZygobGFyZ2VzdERpbWVuc2lvbiArIDEpIC8gKDI1NiArIDEpKSAvIE1hdGgubG9nKDIpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFycmF5V2l0aFZhbHVlID0gZnVuY3Rpb24gKGxlbmd0aCwgdmFsdWUpXG4gICAge1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgdmFyIGkgPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuXG4gICAgdmFyIHNlcXVlbmNlID0gbWFuaWZlc3Quc2VxdWVuY2VzWzBdO1xuXG4gICAgLy9AVE9ETyBjaG9vc2UgYSBzZXF1ZW5jZSBpbnRlbGxpZ2VudGx5XG4gICAgdmFyIGNhbnZhc2VzID0gc2VxdWVuY2UuY2FudmFzZXM7XG5cbiAgICB2YXIgem9vbUxldmVscyA9IFtdO1xuICAgIHZhciBpbWFnZXMgPSBbXTtcbiAgICB2YXIgaW1hZ2VJbmRleCA9IDA7XG5cbiAgICB2YXIgd2lkdGg7XG4gICAgdmFyIGhlaWdodDtcbiAgICB2YXIgdXJsO1xuICAgIHZhciBmaWxlbmFtZTtcbiAgICB2YXIgaW5mbztcbiAgICB2YXIgbWF4Wm9vbTtcbiAgICB2YXIgbGFiZWw7XG4gICAgdmFyIGNvbnRleHQ7XG4gICAgdmFyIHJlc291cmNlO1xuICAgIHZhciBpbWFnZUFQSVZlcnNpb247XG5cbiAgICB2YXIgdGl0bGUgPSBtYW5pZmVzdC5sYWJlbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBudW1DYW52YXNlcyA9IGNhbnZhc2VzLmxlbmd0aDsgaSA8IG51bUNhbnZhc2VzOyBpKyspXG4gICAge1xuICAgICAgICByZXNvdXJjZSA9IGNhbnZhc2VzW2ldLmltYWdlc1swXS5yZXNvdXJjZTtcbiAgICAgICAgd2lkdGggPSByZXNvdXJjZS53aWR0aCB8fCBjYW52YXNlc1tpXS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gcmVzb3VyY2UuaGVpZ2h0IHx8IGNhbnZhc2VzW2ldLmhlaWdodDtcblxuICAgICAgICBpbmZvID0gcGFyc2VJbWFnZUluZm8ocmVzb3VyY2UpO1xuICAgICAgICB1cmwgPSBpbmZvLnVybDtcbiAgICAgICAgZmlsZW5hbWUgPSB1cmw7IC8vIEZvciBJSUlGLCB0aGUgdXJsIGlzIHRoZSBmaWxlbmFtZVxuXG4gICAgICAgIC8vYXBwZW5kIHRyYWlsaW5nIC8gZnJvbSB1cmwgaWYgaXQncyBub3QgdGhlcmVcbiAgICAgICAgaWYgKHVybC5zbGljZSgtMSkgIT09ICcvJylcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsID0gdXJsICsgJy8nO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF4Wm9vbSA9IGdldE1heFpvb21MZXZlbCh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBnZXQgZmlsZW5hbWVzIGZyb20gc2VydmljZSBibG9jayAoQFRPRE8gc2hvdWxkIHRoaXMgYmUgY2hhbmdlZCB0byAnaWRlbnRpZmllcnM/JylcbiAgICAgICAgLy8gZ2V0IGxhYmVsIGZyb20gY2FudmFzIGJsb2NrICgnZmlsZW5hbWUnIGlzIGxlZ2FjeSlcbiAgICAgICAgbGFiZWwgPSBjYW52YXNlc1tpXS5sYWJlbDtcblxuICAgICAgICAvLyBpbmRpY2F0ZSB3aGV0aGVyIGNhbnZhcyBoYXMgdmlld2luZ0hpbnQgb2Ygbm9uLXBhZ2VkXG4gICAgICAgIHZhciBwYWdlZCA9IGNhbnZhc2VzW2ldLnZpZXdpbmdIaW50ICE9PSAnbm9uLXBhZ2VkJztcbiAgICAgICAgdmFyIGZhY2luZ1BhZ2VzID0gY2FudmFzZXNbaV0udmlld2luZ0hpbnQgPT09ICdmYWNpbmctcGFnZXMnO1xuXG4gICAgICAgIGNvbnRleHQgPSByZXNvdXJjZS5zZXJ2aWNlWydAY29udGV4dCddO1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gJ2h0dHA6Ly9paWlmLmlvL2FwaS9pbWFnZS8yL2NvbnRleHQuanNvbicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlQVBJVmVyc2lvbiA9IDIuMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaHR0cDovL2xpYnJhcnkuc3RhbmZvcmQuZWR1L2lpaWYvaW1hZ2UtYXBpLzEuMS9jb250ZXh0Lmpzb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZUFQSVZlcnNpb24gPSAxLjE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZUFQSVZlcnNpb24gPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZXNbaW1hZ2VJbmRleF0gPSB7XG4gICAgICAgICAgICAnbXhfdyc6IHdpZHRoLFxuICAgICAgICAgICAgJ214X2gnOiBoZWlnaHQsXG4gICAgICAgICAgICAnbXhfeic6IG1heFpvb20sXG4gICAgICAgICAgICAnbGFiZWwnOiBsYWJlbCxcbiAgICAgICAgICAgICdmbic6IGZpbGVuYW1lLFxuICAgICAgICAgICAgJ3VybCc6IHVybCxcbiAgICAgICAgICAgICdhcGknOiBpbWFnZUFQSVZlcnNpb24sXG4gICAgICAgICAgICAncGFnZWQnOiBwYWdlZCxcbiAgICAgICAgICAgICdmYWNpbmdQYWdlcyc6IGZhY2luZ1BhZ2VzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGluZm8uaGFzT3duUHJvcGVydHkoJ3gnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgaW1hZ2VzW2ltYWdlSW5kZXhdLnhvZmZzZXQgPSBpbmZvLng7XG4gICAgICAgICAgICBpbWFnZXNbaW1hZ2VJbmRleF0ueW9mZnNldCA9IGluZm8ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvb21MZXZlbHNbaW1hZ2VJbmRleF0gPSBtYXhab29tO1xuICAgICAgICBpbWFnZUluZGV4Kys7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VzdE1heFpvb20gPSBNYXRoLm1pbi5hcHBseShNYXRoLCB6b29tTGV2ZWxzKTtcblxuICAgIC8vIHJhdGlvIGNhbGN1bGF0aW9uc1xuICAgIHZhciBtYXhSYXRpbyA9IDA7XG4gICAgdmFyIG1pblJhdGlvID0gMTAwOyAvLyBpbml0aWFsaXplIGhpZ2ggc28gd2UgY2FuIGdldCB0aGUgbWluaW11bSBsYXRlclxuXG4gICAgdmFyIHRvdGFsV2lkdGhzID0gY3JlYXRlQXJyYXlXaXRoVmFsdWUobG93ZXN0TWF4Wm9vbSArIDEsIDApO1xuICAgIHZhciB0b3RhbEhlaWdodHMgPSBjcmVhdGVBcnJheVdpdGhWYWx1ZShsb3dlc3RNYXhab29tICsgMSwgMCk7XG4gICAgdmFyIG1heFdpZHRocyA9IGNyZWF0ZUFycmF5V2l0aFZhbHVlKGxvd2VzdE1heFpvb20gKyAxLCAwKTtcbiAgICB2YXIgbWF4SGVpZ2h0cyA9IGNyZWF0ZUFycmF5V2l0aFZhbHVlKGxvd2VzdE1heFpvb20gKyAxLCAwKTtcblxuICAgIHZhciBwYWdlcyA9IFtdO1xuICAgIHZhciBjdXJyZW50UGFnZVpvb21EYXRhOyAvLyBkaW1lbnNpb25zIHBlciB6b29tbGV2ZWxcblxuICAgIHZhciB3aWR0aEF0Q3VycmVudFpvb21MZXZlbDtcbiAgICB2YXIgaGVpZ2h0QXRDdXJyZW50Wm9vbUxldmVsO1xuXG4gICAgdmFyIG51bUltYWdlcyA9IGltYWdlcy5sZW5ndGg7XG5cbiAgICAvLyBmb3IgZWFjaCBwYWdlIGltYWdlOlxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1JbWFnZXM7IGkrKylcbiAgICB7XG4gICAgICAgIGN1cnJlbnRQYWdlWm9vbURhdGEgPSBbXTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgJ2QnIGtleS4gZm9yIGVhY2ggem9vbSBsZXZlbDpcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsb3dlc3RNYXhab29tICsgMTsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCBwYWdlIHpvb20gZGF0YVxuICAgICAgICAgICAgd2lkdGhBdEN1cnJlbnRab29tTGV2ZWwgPSBNYXRoLmZsb29yKGluY29ycG9yYXRlWm9vbShpbWFnZXNbaV0ubXhfdywgbG93ZXN0TWF4Wm9vbSAtIGopKTtcbiAgICAgICAgICAgIGhlaWdodEF0Q3VycmVudFpvb21MZXZlbCA9IE1hdGguZmxvb3IoaW5jb3Jwb3JhdGVab29tKGltYWdlc1tpXS5teF9oLCBsb3dlc3RNYXhab29tIC0gaikpO1xuICAgICAgICAgICAgY3VycmVudFBhZ2Vab29tRGF0YVtqXSA9IHtcbiAgICAgICAgICAgICAgICBoOiBoZWlnaHRBdEN1cnJlbnRab29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgdzogd2lkdGhBdEN1cnJlbnRab29tTGV2ZWxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGFkZCB3aWR0aCBvZiBpbWFnZSBhdCBjdXJyZW50IHpvb20gbGV2ZWwgdG8gdG90YWwgd2lkdGhzL2hlaWdodHNcbiAgICAgICAgICAgIHRvdGFsV2lkdGhzW2pdICs9IHdpZHRoQXRDdXJyZW50Wm9vbUxldmVsO1xuICAgICAgICAgICAgdG90YWxIZWlnaHRzW2pdICs9IGhlaWdodEF0Q3VycmVudFpvb21MZXZlbDtcbiAgICAgICAgICAgIG1heFdpZHRoc1tqXSA9IE1hdGgubWF4KHdpZHRoQXRDdXJyZW50Wm9vbUxldmVsLCBtYXhXaWR0aHNbal0pO1xuICAgICAgICAgICAgbWF4SGVpZ2h0c1tqXSA9IE1hdGgubWF4KGhlaWdodEF0Q3VycmVudFpvb21MZXZlbCwgbWF4SGVpZ2h0c1tqXSk7XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBtYXgvbWluIHJhdGlvc1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gaW1hZ2VzW2ldLm14X2ggLyBpbWFnZXNbaV0ubXhfdztcbiAgICAgICAgICAgIG1heFJhdGlvID0gTWF0aC5tYXgocmF0aW8sIG1heFJhdGlvKTtcbiAgICAgICAgICAgIG1pblJhdGlvID0gTWF0aC5taW4ocmF0aW8sIG1pblJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhZ2VzW2ldID0ge1xuICAgICAgICAgICAgZDogY3VycmVudFBhZ2Vab29tRGF0YSxcbiAgICAgICAgICAgIG06IGltYWdlc1tpXS5teF96LFxuICAgICAgICAgICAgbDogaW1hZ2VzW2ldLmxhYmVsLFxuICAgICAgICAgICAgZjogaW1hZ2VzW2ldLmZuLFxuICAgICAgICAgICAgdXJsOiBpbWFnZXNbaV0udXJsLFxuICAgICAgICAgICAgYXBpOiBpbWFnZXNbaV0uYXBpLFxuICAgICAgICAgICAgcGFnZWQ6IGltYWdlc1tpXS5wYWdlZCxcbiAgICAgICAgICAgIGZhY2luZ1BhZ2VzOiBpbWFnZXNbaV0uZmFjaW5nUGFnZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW1hZ2VzW2ldLmhhc093blByb3BlcnR5KCd4b2Zmc2V0JykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VzW2ldLnhvZmZzZXQgPSBpbWFnZXNbaV0ueG9mZnNldDtcbiAgICAgICAgICAgIHBhZ2VzW2ldLnlvZmZzZXQgPSBpbWFnZXNbaV0ueW9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhdmVyYWdlV2lkdGhzID0gW107XG4gICAgdmFyIGF2ZXJhZ2VIZWlnaHRzID0gW107XG5cbiAgICAvLyBmb3IgZWFjaCB6b29tIGxldmVsLCBjYWxjdWxhdGUgYXZlcmFnZSBvZiBoZWlnaHRzL3dpZHRoc1xuICAgIGZvciAoaSA9IDA7IGkgPCBsb3dlc3RNYXhab29tICsgMTsgaSsrKVxuICAgIHtcbiAgICAgICAgYXZlcmFnZVdpZHRocy5wdXNoKHRvdGFsV2lkdGhzW2ldIC8gaW1hZ2VzLmxlbmd0aCk7XG4gICAgICAgIGF2ZXJhZ2VIZWlnaHRzLnB1c2godG90YWxIZWlnaHRzW2ldIC8gaW1hZ2VzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGRpbXMgPSB7XG4gICAgICAgICdhX3dpZCc6IGF2ZXJhZ2VXaWR0aHMsXG4gICAgICAgICdhX2hlaSc6IGF2ZXJhZ2VIZWlnaHRzLFxuICAgICAgICAnbWF4X3cnOiBtYXhXaWR0aHMsXG4gICAgICAgICdtYXhfaCc6IG1heEhlaWdodHMsXG4gICAgICAgICdtYXhfcmF0aW8nOiBtYXhSYXRpbyxcbiAgICAgICAgJ21pbl9yYXRpbyc6IG1pblJhdGlvLFxuICAgICAgICAndF9oZWknOiB0b3RhbEhlaWdodHMsXG4gICAgICAgICd0X3dpZCc6IHRvdGFsV2lkdGhzXG4gICAgfTtcblxuXG4gICAgdmFyIGRpdmFTZXJ2aWNlQmxvY2sgPSB7XG4gICAgICAgIGl0ZW1fdGl0bGU6IHRpdGxlLFxuICAgICAgICBkaW1zOiBkaW1zLFxuICAgICAgICBtYXhfem9vbTogbG93ZXN0TWF4Wm9vbSxcbiAgICAgICAgcGdzOiBwYWdlcyxcbiAgICAgICAgcGFnZWQ6IG1hbmlmZXN0LnZpZXdpbmdIaW50ID09PSAncGFnZWQnIHx8IHNlcXVlbmNlLnZpZXdpbmdIaW50ID09PSAncGFnZWQnXG4gICAgfTtcblxuICAgIHJldHVybiBkaXZhU2VydmljZUJsb2NrO1xufVxuXG4vKipcbiAqIFRha2VzIGluIGEgcmVzb3VyY2UgYmxvY2sgZnJvbSBhIGNhbnZhcyBhbmQgb3V0cHV0cyB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGF0IHJlc291cmNlOlxuICogLSBJbWFnZSBVUkxcbiAqIC0gSW1hZ2UgcmVnaW9uIHRvIGJlIGRpc3BsYXllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNvdXJjZSAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlc291cmNlIGJsb2NrIG9mIGEgY2FudmFzIHNlY3Rpb24gaW4gYSBJSUlGIG1hbmlmZXN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBpbWFnZUluZm8gLSBhbiBvYmplY3QgY29udGFpbmluZyBpbWFnZSBVUkwgYW5kIHJlZ2lvblxuICovXG5mdW5jdGlvbiBwYXJzZUltYWdlSW5mbyhyZXNvdXJjZSlcbntcbiAgICB2YXIgdXJsID0gcmVzb3VyY2VbJ0BpZCddO1xuICAgIHZhciBmcmFnbWVudFJlZ2V4ID0gLyN4eXdoPShbMC05XSssWzAtOV0rLFswLTldKyxbMC05XSspLztcbiAgICB2YXIgeHl3aCA9ICcnO1xuICAgIHZhciBzdHJpcFVSTCA9IHRydWU7XG5cbiAgICBpZiAoL1xcLyhbMC05XSssWzAtOV0rLFswLTldKyxbMC05XSspXFwvLy50ZXN0KHVybCkpXG4gICAge1xuICAgICAgICAvLyBpZiByZXNvdXJjZSBpbiBpbWFnZSBBUEkgZm9ybWF0LCBleHRyYWN0IHJlZ2lvbiB4LHksdyxoIGZyb20gVVJMIChhZnRlciA0dGggc2xhc2ggZnJvbSBsYXN0KVxuICAgICAgICAvLyBtYXRjaGVzIGNvb3JkaW5hdGVzIGluIFVSTHMgb2YgdGhlIGZvcm0gaHR0cDovL3d3dy5leGFtcGxlLm9yZy9paWlmL2Jvb2sxLXBhZ2UxLzQwLDUwLDEyMDAsMTgwMC9mdWxsLzAvZGVmYXVsdC5qcGdcbiAgICAgICAgdmFyIHVybEFycmF5ID0gdXJsLnNwbGl0KCcvJyk7XG4gICAgICAgIHh5d2ggPSB1cmxBcnJheVt1cmxBcnJheS5sZW5ndGggLSA0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZnJhZ21lbnRSZWdleC50ZXN0KHVybCkpXG4gICAge1xuICAgICAgICAvLyBtYXRjaGVzIGNvb3JkaW5hdGVzIG9mIHRoZSBzdHlsZSBodHRwOi8vd3d3LmV4YW1wbGUub3JnL2lpaWYvYm9vazEvY2FudmFzL3AxI3h5d2g9NTAsNTAsMzIwLDI0MFxuICAgICAgICB2YXIgcmVzdWx0ID0gZnJhZ21lbnRSZWdleC5leGVjKHVybCk7XG4gICAgICAgIHh5d2ggPSByZXN1bHRbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc291cmNlLnNlcnZpY2UgJiYgcmVzb3VyY2Uuc2VydmljZVsnQGlkJ10pXG4gICAge1xuICAgICAgICAvLyBhc3N1bWUgY2FudmFzIHNpemUgYmFzZWQgb24gaW1hZ2Ugc2l6ZVxuICAgICAgICB1cmwgPSByZXNvdXJjZS5zZXJ2aWNlWydAaWQnXTtcbiAgICAgICAgLy8gdGhpcyBVUkwgZXhjbHVkZXMgcmVnaW9uIHBhcmFtZXRlcnMgc28gd2UgZG9uJ3QgbmVlZCB0byByZW1vdmUgdGhlbVxuICAgICAgICBzdHJpcFVSTCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJpcFVSTClcbiAgICB7XG4gICAgICAgIC8vIGV4dHJhY3QgVVJMIHVwIHRvIGlkZW50aWZpZXIgKHdlIGVsaW1pbmF0ZSB0aGUgbGFzdCA1IHBhcmFtZXRlcnM6IC9yZWdpb24vc2l6ZS9yb3RhdGlvbi9xdWFsaXR5LmZvcm1hdClcbiAgICAgICAgdXJsID0gdXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgLTQpLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VJbmZvID0ge1xuICAgICAgICB1cmw6IHVybFxuICAgIH07XG5cbiAgICBpZiAoeHl3aC5sZW5ndGgpXG4gICAge1xuICAgICAgICAvLyBwYXJzZSBpbnRvIHNlcGFyYXRlIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB4eXdoLnNwbGl0KCcsJyk7XG4gICAgICAgIGltYWdlSW5mby54ID0gcGFyc2VJbnQoZGltZW5zaW9uc1swXSwgMTApO1xuICAgICAgICBpbWFnZUluZm8ueSA9IHBhcnNlSW50KGRpbWVuc2lvbnNbMV0sIDEwKTtcbiAgICAgICAgaW1hZ2VJbmZvLncgPSBwYXJzZUludChkaW1lbnNpb25zWzJdLCAxMCk7XG4gICAgICAgIGltYWdlSW5mby5oID0gcGFyc2VJbnQoZGltZW5zaW9uc1szXSwgMTApO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZUluZm87XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3BhcnNlLWlpaWYtbWFuaWZlc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIGRpdmEgPSByZXF1aXJlKCcuL2RpdmEtZ2xvYmFsJyk7XG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUb29sYmFyO1xuXG5mdW5jdGlvbiBjcmVhdGVUb29sYmFyKHZpZXdlcilcbntcbiAgICB2YXIgc2V0dGluZ3MgPSB2aWV3ZXIuZ2V0U2V0dGluZ3MoKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IFRlbXBvcmFyaWx5IGNvcGllZCBmcm9tIHdpdGhpbiBEaXZhXG4gICAgdmFyIGVsZW1BdHRycyA9IGZ1bmN0aW9uIChpZGVudCwgYmFzZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkZW50LFxuICAgICAgICAgICAgY2xhc3M6ICdkaXZhLScgKyBpZGVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKGF0dHJzLCBiYXNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG5cbiAgICAvKiogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc3Vic2NyaWJlIHRvIGEgRGl2YSBldmVudCAqL1xuICAgIHZhciBzdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgc2V0dGluZ3MuSUQpO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGVzIGEgdG9vbGJhciBidXR0b25cbiAgICB2YXIgY3JlYXRlQnV0dG9uRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIGxhYmVsLCBjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBidXR0b24gPSBlbHQoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgICAgICAgICAgaWQ6IHNldHRpbmdzLklEICsgbmFtZSxcbiAgICAgICAgICAgIGNsYXNzOiAnZGl2YS0nICsgbmFtZSArICcgZGl2YS1idXR0b24nLFxuICAgICAgICAgICAgdGl0bGU6IGxhYmVsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9O1xuXG4gICAgLy8gSGlnaGVyLWxldmVsIGZ1bmN0aW9uIGZvciBjcmVhdG9ycyBvZiB6b29tIGFuZCBncmlkIGNvbnRyb2xzXG4gICAgdmFyIGdldFJlc29sdXRpb25Db250cm9sQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWcpXG4gICAge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xzO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzW2NvbmZpZy5jb250cm9sbGVyU2V0dGluZ10pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2xpZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMgPSBjb25maWcuY3JlYXRlU2xpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9ucyc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzID0gY29uZmlnLmNyZWF0ZUJ1dHRvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkaXNwbGF5IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGVsdCgnc3BhbicsXG4gICAgICAgICAgICAgICAgY29udHJvbHMsXG4gICAgICAgICAgICAgICAgY29uZmlnLmNyZWF0ZUxhYmVsKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVXcmFwcGVyID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkID09PSBjb25maWcuc2hvd0luR3JpZClcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdEaWRTd2l0Y2gnLCB1cGRhdGVXcmFwcGVyKTtcbiAgICAgICAgICAgIHN1YnNjcmliZSgnT2JqZWN0RGlkTG9hZCcsIHVwZGF0ZVdyYXBwZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdXBkYXRlV3JhcHBlcigpO1xuXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gWm9vbSBjb250cm9sc1xuICAgIHZhciBjcmVhdGVab29tQ29udHJvbHMgPSBnZXRSZXNvbHV0aW9uQ29udHJvbENyZWF0b3Ioe1xuICAgICAgICBjb250cm9sbGVyU2V0dGluZzogJ2VuYWJsZVpvb21Db250cm9scycsXG4gICAgICAgIHNob3dJbkdyaWQ6IGZhbHNlLFxuXG4gICAgICAgIGNyZWF0ZVNsaWRlcjogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVTbGlkZXIoJ3pvb20tc2xpZGVyJywge1xuICAgICAgICAgICAgICAgIHN0ZXA6IDAuMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2V0dGluZ3Muem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIG1pbjogc2V0dGluZ3MubWluWm9vbUxldmVsLFxuICAgICAgICAgICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbUxldmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQoZWxlbSk7XG5cbiAgICAgICAgICAgICRlbGVtLm9uKCdpbnB1dCcsIGZ1bmN0aW9uKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChmbG9hdFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkZWxlbS5vbignY2hhbmdlJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0VmFsdWUgIT09IHNldHRpbmdzLnpvb21MZXZlbClcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChmbG9hdFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlU2xpZGVyID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muem9vbUxldmVsICE9PSAkZWxlbS52YWwoKSlcbiAgICAgICAgICAgICAgICAgICAgJGVsZW0udmFsKHNldHRpbmdzLnpvb21MZXZlbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1pvb21MZXZlbERpZENoYW5nZScsIHVwZGF0ZVNsaWRlcik7XG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsdC5zZXRBdHRyaWJ1dGVzKGVsZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiBzZXR0aW5ncy5taW5ab29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbUxldmVsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXIoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCdXR0b25zOiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KCdzcGFuJyxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCd6b29tLW91dC1idXR0b24nLCAnWm9vbSBPdXQnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChzZXR0aW5ncy56b29tTGV2ZWwgLSAxKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCd6b29tLWluLWJ1dHRvbicsICdab29tIEluJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRab29tTGV2ZWwoc2V0dGluZ3Muem9vbUxldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTGFiZWw6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gY3JlYXRlTGFiZWwoJ2RpdmEtem9vbS1sYWJlbCcsICd6b29tLWxhYmVsJywgJ1pvb20gbGV2ZWw6ICcsICd6b29tLWxldmVsJywgc2V0dGluZ3Muem9vbUxldmVsKTtcbiAgICAgICAgICAgIHZhciB0ZXh0U3BhbiA9ICQoZWxlbSkuZmluZChzZXR0aW5ncy5zZWxlY3RvciArICd6b29tLWxldmVsJylbMF07XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVUZXh0ID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3Bhbi50ZXh0Q29udGVudCA9IHNldHRpbmdzLnpvb21MZXZlbC50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3Vic2NyaWJlKCdab29tTGV2ZWxEaWRDaGFuZ2UnLCB1cGRhdGVUZXh0KTtcbiAgICAgICAgICAgIHN1YnNjcmliZSgnVmlld2VyRGlkTG9hZCcsIHVwZGF0ZVRleHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gR3JpZCBjb250cm9sc1xuICAgIHZhciBjcmVhdGVHcmlkQ29udHJvbHMgPSBnZXRSZXNvbHV0aW9uQ29udHJvbENyZWF0b3Ioe1xuICAgICAgICBjb250cm9sbGVyU2V0dGluZzogJ2VuYWJsZUdyaWRDb250cm9scycsXG4gICAgICAgIHNob3dJbkdyaWQ6IHRydWUsXG5cbiAgICAgICAgY3JlYXRlU2xpZGVyOiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGNyZWF0ZVNsaWRlcignZ3JpZC1zbGlkZXInLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNldHRpbmdzLnBhZ2VzUGVyUm93LFxuICAgICAgICAgICAgICAgIG1pbjogc2V0dGluZ3MubWluUGFnZXNQZXJSb3csXG4gICAgICAgICAgICAgICAgbWF4OiBzZXR0aW5ncy5tYXhQYWdlc1BlclJvd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pO1xuXG4gICAgICAgICAgICAkZWxlbS5vbignaW5wdXQnLCBmdW5jdGlvbigpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQoZWxlbS52YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coaW50VmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRlbGVtLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KGVsZW0udmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50VmFsdWUgIT09IHNldHRpbmdzLnBhZ2VzUGVyUm93KVxuICAgICAgICAgICAgICAgICAgICB2aWV3ZXIuc2V0R3JpZFBhZ2VzUGVyUm93KGludFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ0dyaWRSb3dOdW1iZXJEaWRDaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZSB3aXRoaW4gdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wYWdlc1BlclJvdyAhPT0gJGVsZW0udmFsKCkpXG4gICAgICAgICAgICAgICAgICAgICRlbGVtLnZhbChzZXR0aW5ncy5wYWdlc1BlclJvdyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQnV0dG9uczogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGVsdCgnc3BhbicsXG4gICAgICAgICAgICAgICAgY3JlYXRlQnV0dG9uRWxlbWVudCgnZ3JpZC1vdXQtYnV0dG9uJywgJ1pvb20gT3V0JywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coc2V0dGluZ3MucGFnZXNQZXJSb3cgLSAxKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCdncmlkLWluLWJ1dHRvbicsICdab29tIEluJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coc2V0dGluZ3MucGFnZXNQZXJSb3cgKyAxKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMYWJlbDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVMYWJlbCgnZGl2YS1ncmlkLWxhYmVsJywgJ2dyaWQtbGFiZWwnLCAnUGFnZXMgcGVyIHJvdzogJywgJ3BhZ2VzLXBlci1yb3cnLCBzZXR0aW5ncy5wYWdlc1BlclJvdyk7XG4gICAgICAgICAgICB2YXIgdGV4dFNwYW4gPSAkKGVsZW0pLmZpbmQoc2V0dGluZ3Muc2VsZWN0b3IgKyAncGFnZXMtcGVyLXJvdycpWzBdO1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ0dyaWRSb3dOdW1iZXJEaWRDaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHRTcGFuLnRleHRDb250ZW50ID0gc2V0dGluZ3MucGFnZXNQZXJSb3c7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjcmVhdGVWaWV3TWVudSA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciB2aWV3T3B0aW9uc0xpc3QgPSBlbHQoJ2RpdicsIGVsZW1BdHRycygndmlldy1vcHRpb25zJykpO1xuXG4gICAgICAgIHZhciBjaGFuZ2VWaWV3QnV0dG9uID0gY3JlYXRlQnV0dG9uRWxlbWVudCgndmlldy1pY29uJywgJ0NoYW5nZSB2aWV3JywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJCh2aWV3T3B0aW9uc0xpc3QpLnRvZ2dsZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKGRvY3VtZW50KS5tb3VzZXVwKGZ1bmN0aW9uIChldmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQodmlld09wdGlvbnNMaXN0KTtcblxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuaXMoZXZlbnQudGFyZ2V0KSAmJiBjb250YWluZXIuaGFzKGV2ZW50LnRhcmdldCkubGVuZ3RoID09PSAwICYmIGV2ZW50LnRhcmdldC5pZCAhPT0gc2V0dGluZ3MuSUQgKyAndmlldy1pY29uJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VsZWN0VmlldyA9IGZ1bmN0aW9uICh2aWV3KVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXIuY2hhbmdlVmlldyh2aWV3KTtcblxuICAgICAgICAgICAgLy9oaWRlIHZpZXcgbWVudVxuICAgICAgICAgICAgJCh2aWV3T3B0aW9uc0xpc3QpLmhpZGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlVmlld01lbnUgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB2aWV3SWNvbkNsYXNzZXMgPSAnIGRpdmEtdmlldy1pY29uIGRpdmEtYnV0dG9uJztcblxuICAgICAgICAgICAgLy8gZGlzcGxheSB0aGUgaWNvbiBvZiB0aGUgbW9kZSB3ZSdyZSBjdXJyZW50bHkgaW4gKD8pXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoYW5nZVZpZXdCdXR0b24uY2xhc3NOYW1lID0gJ2RpdmEtZ3JpZC1pY29uJyArIHZpZXdJY29uQ2xhc3NlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmluQm9va0xheW91dClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VWaWV3QnV0dG9uLmNsYXNzTmFtZSA9ICdkaXZhLWJvb2staWNvbicgKyB2aWV3SWNvbkNsYXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVmlld0J1dHRvbi5jbGFzc05hbWUgPSAnZGl2YS1kb2N1bWVudC1pY29uJyArIHZpZXdJY29uQ2xhc3NlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZpZXdPcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgICAgICAvLyB0aGVuIGRpc3BsYXkgZG9jdW1lbnQsIGJvb2ssIGFuZCBncmlkIGJ1dHRvbnMgaW4gdGhhdCBvcmRlciwgZXhjbHVkaW5nIHRoZSBjdXJyZW50IHZpZXdcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkdyaWQgfHwgc2V0dGluZ3MuaW5Cb29rTGF5b3V0KVxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb25zLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbkVsZW1lbnQoJ2RvY3VtZW50LWljb24nLCAnRG9jdW1lbnQgVmlldycsIHNlbGVjdFZpZXcuYmluZChudWxsLCAnZG9jdW1lbnQnKSkpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkIHx8ICFzZXR0aW5ncy5pbkJvb2tMYXlvdXQpXG4gICAgICAgICAgICAgICAgdmlld09wdGlvbnMuYXBwZW5kQ2hpbGQoY3JlYXRlQnV0dG9uRWxlbWVudCgnYm9vay1pY29uJywgJ0Jvb2sgVmlldycsIHNlbGVjdFZpZXcuYmluZChudWxsLCAnYm9vaycpKSk7XG5cbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb25zLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbkVsZW1lbnQoJ2dyaWQtaWNvbicsICdHcmlkIFZpZXcnLCBzZWxlY3RWaWV3LmJpbmQobnVsbCwgJ2dyaWQnKSkpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIG1lbnVcbiAgICAgICAgICAgIHdoaWxlICh2aWV3T3B0aW9uc0xpc3QuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2aWV3T3B0aW9uc0xpc3QucmVtb3ZlQ2hpbGQodmlld09wdGlvbnNMaXN0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgbmV3IG1lbnVcbiAgICAgICAgICAgIHZpZXdPcHRpb25zTGlzdC5hcHBlbmRDaGlsZCh2aWV3T3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3Vic2NyaWJlKCdWaWV3RGlkU3dpdGNoJywgdXBkYXRlVmlld01lbnUpO1xuICAgICAgICBzdWJzY3JpYmUoJ09iamVjdERpZExvYWQnLCB1cGRhdGVWaWV3TWVudSk7XG5cbiAgICAgICAgcmV0dXJuIGVsdCgnZGl2JywgZWxlbUF0dHJzKCd2aWV3LW1lbnUnKSxcbiAgICAgICAgICAgIGNoYW5nZVZpZXdCdXR0b24sXG4gICAgICAgICAgICB2aWV3T3B0aW9uc0xpc3RcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNsaWRlciA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpXG4gICAge1xuICAgICAgICByZXR1cm4gZWx0KCdpbnB1dCcsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIG5hbWUsXG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtJyArIG5hbWUgKyAnIGRpdmEtc2xpZGVyJyxcbiAgICAgICAgICAgIHR5cGU6ICdyYW5nZSdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMYWJlbCA9IGZ1bmN0aW9uKG5hbWUsIGlkLCBsYWJlbCwgaW5uZXJOYW1lLCBpbm5lclZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBuYW1lICsgJyBkaXZhLWxhYmVsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBlbHQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlubmVyTmFtZVxuICAgICAgICAgICAgICAgIH0sIGlubmVyVmFsdWUpXG4gICAgICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhZ2VOYXZpZ2F0aW9uQ29udHJvbHMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gR28gdG8gcGFnZSBmb3JtXG4gICAgICAgIHZhciBnb3RvRm9ybSA9IHNldHRpbmdzLmVuYWJsZUdvdG9QYWdlID8gY3JlYXRlR290b1BhZ2VGb3JtKCkgOiBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbHQoJ3NwYW4nLCBlbGVtQXR0cnMoJ3BhZ2UtbmF2JyksXG4gICAgICAgICAgICBjcmVhdGVQYWdlTGFiZWwoKSwgLy8gJ1BhZ2UgeCBvZiB5JyBsYWJlbFxuICAgICAgICAgICAgZ290b0Zvcm1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUdvdG9QYWdlRm9ybSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ290b1BhZ2VJbnB1dCA9IGVsdCgnaW5wdXQnLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlLWlucHV0JyxcbiAgICAgICAgICAgIGNsYXNzOiAnZGl2YS1pbnB1dCBkaXZhLWdvdG8tcGFnZS1pbnB1dCcsXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBnb3RvUGFnZVN1Ym1pdCA9IGVsdCgnaW5wdXQnLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlLXN1Ym1pdCcsXG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtYnV0dG9uIGRpdmEtYnV0dG9uLXRleHQnLFxuICAgICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXG4gICAgICAgICAgICB2YWx1ZTogJ0dvJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaW5wdXRTdWdnZXN0aW9ucyA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdpbnB1dC1zdWdnZXN0aW9ucycsXG4gICAgICAgICAgICAgICAgY2xhc3M6ICdkaXZhLWlucHV0LXN1Z2dlc3Rpb25zJ1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBnb3RvRm9ybSA9IGVsdCgnZm9ybScsIHtcbiAgICAgICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlJyxcbiAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtZ290by1mb3JtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdvdG9QYWdlSW5wdXQsXG4gICAgICAgICAgICBnb3RvUGFnZVN1Ym1pdCxcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICAkKGdvdG9Gb3JtKS5vbignc3VibWl0JywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRlc2lyZWRQYWdlTGFiZWwgPSBnb3RvUGFnZUlucHV0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub25Hb3RvU3VibWl0ICYmIHR5cGVvZiBzZXR0aW5ncy5vbkdvdG9TdWJtaXQgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gc2V0dGluZ3Mub25Hb3RvU3VibWl0KGRlc2lyZWRQYWdlTGFiZWwpO1xuICAgICAgICAgICAgICAgIGlmICghdmlld2VyLmdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgICBhbGVydChcIk5vIHBhZ2UgY291bGQgYmUgZm91bmQgd2l0aCB0aGF0IGxhYmVsIG9yIHBhZ2UgbnVtYmVyXCIpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIC8vIERlZmF1bHQgaWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkIGluIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghdmlld2VyLmdvdG9QYWdlQnlMYWJlbChkZXNpcmVkUGFnZUxhYmVsKSlcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJObyBwYWdlIGNvdWxkIGJlIGZvdW5kIHdpdGggdGhhdCBsYWJlbCBvciBwYWdlIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGlkZSB0aGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgcmVsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZ290b1BhZ2VJbnB1dCkub24oJ2lucHV0IGZvY3VzJywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXRTdWdnZXN0aW9ucy5pbm5lckhUTUwgPSAnJzsgLy8gUmVtb3ZlIGFsbCBwcmV2aW91cyBzdWdnZXN0aW9uc1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnb3RvUGFnZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIG51bVN1Z2dlc3Rpb25zID0gMDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVHb3RvU3VnZ2VzdGlvbnMgJiYgdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VzID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbiAmJiBudW1TdWdnZXN0aW9ucyA8IDEwOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFnZXNbaV0ubC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0lucHV0U3VnZ2VzdGlvbiA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtaW5wdXQtc3VnZ2VzdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VzW2ldLmxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuYXBwZW5kQ2hpbGQobmV3SW5wdXRTdWdnZXN0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtU3VnZ2VzdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNob3cgbGFiZWwgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAobnVtU3VnZ2VzdGlvbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBpbnB1dFN1Z2dlc3Rpb25zLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChnb3RvUGFnZUlucHV0KS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWw7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykgLy8gJ0VudGVyJyBrZXlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gJCgnLmFjdGl2ZScsIGlucHV0U3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBnb3RvUGFnZUlucHV0LnZhbHVlID0gYWN0aXZlLnRleHQoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzgpIC8vIFVwIGFycm93IGtleVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsID0gJCgnLmFjdGl2ZScsIGlucHV0U3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2RWwgPSBlbC5wcmV2KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZFbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZFbC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmRpdmEtaW5wdXQtc3VnZ2VzdGlvbjpsYXN0JywgaW5wdXRTdWdnZXN0aW9ucykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gNDApIC8vIERvd24gYXJyb3cga2V5XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWwgPSAkKCcuYWN0aXZlJywgaW5wdXRTdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRFbCA9IGVsLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsLmxlbmd0aClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAkKCcuZGl2YS1pbnB1dC1zdWdnZXN0aW9uOmZpcnN0JywgaW5wdXRTdWdnZXN0aW9ucykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChpbnB1dFN1Z2dlc3Rpb25zKS5vbignbW91c2Vkb3duJywgJy5kaXZhLWlucHV0LXN1Z2dlc3Rpb24nLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdvdG9QYWdlSW5wdXQudmFsdWUgPSB0aGlzLnRleHRDb250ZW50O1xuICAgICAgICAgICAgaW5wdXRTdWdnZXN0aW9ucy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgJChnb3RvUGFnZUlucHV0KS50cmlnZ2VyKCdzdWJtaXQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChnb3RvUGFnZUlucHV0KS5vbignYmx1cicsIGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEhpZGUgbGFiZWwgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdvdG9Gb3JtO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGFnZUxhYmVsID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gQ3VycmVudCBwYWdlXG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IGVsdCgnc3BhbicsIHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdjdXJyZW50LXBhZ2UnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB1cGRhdGVDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlLnRleHRDb250ZW50ID0gcGFyc2VJbnQoc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCwgMTApICsgMTtcbiAgICAgICAgfTtcblxuICAgICAgICBzdWJzY3JpYmUoJ1Zpc2libGVQYWdlRGlkQ2hhbmdlJywgdXBkYXRlQ3VycmVudFBhZ2UpO1xuICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCB1cGRhdGVDdXJyZW50UGFnZSk7XG5cbiAgICAgICAgLy8gTnVtYmVyIG9mIHBhZ2VzXG4gICAgICAgIHZhciBudW1QYWdlcyA9IGVsdCgnc3BhbicsIHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdudW0tcGFnZXMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB1cGRhdGVOdW1QYWdlcyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG51bVBhZ2VzLnRleHRDb250ZW50ID0gc2V0dGluZ3MubnVtUGFnZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3Vic2NyaWJlKCdOdW1iZXJPZlBhZ2VzRGlkQ2hhbmdlJywgdXBkYXRlTnVtUGFnZXMpO1xuICAgICAgICBzdWJzY3JpYmUoJ09iamVjdERpZExvYWQnLCB1cGRhdGVOdW1QYWdlcyk7XG5cbiAgICAgICAgcmV0dXJuIGVsdCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtcGFnZS1sYWJlbCBkaXZhLWxhYmVsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdQYWdlICcsIGN1cnJlbnRQYWdlLCAnIG9mICcsIG51bVBhZ2VzXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVUb29sYmFyQnV0dG9uR3JvdXAgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGJ1dHRvbnMgPSBbY3JlYXRlVmlld01lbnUoKV07XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZUxpbmtJY29uKVxuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKGNyZWF0ZUxpbmtJY29uKCkpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVOb25QYWdlZFZpc2liaWxpdHlJY29uKVxuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKGNyZWF0ZVRvZ2dsZU5vblBhZ2VkQnV0dG9uKCkpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVGdWxsc2NyZWVuKVxuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKGNyZWF0ZUZ1bGxzY3JlZW5CdXR0b24oKSk7XG5cbiAgICAgICAgcmV0dXJuIGVsdCgnc3BhbicsIGVsZW1BdHRycygndG9vbGJhci1idXR0b24tZ3JvdXAnKSwgYnV0dG9ucyk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMaW5rSWNvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbSA9IGNyZWF0ZUJ1dHRvbkVsZW1lbnQoJ2xpbmstaWNvbicsICdMaW5rIHRvIHRoaXMgcGFnZScpO1xuICAgICAgICB2YXIgbGlua0ljb24gPSAkKGVsZW0pO1xuXG4gICAgICAgIGxpbmtJY29uLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgICQoJ2JvZHknKS5wcmVwZW5kKFxuICAgICAgICAgICAgICAgIGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnbGluay1wb3B1cCcsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZGl2YS1wb3B1cCBkaXZhLWxpbmstcG9wdXAnXG4gICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICBlbHQoJ2lucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNldHRpbmdzLklEICsgJ2xpbmstcG9wdXAtaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdkaXZhLWlucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2aWV3ZXIuZ2V0Q3VycmVudFVSTCgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkZ1bGxzY3JlZW4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICdsaW5rLXBvcHVwJykuYWRkQ2xhc3MoJ2luLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlZnQgYW5kIHRvcCBvZmZzZXRzXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSBsaW5rSWNvbi5vZmZzZXQoKS5sZWZ0IC0gMjIyICsgbGlua0ljb24ub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciB0b3BPZmZzZXQgPSBsaW5rSWNvbi5vZmZzZXQoKS50b3AgKyBsaW5rSWNvbi5vdXRlckhlaWdodCgpIC0gMTtcblxuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAnbGluay1wb3B1cCcpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICd0b3AnOiB0b3BPZmZzZXQgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAnbGVmdCc6IGxlZnRPZmZzZXQgKyAncHgnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhdGNoIG9ubW91c2V1cCBldmVudHMgb3V0c2lkZSBvZiB0aGlzIGRpdlxuICAgICAgICAgICAgJCgnYm9keScpLm1vdXNldXAoZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJRCA9IGV2ZW50LnRhcmdldC5pZDtcblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJRCAhPT0gc2V0dGluZ3MuSUQgKyAnbGluay1wb3B1cCcgJiYgdGFyZ2V0SUQgIT09IHNldHRpbmdzLklEICsgJ2xpbmstcG9wdXAtaW5wdXQnKVxuICAgICAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2xpbmstcG9wdXAnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBbHNvIGRlbGV0ZSBpdCB1cG9uIHNjcm9sbCBhbmQgcGFnZSB1cC9kb3duIGtleSBldmVudHNcbiAgICAgICAgICAgIC8vIEZJWE1FKHdhYmFpbik6IFRoaXMgaXMgYWdncmVzc2l2ZVxuICAgICAgICAgICAgc2V0dGluZ3Mudmlld3BvcnRPYmplY3Quc2Nyb2xsKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICdsaW5rLXBvcHVwJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAnbGluay1wb3B1cCBpbnB1dCcpLmNsaWNrKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5mb2N1cygpLnNlbGVjdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVGdWxsc2NyZWVuQnV0dG9uID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdXR0b25FbGVtZW50KCdmdWxsc2NyZWVuLWljb24nLCAnVG9nZ2xlIGZ1bGxzY3JlZW4gbW9kZScsIGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlci50b2dnbGVGdWxsc2NyZWVuTW9kZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRvZ2dsZU5vblBhZ2VkQnV0dG9uID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBnZXRDbGFzc05hbWUgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAndG9nZ2xlLW5vbnBhZ2VkLWljb24nICsgKHZpZXdlci5nZXRTZXR0aW5ncygpLnNob3dOb25QYWdlZFBhZ2VzID8gJy1hY3RpdmUnIDogJycpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b2dnbGVOb25QYWdlZEJ1dHRvbiA9IGNyZWF0ZUJ1dHRvbkVsZW1lbnQoZ2V0Q2xhc3NOYW1lKCksICdUb2dnbGUgdmlzaWJpbGl0eSBvZiBub24tcGFnZWQgcGFnZXMnLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlci50b2dnbGVOb25QYWdlZFBhZ2VzVmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgdmFyIG5ld0NsYXNzTmFtZSA9ICdkaXZhLScgKyBnZXRDbGFzc05hbWUoKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUucmVwbGFjZSgvZGl2YS10b2dnbGUtbm9ucGFnZWQtaWNvbigtYWN0aXZlKT8vLCBuZXdDbGFzc05hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdXBkYXRlTm9uUGFnZWRCdXR0b25WaXNpYmlsaXR5ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhZ2VzID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5tYW5pZmVzdC5wYWdlZCAmJiAhcGFnZXNbaV0ucGFnZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSBidXR0b24sIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBub24tcGFnZWQgcGFnZVxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVOb25QYWdlZEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIG5vbi1wYWdlZCBwYWdlcyB3ZXJlIGZvdW5kLCBoaWRlIHRoZSBidXR0b25cbiAgICAgICAgICAgIHRvZ2dsZU5vblBhZ2VkQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH07XG4gICAgICAgIHN1YnNjcmliZSgnT2JqZWN0RGlkTG9hZCcsIHVwZGF0ZU5vblBhZ2VkQnV0dG9uVmlzaWJpbGl0eSk7XG5cbiAgICAgICAgcmV0dXJuIHRvZ2dsZU5vblBhZ2VkQnV0dG9uO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGVzIGFsbCBzdGF0dXMgdXBkYXRpbmcgZXRjIChib3RoIGZ1bGxzY3JlZW4gYW5kIG5vdClcbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgbGVmdFRvb2xzID0gW2NyZWF0ZVpvb21Db250cm9scygpLCBjcmVhdGVHcmlkQ29udHJvbHMoKV07XG4gICAgICAgIHZhciByaWdodFRvb2xzID0gW2NyZWF0ZVBhZ2VOYXZpZ2F0aW9uQ29udHJvbHMoKSwgY3JlYXRlVG9vbGJhckJ1dHRvbkdyb3VwKCldO1xuXG4gICAgICAgIHZhciB0b29scyA9IGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0b29scycpLFxuICAgICAgICAgICAgZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ3Rvb2xzLWxlZnQnKSwgbGVmdFRvb2xzKSxcbiAgICAgICAgICAgIGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0b29scy1yaWdodCcpLCByaWdodFRvb2xzKVxuICAgICAgICApO1xuXG4gICAgICAgIHNldHRpbmdzLnRvb2xiYXJQYXJlbnRPYmplY3QucHJlcGVuZCh0b29scyk7XG5cbiAgICAgICAgLy8gSGFuZGxlIGVudHJ5IHRvIGFuZCBleGl0IGZyb20gZnVsbHNjcmVlbiBtb2RlXG4gICAgICAgIHZhciBzd2l0Y2hNb2RlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRvb2xzUmlnaHRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2V0dGluZ3MuSUQgKyAndG9vbHMtcmlnaHQnKTtcbiAgICAgICAgICAgIHZhciBwYWdlTmF2RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNldHRpbmdzLklEICsgJ3BhZ2UtbmF2Jyk7XG5cbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaW5GdWxsc2NyZWVuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIExlYXZpbmcgZnVsbHNjcmVlblxuICAgICAgICAgICAgICAgICQodG9vbHMpLnJlbW92ZUNsYXNzKCdkaXZhLWZ1bGxzY3JlZW4tdG9vbHMnKTtcblxuICAgICAgICAgICAgICAgIC8vbW92ZSBJRC1wYWdlLW5hdiB0byBiZWdpbm5pbmcgb2YgdG9vbHMgcmlnaHRcbiAgICAgICAgICAgICAgICB0b29sc1JpZ2h0RWxlbWVudC5yZW1vdmVDaGlsZChwYWdlTmF2RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdG9vbHNSaWdodEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHBhZ2VOYXZFbGVtZW50LCB0b29sc1JpZ2h0RWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBFbnRlcmluZyBmdWxsc2NyZWVuXG4gICAgICAgICAgICAgICAgJCh0b29scykuYWRkQ2xhc3MoJ2RpdmEtZnVsbHNjcmVlbi10b29scycpO1xuXG4gICAgICAgICAgICAgICAgLy9tb3ZlIElELXBhZ2UtbmF2IHRvIGVuZCBvZiB0b29scyByaWdodFxuICAgICAgICAgICAgICAgIHRvb2xzUmlnaHRFbGVtZW50LnJlbW92ZUNoaWxkKHBhZ2VOYXZFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0b29sc1JpZ2h0RWxlbWVudC5hcHBlbmRDaGlsZChwYWdlTmF2RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc3Vic2NyaWJlKCdNb2RlRGlkU3dpdGNoJywgc3dpdGNoTW9kZSk7XG4gICAgICAgIHN1YnNjcmliZSgnVmlld2VyRGlkTG9hZCcsIHN3aXRjaE1vZGUpO1xuXG4gICAgICAgIHZhciB0b29sYmFyID0ge1xuICAgICAgICAgICAgZWxlbWVudDogdG9vbHMsXG4gICAgICAgICAgICBjbG9zZVBvcHVwczogZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAkKCcuZGl2YS1wb3B1cCcpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgfTtcblxuICAgIHJldHVybiBpbml0KCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3Rvb2xiYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxucmVxdWlyZSgnLi91dGlscy9qcXVlcnktZXh0ZW5zaW9ucycpO1xuXG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcbnZhciBnZXRTY3JvbGxiYXJXaWR0aCA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0LXNjcm9sbGJhci13aWR0aCcpO1xuXG52YXIgZ2VzdHVyZUV2ZW50cyA9IHJlcXVpcmUoJy4vZ2VzdHVyZS1ldmVudHMnKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi9kaXZhLWdsb2JhbCcpO1xudmFyIERvY3VtZW50SGFuZGxlciA9IHJlcXVpcmUoJy4vZG9jdW1lbnQtaGFuZGxlcicpO1xudmFyIEdyaWRIYW5kbGVyID0gcmVxdWlyZSgnLi9ncmlkLWhhbmRsZXInKTtcbnZhciBQYWdlT3ZlcmxheU1hbmFnZXIgPSByZXF1aXJlKCcuL3BhZ2Utb3ZlcmxheS1tYW5hZ2VyJyk7XG52YXIgUGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL3BsdWdpbi1yZWdpc3RyeScpO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIGdldFBhZ2VMYXlvdXRzID0gcmVxdWlyZSgnLi9wYWdlLWxheW91dHMnKTtcbnZhciBjcmVhdGVTZXR0aW5nc1ZpZXcgPSByZXF1aXJlKCcuL3NldHRpbmdzLXZpZXcnKTtcbnZhciBWYWxpZGF0aW9uUnVubmVyID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uLXJ1bm5lcicpO1xudmFyIFZpZXdwb3J0ID0gcmVxdWlyZSgnLi92aWV3cG9ydCcpO1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdkaXZhOlZpZXdlckNvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3ZXJDb3JlO1xuXG4vLyBEZWZpbmUgdmFsaWRhdGlvbnNcbnZhciBvcHRpb25zVmFsaWRhdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBrZXk6ICdnb0RpcmVjdGx5VG8nLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlLCBzZXR0aW5ncylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnbWluUGFnZXNQZXJSb3cnLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ21heFBhZ2VzUGVyUm93JyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSwgc2V0dGluZ3MubWluUGFnZXNQZXJSb3cpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ3BhZ2VzUGVyUm93JyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIG1heGltdW1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IHNldHRpbmdzLm1pblBhZ2VzUGVyUm93IHx8IHZhbHVlID4gc2V0dGluZ3MubWF4UGFnZXNQZXJSb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1heFBhZ2VzUGVyUm93O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ21heFpvb21MZXZlbCcsXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUsIHNldHRpbmdzLCBjb25maWcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoaXMgdmFsdWUgaXNuJ3QgcmVhbGx5IGFuIGVycm9yLCBpdCBqdXN0IGRlcGVuZHMgb24gdGhlXG4gICAgICAgICAgICAvLyBzb3VyY2UgbWFuaWZlc3RcbiAgICAgICAgICAgIGNvbmZpZy5zdXBwcmVzc1dhcm5pbmcoKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IHNldHRpbmdzLm1hbmlmZXN0Lm1heFpvb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0Lm1heFpvb207XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnbWluWm9vbUxldmVsJyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MsIGNvbmZpZylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQ2hhbmdlcyBiYXNlZCBvbiB0aGUgbWFuaWZlc3QgdmFsdWUgc2hvdWxkbid0IHRyaWdnZXIgYVxuICAgICAgICAgICAgLy8gd2FybmluZ1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gc2V0dGluZ3MubWFuaWZlc3QubWF4Wm9vbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcHJlc3NXYXJuaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiBzZXR0aW5ncy5tYXhab29tTGV2ZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnem9vbUxldmVsJyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MsIGNvbmZpZylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gc2V0dGluZ3MubWFuaWZlc3QubWF4Wm9vbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcHJlc3NXYXJuaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IHNldHRpbmdzLm1pblpvb21MZXZlbCB8fCB2YWx1ZSA+IHNldHRpbmdzLm1heFpvb21MZXZlbClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWluWm9vbUxldmVsO1xuICAgICAgICB9XG4gICAgfVxuXTtcblxuZnVuY3Rpb24gVmlld2VyQ29yZShlbGVtZW50LCBvcHRpb25zLCBwdWJsaWNJbnN0YW5jZSlcbntcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhcmVudE9iamVjdCA9ICQoZWxlbWVudCk7XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBjYW5ub3QgYmUgY2hhbmdlZCBiZWNhdXNlIG9mIHRoZSB3YXkgdGhleSBhcmUgdXNlZCBieSB0aGUgc2NyaXB0XG4gICAgLy8gTWFueSBvZiB0aGVzZSBhcmUgZGVjbGFyZWQgd2l0aCBhcmJpdHJhcnkgdmFsdWVzIHRoYXQgYXJlIGNoYW5nZWQgbGF0ZXIgb25cbiAgICB2YXIgdmlld2VyU3RhdGUgPSB7XG4gICAgICAgIGN1cnJlbnRQYWdlSW5kZXg6IDAsICAgICAgICAvLyBUaGUgY3VycmVudCBwYWdlIGluIHRoZSB2aWV3cG9ydCAoY2VudGVyLW1vc3QgcGFnZSlcbiAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogMCwgICAgICAgIC8vIERpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZGl2YSBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICBob3Jpem9udGFsUGFkZGluZzogMCwgICAgICAgLy8gRWl0aGVyIHRoZSBmaXhlZCBwYWRkaW5nIG9yIGFkYXB0aXZlIHBhZGRpbmdcbiAgICAgICAgSUQ6IG51bGwsICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmaXggb2YgdGhlIElEcyBvZiB0aGUgZWxlbWVudHMgKHVzdWFsbHkgMS1kaXZhLSlcbiAgICAgICAgaW5pdGlhbEtleVNjcm9sbDogZmFsc2UsICAgIC8vIEhvbGRzIHRoZSBpbml0aWFsIHN0YXRlIG9mIGVuYWJsZUtleVNjcm9sbFxuICAgICAgICBpbml0aWFsU3BhY2VTY3JvbGw6IGZhbHNlLCAgLy8gSG9sZHMgdGhlIGluaXRpYWwgc3RhdGUgb2YgZW5hYmxlU3BhY2VTY3JvbGxcbiAgICAgICAgaW5uZXJFbGVtZW50OiBudWxsLCAgICAgICAgIC8vIFRoZSBuYXRpdmUgLmRpdmEtb3V0ZXIgRE9NIG9iamVjdFxuICAgICAgICBpbm5lck9iamVjdDoge30sICAgICAgICAgICAgLy8gJChzZXR0aW5ncy5JRCArICdpbm5lcicpLCBmb3Igc2VsZWN0aW5nIHRoZSAuZGl2YS1pbm5lciBlbGVtZW50XG4gICAgICAgIGlzQWN0aXZlRGl2YTogdHJ1ZSwgICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IG11bHRpcGxlIGRpdmEgcGFuZXMgZXhpc3Qgb24gdGhlIHNhbWUgcGFnZSwgdGhpcyBzaG91bGQgaGF2ZSBldmVudHMgZnVubmVsZWQgdG8gaXQuXG4gICAgICAgIGlzSUlJRjogZmFsc2UsICAgICAgICAgICAgICAvLyBTcGVjaWZpZXMgd2hldGhlciBvYmplY3REYXRhIGlzIGluIERpdmEgbmF0aXZlIG9yIElJSUYgTWFuaWZlc3QgZm9ybWF0XG4gICAgICAgIGlzU2Nyb2xsYWJsZTogdHJ1ZSwgICAgICAgICAvLyBVc2VkIGluIGVuYWJsZS9kaXNhYmxlU2Nyb2xsYWJsZSBwdWJsaWMgbWV0aG9kc1xuICAgICAgICBpc1pvb21pbmc6IGZhbHNlLCAgICAgICAgICAgLy8gRmxhZyB0byBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgem9vbWluZyBpcyBzdGlsbCBpbiBwcm9ncmVzcywgZm9yIGhhbmRsZVpvb21cbiAgICAgICAgbG9hZGVkOiBmYWxzZSwgICAgICAgICAgICAgIC8vIEEgZmxhZyBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGxvYWRlZCBhbmQgcmVhZHkgdG8gZ28uXG4gICAgICAgIG1hbmlmZXN0OiBudWxsLFxuICAgICAgICBtb2JpbGVXZWJraXQ6IGZhbHNlLCAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSB1c2VyIGlzIG9uIGEgdG91Y2ggZGV2aWNlIChpUGFkL2lQb2QvaVBob25lL0FuZHJvaWQpXG4gICAgICAgIG51bVBhZ2VzOiAwLCAgICAgICAgICAgICAgICAvLyBOdW1iZXIgb2YgcGFnZXMgaW4gdGhlIGFycmF5XG4gICAgICAgIG9sZFpvb21MZXZlbDogLTEsICAgICAgICAgICAvLyBIb2xkcyB0aGUgcHJldmlvdXMgem9vbSBsZXZlbCBhZnRlciB6b29taW5nIGluIG9yIG91dFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBvdXRlckVsZW1lbnQ6IG51bGwsICAgICAgICAgLy8gVGhlIG5hdGl2ZSAuZGl2YS1vdXRlciBET00gb2JqZWN0XG4gICAgICAgIG91dGVyT2JqZWN0OiB7fSwgICAgICAgICAgICAvLyAkKHNldHRpbmdzLklEICsgJ291dGVyJyksIGZvciBzZWxlY3RpbmcgdGhlIC5kaXZhLW91dGVyIGVsZW1lbnRcbiAgICAgICAgcGFnZU92ZXJsYXlzOiBuZXcgUGFnZU92ZXJsYXlNYW5hZ2VyKCksXG4gICAgICAgIHBhZ2VUb29sczogW10sICAgICAgICAgICAgICAvLyBUaGUgcGx1Z2lucyB3aGljaCBhcmUgZW5hYmxlZCBhcyBwYWdlIHRvb2xzXG4gICAgICAgIHBhcmVudE9iamVjdDogcGFyZW50T2JqZWN0LCAvLyBKUXVlcnkgb2JqZWN0IHJlZmVyZW5jaW5nIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0OiBudWxsLCAvLyBSZWZlcmVuY2UgdG8gdGhlIHhociByZXF1ZXN0IHJldHJpZXZpbmcgdGhlIG1hbmlmZXN0LiBVc2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdCBvbiBkZXN0cm95KClcbiAgICAgICAgcGx1Z2luczogW10sICAgICAgICAgICAgICAgIC8vIEZpbGxlZCB3aXRoIHRoZSBlbmFibGVkIHBsdWdpbnMgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgIHJlc2l6ZVRpbWVyOiAtMSwgICAgICAgICAgICAvLyBIb2xkcyB0aGUgSUQgb2YgdGhlIHRpbWVvdXQgdXNlZCB3aGVuIHJlc2l6aW5nIHRoZSB3aW5kb3cgKGZvciBjbGVhcmluZylcbiAgICAgICAgc2Nyb2xsYmFyV2lkdGg6IDAsICAgICAgICAgIC8vIFNldCB0byB0aGUgYWN0dWFsIHNjcm9sbGJhciB3aWR0aCBpbiBpbml0KClcbiAgICAgICAgc2VsZWN0b3I6ICcnLCAgICAgICAgICAgICAgIC8vIFVzZXMgdGhlIGdlbmVyYXRlZCBJRCBwcmVmaXggdG8gZWFzaWx5IHNlbGVjdCBlbGVtZW50c1xuICAgICAgICB0aHJvYmJlclRpbWVvdXRJRDogLTEsICAgICAgLy8gSG9sZHMgdGhlIElEIG9mIHRoZSB0aHJvYmJlciBsb2FkaW5nIHRpbWVvdXRcbiAgICAgICAgdG9vbGJhcjogbnVsbCwgICAgICAgICAgICAgIC8vIEhvbGRzIGFuIG9iamVjdCB3aXRoIHNvbWUgdG9vbGJhci1yZWxhdGVkIGZ1bmN0aW9uc1xuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogMCwgICAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBkaXZhIGVsZW1lbnQgdG8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIHZlcnRpY2FsUGFkZGluZzogMCwgICAgICAgICAvLyBFaXRoZXIgdGhlIGZpeGVkIHBhZGRpbmcgb3IgYWRhcHRpdmUgcGFkZGluZ1xuICAgICAgICB2aWV3SGFuZGxlcjogbnVsbCxcbiAgICAgICAgdmlld3BvcnQ6IG51bGwsICAgICAgICAgICAgIC8vIE9iamVjdCBjYWNoaW5nIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudDogbnVsbCxcbiAgICAgICAgdmlld3BvcnRPYmplY3Q6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIHNldHRpbmdzID0gY3JlYXRlU2V0dGluZ3NWaWV3KFtvcHRpb25zLCB2aWV3ZXJTdGF0ZV0pO1xuXG4gICAgLy8gQWxpYXNlcyBmb3IgY29tcGF0aWJpbHR5XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgICAgICAgLy8gSGVpZ2h0IG9mIHRoZSBkb2N1bWVudCB2aWV3ZXIgcGFuZVxuICAgICAgICBwYW5lbEhlaWdodDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdpZHRoIG9mIHRoZSBkb2N1bWVudCB2aWV3ZXIgcGFuZVxuICAgICAgICBwYW5lbFdpZHRoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnZpZXdwb3J0LndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9uc1ZhbGlkYXRvciA9IG5ldyBWYWxpZGF0aW9uUnVubmVyKHtcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6ICdtYW5pZmVzdCcsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLm1hbmlmZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcblxuICAgICAgICB2YWxpZGF0aW9uczogb3B0aW9uc1ZhbGlkYXRpb25zXG4gICAgfSk7XG5cbiAgICB2YXIgaXNWYWxpZE9wdGlvbiA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNWYWxpZGF0b3IuaXNWYWxpZChrZXksIHZhbHVlLCB2aWV3ZXJTdGF0ZS5vcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1BdHRycyA9IGZ1bmN0aW9uIChpZGVudCwgYmFzZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkZW50LFxuICAgICAgICAgICAgY2xhc3M6ICdkaXZhLScgKyBpZGVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKGF0dHJzLCBiYXNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0UGFnZURhdGEgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBhdHRyaWJ1dGUpXG4gICAge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFuaWZlc3QucGFnZXNbcGFnZUluZGV4XS5kW3NldHRpbmdzLnpvb21MZXZlbF1bYXR0cmlidXRlXTtcbiAgICB9O1xuXG4gICAgLy8gUmVzZXQgc29tZSBzZXR0aW5ncyBhbmQgZW1wdHkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGNsZWFyVmlld2VyID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCA9IDA7XG5cbiAgICAgICAgLy8gQ2xlYXIgYWxsIHRoZSB0aW1lb3V0cyB0byBwcmV2ZW50IHVuZGVzaXJlZCBwYWdlcyBmcm9tIGxvYWRpbmdcbiAgICAgICAgY2xlYXJUaW1lb3V0KHZpZXdlclN0YXRlLnJlc2l6ZVRpbWVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNldHRpbmdzIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy4gTG9hZCB0aGUgdmlld2VyLFxuICAgICAqIGZpcmUgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBjaGFuZ2VkIG9wdGlvbnMuXG4gICAgICovXG4gICAgdmFyIHJlbG9hZFZpZXdlciA9IGZ1bmN0aW9uIChuZXdPcHRpb25zKVxuICAgIHtcbiAgICAgICAgdmFyIHF1ZXVlZEV2ZW50cyA9IFtdO1xuXG4gICAgICAgIG5ld09wdGlvbnMgPSBvcHRpb25zVmFsaWRhdG9yLmdldFZhbGlkYXRlZE9wdGlvbnMoc2V0dGluZ3MsIG5ld09wdGlvbnMpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgem9vbSBsZXZlbCBpZiB2YWxpZCBhbmQgZmlyZSBhIFpvb21MZXZlbERpZENoYW5nZSBldmVudFxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAnem9vbUxldmVsJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9sZFpvb21MZXZlbCA9IHNldHRpbmdzLnpvb21MZXZlbDtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuem9vbUxldmVsID0gbmV3T3B0aW9ucy56b29tTGV2ZWw7XG4gICAgICAgICAgICBxdWV1ZWRFdmVudHMucHVzaChbXCJab29tTGV2ZWxEaWRDaGFuZ2VcIiwgbmV3T3B0aW9ucy56b29tTGV2ZWxdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgcGFnZXMgcGVyIHJvdyBpZiB2YWxpZCBhbmQgZmlyZSBhbiBldmVudFxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAncGFnZXNQZXJSb3cnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5wYWdlc1BlclJvdyA9IG5ld09wdGlvbnMucGFnZXNQZXJSb3c7XG4gICAgICAgICAgICBxdWV1ZWRFdmVudHMucHVzaChbXCJHcmlkUm93TnVtYmVyRGlkQ2hhbmdlXCIsIG5ld09wdGlvbnMucGFnZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB2ZXJ0aWNhbGx5T3JpZW50ZWQgKG5vIGV2ZW50IGZpcmVkKVxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAndmVydGljYWxseU9yaWVudGVkJykpXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLnZlcnRpY2FsbHlPcmllbnRlZCA9IG5ld09wdGlvbnMudmVydGljYWxseU9yaWVudGVkO1xuXG4gICAgICAgIC8vIFNob3cvSGlkZSBub24tcGFnZWQgcGFnZXNcbiAgICAgICAgaWYgKGhhc0NoYW5nZWRPcHRpb24obmV3T3B0aW9ucywgJ3Nob3dOb25QYWdlZFBhZ2VzJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuc2hvd05vblBhZ2VkUGFnZXMgPSBuZXdPcHRpb25zLnNob3dOb25QYWdlZFBhZ2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHBhZ2UgcG9zaXRpb24gKG5vIGV2ZW50IGZpcmVkIGhlcmUpXG4gICAgICAgIGlmICgnZ29EaXJlY3RseVRvJyBpbiBuZXdPcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmdvRGlyZWN0bHlUbyA9IG5ld09wdGlvbnMuZ29EaXJlY3RseVRvO1xuXG4gICAgICAgICAgICBpZiAoJ3ZlcnRpY2FsT2Zmc2V0JyBpbiBuZXdPcHRpb25zKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0ID0gbmV3T3B0aW9ucy52ZXJ0aWNhbE9mZnNldDtcblxuICAgICAgICAgICAgaWYgKCdob3Jpem9udGFsT2Zmc2V0JyBpbiBuZXdPcHRpb25zKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBuZXdPcHRpb25zLmhvcml6b250YWxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGRlZmF1bHQgaXMgdG8gcmVtYWluIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuZ29EaXJlY3RseVRvID0gc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkT3B0aW9uKG5ld09wdGlvbnMsICdpbkdyaWQnKSB8fCBoYXNDaGFuZ2VkT3B0aW9uKG5ld09wdGlvbnMsICdpbkJvb2tMYXlvdXQnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCdpbkdyaWQnIGluIG5ld09wdGlvbnMpXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5pbkdyaWQgPSBuZXdPcHRpb25zLmluR3JpZDtcblxuICAgICAgICAgICAgaWYgKCdpbkJvb2tMYXlvdXQnIGluIG5ld09wdGlvbnMpXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5pbkJvb2tMYXlvdXQgPSBuZXdPcHRpb25zLmluQm9va0xheW91dDtcblxuICAgICAgICAgICAgcXVldWVkRXZlbnRzLnB1c2goW1wiVmlld0RpZFN3aXRjaFwiLCBzZXR0aW5ncy5pbkdyaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHByZXBhcmVNb2RlQ2hhbmdlKCkgZGVwZW5kcyBvbiBpbkdyaWQgYW5kIHRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsT2Zmc2V0IChmb3Igbm93KVxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAnaW5GdWxsc2NyZWVuJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuaW5GdWxsc2NyZWVuID0gbmV3T3B0aW9ucy5pbkZ1bGxzY3JlZW47XG4gICAgICAgICAgICBwcmVwYXJlTW9kZUNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIHF1ZXVlZEV2ZW50cy5wdXNoKFtcIk1vZGVEaWRTd2l0Y2hcIiwgc2V0dGluZ3MuaW5GdWxsc2NyZWVuXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclZpZXdlcigpO1xuICAgICAgICB1cGRhdGVWaWV3SGFuZGxlckFuZFJlbmRlcmluZygpO1xuXG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5yZW5kZXJlcilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhlIHVzYWdlIG9mIHBhZGRpbmcgdmFyaWFibGVzIGlzIHN0aWxsIHJlYWxseVxuICAgICAgICAgICAgLy8gbWVzc3kgYW5kIGluY29uc2lzdGVudFxuICAgICAgICAgICAgdmFyIHJlbmRlcmVyQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHBhZ2VMYXlvdXRzOiBnZXRQYWdlTGF5b3V0cyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgcGFkZGluZzogZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgICAgIG1heFpvb21MZXZlbDogc2V0dGluZ3MuaW5HcmlkID8gbnVsbCA6IHZpZXdlclN0YXRlLm1hbmlmZXN0Lm1heFpvb20sXG4gICAgICAgICAgICAgICAgdmVydGljYWxseU9yaWVudGVkOiBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgfHwgc2V0dGluZ3MuaW5HcmlkLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiBzZXR0aW5ncy5pbkdyaWQgPyBudWxsIDogc2V0dGluZ3Muem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHNldHRpbmdzLmdvRGlyZWN0bHlUbyxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogdmlld2VyU3RhdGUuaG9yaXpvbnRhbE9mZnNldFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNvdXJjZVByb3ZpZGVyID0gZ2V0Q3VycmVudFNvdXJjZVByb3ZpZGVyKCk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gT2JqZWN0LmtleXMocmVuZGVyZXJDb25maWcpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9vIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgIT09ICdwYWdlTGF5b3V0cycgJiYga2V5ICE9PSAncGFkZGluZyc7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVuZGVyZXJDb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnKCdyZWxvYWQgd2l0aCAlcycsIHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sb2FkKHJlbmRlcmVyQ29uZmlnLCB2aWV3cG9ydFBvc2l0aW9uLCBzb3VyY2VQcm92aWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1zKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaGFzQ2hhbmdlZE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4ga2V5IGluIG9wdGlvbnMgJiYgb3B0aW9uc1trZXldICE9PSBzZXR0aW5nc1trZXldO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGVzIHN3aXRjaGluZyBpbiBhbmQgb3V0IG9mIGZ1bGxzY3JlZW4gbW9kZVxuICAgIHZhciBwcmVwYXJlTW9kZUNoYW5nZSA9IGZ1bmN0aW9uIChvcHRpb25zKVxuICAgIHtcbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBjbGFzc2VzXG4gICAgICAgIHZhciBjaGFuZ2VDbGFzcyA9IG9wdGlvbnMuaW5GdWxsc2NyZWVuID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHZpZXdlclN0YXRlLm91dGVyT2JqZWN0W2NoYW5nZUNsYXNzXSgnZGl2YS1mdWxsc2NyZWVuJyk7XG4gICAgICAgICQoJ2JvZHknKVtjaGFuZ2VDbGFzc10oJ2RpdmEtaGlkZS1zY3JvbGxiYXInKTtcbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0W2NoYW5nZUNsYXNzXSgnZGl2YS1mdWxsLXdpZHRoJyk7XG5cbiAgICAgICAgLy8gQWRqdXN0IERpdmEncyBpbnRlcm5hbCBwYW5lbCBzaXplLCBrZWVwaW5nIHRoZSBvbGQgdmFsdWVzXG4gICAgICAgIHZhciBzdG9yZWRIZWlnaHQgPSBzZXR0aW5ncy5wYW5lbEhlaWdodDtcbiAgICAgICAgdmFyIHN0b3JlZFdpZHRoID0gc2V0dGluZ3MucGFuZWxXaWR0aDtcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgdGhlIG9yaWdpbmFsIGxvYWQsIHRoZSBvZmZzZXRzIG1hdHRlciwgYW5kIHRoZSBwb3NpdGlvbiBpc24ndCBiZWluZyBjaGFuZ2VkLi4uXG4gICAgICAgIGlmICghdmlld2VyU3RhdGUubG9hZGVkICYmICFzZXR0aW5ncy5pbkdyaWQgJiYgISgndmVydGljYWxPZmZzZXQnIGluIG9wdGlvbnMpKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL2dldCB0aGUgdXBkYXRlZCBwYW5lbCBzaXplXG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gc2V0dGluZ3MucGFuZWxIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBzZXR0aW5ncy5wYW5lbFdpZHRoO1xuXG4gICAgICAgICAgICAvL2FuZCByZS1jZW50ZXIgdGhlIG5ldyBwYW5lbCBvbiB0aGUgc2FtZSBwb2ludFxuICAgICAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQgKz0gKChzdG9yZWRIZWlnaHQgLSBuZXdIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0ICs9ICgoc3RvcmVkV2lkdGggLSBuZXdXaWR0aCkgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdHVybiBvbi9vZmYgZXNjYXBlIGtleSBsaXN0ZW5lclxuICAgICAgICBpZiAob3B0aW9ucy5pbkZ1bGxzY3JlZW4pXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbigna2V5dXAnLCBlc2NhcGVMaXN0ZW5lcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZigna2V5dXAnLCBlc2NhcGVMaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBoYW5kbGVyIGFuZCB0aGUgdmlldyByZW5kZXJpbmcgZm9yIHRoZSBjdXJyZW50IHZpZXdcbiAgICB2YXIgdXBkYXRlVmlld0hhbmRsZXJBbmRSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIEhhbmRsZXIgPSBzZXR0aW5ncy5pbkdyaWQgPyBHcmlkSGFuZGxlciA6IERvY3VtZW50SGFuZGxlcjtcblxuICAgICAgICBpZiAodmlld2VyU3RhdGUudmlld0hhbmRsZXIgJiYgISh2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlciBpbnN0YW5jZW9mIEhhbmRsZXIpKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZpZXdlclN0YXRlLnZpZXdIYW5kbGVyKVxuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld0hhbmRsZXIgPSBuZXcgSGFuZGxlcihzZWxmKTtcblxuICAgICAgICBpZiAoIXZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICAgICAgaW5pdGlhbGl6ZVJlbmRlcmVyKCk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgcHJvYmFibHkgYmUgZG9uZSB1cG9uIFZpZXdlckNvcmUgaW5pdGlhbGl6YXRpb25cbiAgICB2YXIgaW5pdGlhbGl6ZVJlbmRlcmVyID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjb21wYXRFcnJvcnMgPSBSZW5kZXJlci5nZXRDb21wYXRpYmlsaXR5RXJyb3JzKCk7XG5cbiAgICAgICAgaWYgKGNvbXBhdEVycm9ycylcbiAgICAgICAge1xuICAgICAgICAgICAgc2hvd0Vycm9yKGNvbXBhdEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogdmlld2VyU3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAgICAgb3V0ZXJFbGVtZW50OiB2aWV3ZXJTdGF0ZS5vdXRlckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5uZXJFbGVtZW50OiB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBob29rcyA9IHtcbiAgICAgICAgICAgICAgICBvblZpZXdXaWxsTG9hZDogZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld1dpbGxMb2FkKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblZpZXdEaWRMb2FkOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld0RpZExvYWQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uVmlld0RpZFVwZGF0ZTogZnVuY3Rpb24gKHBhZ2VzLCB0YXJnZXRQYWdlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld0RpZFVwZGF0ZShwYWdlcywgdGFyZ2V0UGFnZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblZpZXdEaWRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhZ2VXaWxsTG9hZDogZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2goJ1BhZ2VXaWxsTG9hZCcsIHBhZ2VJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIob3B0aW9ucywgaG9va3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRDdXJyZW50U291cmNlUHJvdmlkZXIgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmluR3JpZClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyaWRTb3VyY2VQcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBnZXRBbGxab29tTGV2ZWxzRm9yUGFnZTogZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2dyaWRTb3VyY2VQcm92aWRlci5nZXRCZXN0Wm9vbUxldmVsRm9yUGFnZShwYWdlKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRCZXN0Wm9vbUxldmVsRm9yUGFnZTogZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gc2V0dGluZ3MubWFuaWZlc3QuZ2V0UGFnZUltYWdlVVJMKHBhZ2UuaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYWdlLmRpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbDogMSwgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsOiAxLCAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZS5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBncmlkU291cmNlUHJvdmlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlsZURpbWVucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBzZXR0aW5ncy50aWxlV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNldHRpbmdzLnRpbGVIZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0QmVzdFpvb21MZXZlbEZvclBhZ2U6IGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5nZXRQYWdlSW1hZ2VUaWxlcyhwYWdlLmluZGV4LCBNYXRoLmNlaWwoc2V0dGluZ3Muem9vbUxldmVsKSwgdGlsZURpbWVucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QWxsWm9vbUxldmVsc0ZvclBhZ2U6IGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBsZXZlbENvdW50ID0gdmlld2VyU3RhdGUubWFuaWZlc3QubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsZXZlbD0wOyBsZXZlbCA8PSBsZXZlbENvdW50OyBsZXZlbCsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxzLnB1c2goc2V0dGluZ3MubWFuaWZlc3QuZ2V0UGFnZUltYWdlVGlsZXMocGFnZS5pbmRleCwgbGV2ZWwsIHRpbGVEaW1lbnMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXZlbHMucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFBhZGRpbmcgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHRvcFBhZGRpbmcsIGxlZnRQYWRkaW5nO1xuICAgICAgICB2YXIgZG9jVlBhZGRpbmcsIGRvY0hQYWRkaW5nO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5pbkdyaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRvY1ZQYWRkaW5nID0gc2V0dGluZ3MuZml4ZWRQYWRkaW5nO1xuICAgICAgICAgICAgdG9wUGFkZGluZyA9IGxlZnRQYWRkaW5nID0gZG9jSFBhZGRpbmcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdG9wUGFkZGluZyA9IHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCA/IHZpZXdlclN0YXRlLnZlcnRpY2FsUGFkZGluZyA6IDA7XG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCA/IDAgOiB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgICAgICAgZG9jVlBhZGRpbmcgPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyAwIDogdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgZG9jSFBhZGRpbmcgPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB0b3A6IGRvY1ZQYWRkaW5nLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogZG9jVlBhZGRpbmcsXG4gICAgICAgICAgICAgICAgbGVmdDogZG9jSFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGRvY0hQYWRkaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wUGFkZGluZyxcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVBhZ2VPdmVybGF5cyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2aWV3ZXJTdGF0ZS5wYWdlT3ZlcmxheXMudXBkYXRlT3ZlcmxheXModmlld2VyU3RhdGUucmVuZGVyZXIuZ2V0UmVuZGVyZWRQYWdlcygpKTtcbiAgICB9O1xuXG4gICAgLy9TaG9ydGN1dCBmb3IgY2xvc2luZyBmdWxsc2NyZWVuIHdpdGggdGhlIGVzY2FwZSBrZXlcbiAgICB2YXIgZXNjYXBlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSlcbiAgICB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgaW5GdWxsc2NyZWVuOiAhc2V0dGluZ3MuaW5GdWxsc2NyZWVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDYWxsZWQgdG8gaGFuZGxlIGFueSB6b29tIGxldmVsXG4gICAgdmFyIGhhbmRsZVpvb20gPSBmdW5jdGlvbiAobmV3Wm9vbUxldmVsLCBmb2NhbFBvaW50KVxuICAgIHtcbiAgICAgICAgLy8gSWYgdGhlIHpvb20gbGV2ZWwgcHJvdmlkZWQgaXMgaW52YWxpZCwgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICghaXNWYWxpZE9wdGlvbignem9vbUxldmVsJywgbmV3Wm9vbUxldmVsKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBJZiBubyBmb2NhbCBwb2ludCB3YXMgZ2l2ZW4sIHpvb20gb24gdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgaWYgKGZvY2FsUG9pbnQgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gdmlld2VyU3RhdGUudmlld3BvcnQ7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlZ2lvbiA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlUmVnaW9uKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgpO1xuXG4gICAgICAgICAgICBmb2NhbFBvaW50ID0ge1xuICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICh2aWV3cG9ydC53aWR0aCAvIDIpIC0gKGN1cnJlbnRSZWdpb24ubGVmdCAtIHZpZXdwb3J0LmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6ICh2aWV3cG9ydC5oZWlnaHQgLyAyKSAtIChjdXJyZW50UmVnaW9uLnRvcCAtIHZpZXdwb3J0LnRvcClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZ2VSZWdpb24gPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sYXlvdXQuZ2V0UGFnZVJlZ2lvbihmb2NhbFBvaW50LmFuY2hvclBhZ2UpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIGN1cnNvciBjb29yZGluYXRlcyB0byBjZW50ZXIgb2Ygdmlld3BvcnRcbiAgICAgICAgdmFyIGZvY2FsWFRvQ2VudGVyID0gKHBhZ2VSZWdpb24ubGVmdCArIGZvY2FsUG9pbnQub2Zmc2V0LmxlZnQpIC1cbiAgICAgICAgICAgIChzZXR0aW5ncy52aWV3cG9ydC5sZWZ0ICsgKHNldHRpbmdzLnZpZXdwb3J0LndpZHRoIC8gMikpO1xuICAgICAgICB2YXIgZm9jYWxZVG9DZW50ZXIgPSAocGFnZVJlZ2lvbi50b3AgKyBmb2NhbFBvaW50Lm9mZnNldC50b3ApIC1cbiAgICAgICAgICAgIChzZXR0aW5ncy52aWV3cG9ydC50b3AgKyAoc2V0dGluZ3Mudmlld3BvcnQuaGVpZ2h0IC8gMikpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKHpvb21MZXZlbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHpvb21SYXRpbyA9IE1hdGgucG93KDIsIHpvb21MZXZlbCAtIGluaXRpYWxab29tTGV2ZWwpO1xuXG4gICAgICAgICAgICAvL1RPRE8oamVyb21lcGwpOiBDYWxjdWxhdGUgcG9zaXRpb24gZnJvbSBwYWdlIHRvcCBsZWZ0IHRvIHZpZXdwb3J0IHRvcCBsZWZ0XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgaG9yaXpvbnRhbC92ZXJ0aWNhbE9mZnNldDogZGlzdGFuY2UgZnJvbSB2aWV3cG9ydCBjZW50ZXIgdG8gcGFnZSB1cHBlciBsZWZ0IGNvcm5lclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSAoZm9jYWxQb2ludC5vZmZzZXQubGVmdCAqIHpvb21SYXRpbykgLSBmb2NhbFhUb0NlbnRlcjtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IChmb2NhbFBvaW50Lm9mZnNldC50b3AgKiB6b29tUmF0aW8pIC0gZm9jYWxZVG9DZW50ZXI7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiB6b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgYW5jaG9yUGFnZTogZm9jYWxQb2ludC5hbmNob3JQYWdlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRpYWxab29tTGV2ZWwgPSB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPSBzZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuem9vbUxldmVsID0gbmV3Wm9vbUxldmVsO1xuXG4gICAgICAgIHZhciBlbmRQb3NpdGlvbiA9IGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKG5ld1pvb21MZXZlbCk7XG4gICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuZ29EaXJlY3RseVRvID0gZW5kUG9zaXRpb24uYW5jaG9yUGFnZTtcbiAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQgPSBlbmRQb3NpdGlvbi52ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgdmlld2VyU3RhdGUuaG9yaXpvbnRhbE9mZnNldCA9IGVuZFBvc2l0aW9uLmhvcml6b250YWxPZmZzZXQ7XG5cbiAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIudHJhbnNpdGlvblZpZXdwb3J0UG9zaXRpb24oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogaW5pdGlhbFpvb21MZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgdG86IG5ld1pvb21MZXZlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBhcmFtZXRlcnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKHBhcmFtZXRlcnMuem9vbUxldmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVuZDogZnVuY3Rpb24gKGluZm8pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRPYmplY3Quc2Nyb2xsKHNjcm9sbEZ1bmN0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmZvLmludGVycnVwdGVkKVxuICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPSBuZXdab29tTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2xpZGVyXG4gICAgICAgIHB1Ymxpc2goXCJab29tTGV2ZWxEaWRDaGFuZ2VcIiwgbmV3Wm9vbUxldmVsKTtcblxuICAgICAgICAvLyBXaGlsZSB6b29taW5nLCBkb24ndCB1cGRhdGUgc2Nyb2xsIG9mZnNldHMgYmFzZWQgb24gdGhlIHNjYWxlZCB2ZXJzaW9uIG9mIGRpdmEtaW5uZXJcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRPYmplY3Qub2ZmKCdzY3JvbGwnKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgR2V0cyB0aGUgWS1vZmZzZXQgZm9yIGEgc3BlY2lmaWMgcG9pbnQgb24gYSBzcGVjaWZpYyBwYWdlXG4gICAgIEFjY2VwdGFibGUgdmFsdWVzIGZvciBcImFuY2hvclwiOlxuICAgICBcInRvcFwiIChkZWZhdWx0KSAtIHdpbGwgYW5jaG9yIHRvcCBvZiB0aGUgcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBkaXZhLW91dGVyIGVsZW1lbnRcbiAgICAgXCJib3R0b21cIiAtIHRvcCwgcy90b3AvYm90dG9tXG4gICAgIFwiY2VudGVyXCIgLSB3aWxsIGNlbnRlciB0aGUgcGFnZSBvbiB0aGUgZGl2YSBlbGVtZW50XG4gICAgIFJldHVybmVkIHZhbHVlIHdpbGwgYmUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZGl2YS1vdXRlciBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIGN1cnJlbnQgcGFnZSBmb3IgdGhlIHNwZWNpZmllZCBhbmNob3JcbiAgICAgKi9cbiAgICB2YXIgZ2V0WU9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIGFuY2hvcilcbiAgICB7XG4gICAgICAgIHBhZ2VJbmRleCA9ICh0eXBlb2YocGFnZUluZGV4KSA9PT0gXCJ1bmRlZmluZWRcIiA/IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXggOiBwYWdlSW5kZXgpO1xuXG4gICAgICAgIGlmIChhbmNob3IgPT09IFwiY2VudGVyXCIgfHwgYW5jaG9yID09PSBcImNlbnRyZVwiKSAvL2hvdyB5b3UgY2FuIHRlbGwgYW4gQW1lcmljYW4gY29kZWQgdGhpc1xuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcImhcIikgLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5jaG9yID09PSBcImJvdHRvbVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcImhcIikgLSBzZXR0aW5ncy5wYW5lbEhlaWdodCAvIDIsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzZXR0aW5ncy5wYW5lbEhlaWdodCAvIDIsIDEwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1NhbWUgYXMgZ2V0WU9mZnNldCB3aXRoIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIgYXMgYWNjZXB0YWJsZSB2YWx1ZXMgaW5zdGVhZCBvZiBcInRvcFwiIGFuZCBcImJvdHRvbVwiXG4gICAgdmFyIGdldFhPZmZzZXQgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBhbmNob3IpXG4gICAge1xuICAgICAgICBwYWdlSW5kZXggPSAodHlwZW9mKHBhZ2VJbmRleCkgPT09IFwidW5kZWZpbmVkXCIgPyBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4IDogcGFnZUluZGV4KTtcblxuICAgICAgICBpZiAoYW5jaG9yID09PSBcImxlZnRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNldHRpbmdzLnBhbmVsV2lkdGggLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5jaG9yID09PSBcInJpZ2h0XCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChnZXRQYWdlRGF0YShwYWdlSW5kZXgsIFwid1wiKSAtIHNldHRpbmdzLnBhbmVsV2lkdGggLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcIndcIikgLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdXBkYXRlcyBwYW5lbEhlaWdodC9wYW5lbFdpZHRoIG9uIHJlc2l6ZVxuICAgIHZhciB1cGRhdGVQYW5lbFNpemUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIC8vIEZJWE1FKHdhYmFpbik6IFRoaXMgc2hvdWxkIHJlYWxseSBvbmx5IGJlIGNhbGxlZCBhZnRlciBpbml0aWFsIGxvYWRcbiAgICAgICAgaWYgKHZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVPZmZzZXRzKCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nb3RvKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0LCB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlT2Zmc2V0cyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCB2aWV3ZXJTdGF0ZS52aWV3cG9ydCk7XG5cbiAgICAgICAgaWYgKHBhZ2VPZmZzZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBwYWdlT2Zmc2V0Lng7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbE9mZnNldCA9IHBhZ2VPZmZzZXQueTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBCaW5kIG1vdXNlIGV2ZW50cyAoZHJhZyB0byBzY3JvbGwsIGRvdWJsZS1jbGljaylcbiAgICB2YXIgYmluZE1vdXNlRXZlbnRzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gU2V0IGRyYWcgc2Nyb2xsIG9uIGZpcnN0IGRlc2NlbmRhbnQgb2YgY2xhc3MgZHJhZ2dlciBvbiBib3RoIHNlbGVjdGVkIGVsZW1lbnRzXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6ICcuZGl2YS1kcmFnZ2VyJywgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHZpZXdlclN0YXRlLmlubmVyT2JqZWN0LmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6ICcuZGl2YS1kcmFnZ2VyJywgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlfSk7XG5cbiAgICAgICAgZ2VzdHVyZUV2ZW50cy5vbkRvdWJsZUNsaWNrKHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LCBmdW5jdGlvbiAoZXZlbnQsIGNvb3JkcylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVidWcoJ0RvdWJsZSBjbGljayBhdCAlcywgJXMnLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlci5vbkRvdWJsZUNsaWNrKGV2ZW50LCBjb29yZHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG9uUmVzaXplID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdXBkYXRlUGFuZWxTaXplKCk7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgcHJldmlvdXNseS1zZXQgcmVzaXplIHRpbWVvdXRzXG4gICAgICAgIGNsZWFyVGltZW91dCh2aWV3ZXJTdGF0ZS5yZXNpemVUaW1lcik7XG5cbiAgICAgICAgdmlld2VyU3RhdGUucmVzaXplVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0LmdldFBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZpZXdwb3J0KTtcblxuICAgICAgICAgICAgaWYgKHBhZ2VPZmZzZXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICAgICAgZ29EaXJlY3RseVRvOiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogcGFnZU9mZnNldC55LFxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBwYWdlT2Zmc2V0LnhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICBnb0RpcmVjdGx5VG86IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9O1xuXG4gICAgLy8gQmluZCB0b3VjaCBhbmQgb3JpZW50YXRpb24gY2hhbmdlIGV2ZW50c1xuICAgIHZhciBiaW5kVG91Y2hFdmVudHMgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICAvLyBCbG9jayB0aGUgdXNlciBmcm9tIG1vdmluZyB0aGUgd2luZG93IG9ubHkgaWYgaXQncyBub3QgaW50ZWdyYXRlZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYmxvY2tNb2JpbGVNb3ZlKVxuICAgICAgICB7XG4gICAgICAgICAgICAkKCdib2R5JykuYmluZCgndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlID0gZXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvdWNoIGV2ZW50cyBmb3Igc3dpcGluZyBpbiB0aGUgdmlld3BvcnQgdG8gc2Nyb2xsIHBhZ2VzXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LmtpbmV0aWMoe1xuICAgICAgICAgICAgdHJpZ2dlckhhcmR3YXJlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdlc3R1cmVFdmVudHMub25QaW5jaCh2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCwgZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMsIHN0YXJ0LCBlbmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlYnVnKCdQaW5jaCAlcyBhdCAlcywgJXMnLCBlbmQgLSBzdGFydCwgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld0hhbmRsZXIub25QaW5jaChldmVudCwgY29vcmRzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2VzdHVyZUV2ZW50cy5vbkRvdWJsZVRhcCh2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCwgZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlYnVnKCdEb3VibGUgdGFwIGF0ICVzLCAlcycsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uRG91YmxlQ2xpY2soZXZlbnQsIGNvb3Jkcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGhlIHNjcm9sbFxuICAgIHZhciBzY3JvbGxGdW5jdGlvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgcHJldmlvdXNUb3BTY3JvbGwgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3A7XG4gICAgICAgIHZhciBwcmV2aW91c0xlZnRTY3JvbGwgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5sZWZ0O1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3A7XG4gICAgICAgIHZhciBuZXdTY3JvbGxMZWZ0ID0gdmlld2VyU3RhdGUudmlld3BvcnQubGVmdDtcblxuICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkIHx8IHNldHRpbmdzLmluR3JpZClcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ld1Njcm9sbFRvcCAtIHByZXZpb3VzVG9wU2Nyb2xsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXdTY3JvbGxMZWZ0IC0gcHJldmlvdXNMZWZ0U2Nyb2xsO1xuXG4gICAgICAgIC8vZ2l2ZSBhZGp1c3QgdGhlIGRpcmVjdGlvbiB3ZSBjYXJlIGFib3V0XG4gICAgICAgIHZpZXdlclN0YXRlLnJlbmRlcmVyLmFkanVzdChkaXJlY3Rpb24pO1xuXG4gICAgICAgIHZhciBwcmltYXJ5U2Nyb2xsID0gKHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCB8fCBzZXR0aW5ncy5pbkdyaWQpID8gbmV3U2Nyb2xsVG9wIDogbmV3U2Nyb2xsTGVmdDtcblxuICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsXCIsIHByaW1hcnlTY3JvbGwpO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsRG93blwiLCBwcmltYXJ5U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsVXBcIiwgcHJpbWFyeVNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXRzKCk7XG4gICAgfTtcblxuICAgIC8vIEJpbmRzIG1vc3Qgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIChzb21lIG1vcmUgaW4gY3JlYXRlVG9vbGJhcilcbiAgICB2YXIgaGFuZGxlRXZlbnRzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3Vyc29yIGZvciBkcmFnZ2luZ1xuICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC5tb3VzZWRvd24oZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJPYmplY3QuYWRkQ2xhc3MoJ2RpdmEtZ3JhYmJpbmcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJPYmplY3QubW91c2V1cChmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC5yZW1vdmVDbGFzcygnZGl2YS1ncmFiYmluZycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBiaW5kTW91c2VFdmVudHMoKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdC5zY3JvbGwoc2Nyb2xsRnVuY3Rpb24pO1xuXG4gICAgICAgIHZhciB1cEFycm93S2V5ID0gMzgsXG4gICAgICAgICAgICBkb3duQXJyb3dLZXkgPSA0MCxcbiAgICAgICAgICAgIGxlZnRBcnJvd0tleSA9IDM3LFxuICAgICAgICAgICAgcmlnaHRBcnJvd0tleSA9IDM5LFxuICAgICAgICAgICAgc3BhY2VLZXkgPSAzMixcbiAgICAgICAgICAgIHBhZ2VVcEtleSA9IDMzLFxuICAgICAgICAgICAgcGFnZURvd25LZXkgPSAzNCxcbiAgICAgICAgICAgIGhvbWVLZXkgPSAzNixcbiAgICAgICAgICAgIGVuZEtleSA9IDM1O1xuXG4gICAgICAgIC8vIENhdGNoIHRoZSBrZXkgcHJlc3NlcyBpbiBkb2N1bWVudFxuICAgICAgICAkKGRvY3VtZW50KS5vbigna2V5ZG93bi5kaXZhJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXZpZXdlclN0YXRlLmlzQWN0aXZlRGl2YSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gU3BhY2Ugb3IgcGFnZSBkb3duIC0gZ28gdG8gdGhlIG5leHQgcGFnZVxuICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5lbmFibGVTcGFjZVNjcm9sbCAmJiAhZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gc3BhY2VLZXkpIHx8IChzZXR0aW5ncy5lbmFibGVLZXlTY3JvbGwgJiYgZXZlbnQua2V5Q29kZSA9PT0gcGFnZURvd25LZXkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCArPSBzZXR0aW5ncy5wYW5lbEhlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc2V0dGluZ3MuZW5hYmxlU3BhY2VTY3JvbGwgJiYgZXZlbnQua2V5Q29kZSA9PT0gc3BhY2VLZXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZUtleVNjcm9sbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdGVhbCBrZXlib2FyZCBzaG9ydGN1dHMgKG1ldGFLZXkgPSBjb21tYW5kIFtPUyBYXSwgc3VwZXIgW1dpbi9MaW51eF0pXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHBhZ2VVcEtleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgdXAgLSBnbyB0byB0aGUgcHJldmlvdXMgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQudG9wIC09IHNldHRpbmdzLnBhbmVsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdXBBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwIGFycm93IC0gc2Nyb2xsIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3AgLT0gc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBkb3duQXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb3duIGFycm93IC0gc2Nyb2xsIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCArPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIGxlZnRBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgYXJyb3cgLSBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQubGVmdCAtPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIHJpZ2h0QXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCBhcnJvdyAtIHNjcm9sbCByaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQubGVmdCArPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIGhvbWVLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb21lIGtleSAtIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZW5kS2V5OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGtleSAtIGdvIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBvbiB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSB2YWx1ZSBiZWluZyBub3JtYWxpemVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LmxlZnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJEaWRUZXJtaW5hdGUnLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZigna2V5ZG93bi5kaXZhJyk7XG4gICAgICAgIH0sIHNldHRpbmdzLklEKTtcblxuICAgICAgICBiaW5kVG91Y2hFdmVudHMoKTtcblxuICAgICAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6aW5nIGV2ZW50c1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKTtcblxuICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1ZpZXdlckRpZFRlcm1pbmF0ZScsIGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgIH0sIHNldHRpbmdzLklEKTtcblxuICAgICAgICAvLyBIYW5kbGUgb3JpZW50YXRpb24gY2hhbmdlIHNlcGFyYXRlbHlcbiAgICAgICAgaWYgKCdvbm9yaWVudGF0aW9uY2hhbmdlJyBpbiB3aW5kb3cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkVGVybWluYXRlJywgZnVuY3Rpb24oKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICB9LCBzZXR0aW5ncy5JRCk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1BhbmVsU2l6ZURpZENoYW5nZScsIHVwZGF0ZVBhbmVsU2l6ZSwgc2V0dGluZ3MuSUQpO1xuXG4gICAgICAgIC8vIENsZWFyIHBhZ2UgYW5kIHJlc2l6ZSB0aW1lb3V0cyB3aGVuIHRoZSB2aWV3ZXIgaXMgZGVzdHJveWVkXG4gICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkVGVybWluYXRlJywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnJlbmRlcmVyLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHZpZXdlclN0YXRlLnJlc2l6ZVRpbWVyKTtcbiAgICAgICAgfSwgc2V0dGluZ3MuSUQpO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdFBsdWdpbnMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gQWRkIGFsbCB0aGUgcGx1Z2lucyB0aGF0IGhhdmUgbm90IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCB0b1xuICAgICAgICAvLyBzZXR0aW5ncy5wbHVnaW5zXG4gICAgICAgIFBsdWdpblJlZ2lzdHJ5LmdldEFsbCgpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBsdWdpblByb3Blck5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgcGx1Z2luLnBsdWdpbk5hbWUuc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NbJ2VuYWJsZScgKyBwbHVnaW5Qcm9wZXJOYW1lXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBpbml0IGZ1bmN0aW9uIGFuZCBjaGVjayByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgZW5hYmxlUGx1Z2luID0gcGx1Z2luLmluaXQoc2V0dGluZ3MsIHB1YmxpY0luc3RhbmNlKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGludCByZXR1cm5zIGZhbHNlLCBjb25zaWRlciB0aGUgcGx1Z2luIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVQbHVnaW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcGFnZVRvb2xzIGJhciBpZiBoYW5kbGVDbGljayBpcyBzZXQgdG8gYSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmhhbmRsZUNsaWNrID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUucGFnZVRvb2xzLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gc2V0dGluZ3MucGx1Z2lucyBzbyBpdCBjYW4gYmUgdXNlZCBsYXRlclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHNob3dUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS50aHJvYmJlclRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICd0aHJvYmJlcicpLnNob3coKTtcbiAgICAgICAgfSwgc2V0dGluZ3MudGhyb2JiZXJUaW1lb3V0KTtcbiAgICB9O1xuXG4gICAgdmFyIGhpZGVUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBDbGVhciB0aGUgdGltZW91dCwgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldFxuICAgICAgICBjbGVhclRpbWVvdXQodmlld2VyU3RhdGUudGhyb2JiZXJUaW1lb3V0SUQpO1xuXG4gICAgICAgIC8vIEhpZGUgdGhlIHRocm9iYmVyIGlmIGl0IGhhcyBhbHJlYWR5IGV4ZWN1dGVkXG4gICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAndGhyb2JiZXInKS5oaWRlKCk7XG4gICAgfTtcblxuICAgIHZhciBzaG93RXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgdmFyIGVycm9yRWxlbWVudCA9IGVsdCgnZGl2JywgZWxlbUF0dHJzKCdlcnJvcicpLCBbXG4gICAgICAgICAgICBlbHQoJ2J1dHRvbicsIGVsZW1BdHRycygnZXJyb3ItY2xvc2UnLCB7J2FyaWEtbGFiZWwnOiAnQ2xvc2UgZGlhbG9nJ30pKSxcbiAgICAgICAgICAgIGVsdCgncCcsXG4gICAgICAgICAgICAgICAgZWx0KCdzdHJvbmcnLCAnRXJyb3InKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGVsdCgnZGl2JywgbWVzc2FnZSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QuYXBwZW5kKGVycm9yRWxlbWVudCk7XG5cbiAgICAgICAgLy9iaW5kIGRpYWxvZyBjbG9zZSBidXR0b25cbiAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICdlcnJvci1jbG9zZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgZXJyb3JFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZXJyb3JFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBzZXRNYW5pZmVzdCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgaXNJSUlGLCBsb2FkT3B0aW9ucylcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG5cbiAgICAgICAgLy8gRklYTUU6IGlzIGlzSUlJRiBldmVuIG5lZWRlZD9cbiAgICAgICAgdmlld2VyU3RhdGUuaXNJSUlGID0gaXNJSUlGO1xuXG4gICAgICAgIGhpZGVUaHJvYmJlcigpO1xuXG4gICAgICAgIC8vIENvbnZlbmllbmNlIHZhbHVlXG4gICAgICAgIHZpZXdlclN0YXRlLm51bVBhZ2VzID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXMubGVuZ3RoO1xuXG4gICAgICAgIG9wdGlvbnNWYWxpZGF0b3IudmFsaWRhdGUodmlld2VyU3RhdGUub3B0aW9ucyk7XG5cbiAgICAgICAgcHVibGlzaCgnTnVtYmVyT2ZQYWdlc0RpZENoYW5nZScsIHNldHRpbmdzLm51bVBhZ2VzKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlQXV0b1RpdGxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoJChzZXR0aW5ncy5zZWxlY3RvciArICd0aXRsZScpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ3RpdGxlJykuaHRtbChzZXR0aW5ncy5tYW5pZmVzdC5pdGVtVGl0bGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBhcmVudE9iamVjdC5wcmVwZW5kKGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0aXRsZScpLCBbc2V0dGluZ3MubWFuaWZlc3QuaXRlbVRpdGxlXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBpbnRlci1wYWdlIHBhZGRpbmcgYmFzZWQgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGF2ZXJhZ2Ugem9vbSBsZXZlbFxuICAgICAgICBpZiAoc2V0dGluZ3MuYWRhcHRpdmVQYWRkaW5nID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmZsb29yKChzZXR0aW5ncy5taW5ab29tTGV2ZWwgKyBzZXR0aW5ncy5tYXhab29tTGV2ZWwpIC8gMik7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA9IHBhcnNlSW50KHNldHRpbmdzLm1hbmlmZXN0LmdldEF2ZXJhZ2VXaWR0aCh6KSAqIHNldHRpbmdzLmFkYXB0aXZlUGFkZGluZywgMTApO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nID0gcGFyc2VJbnQoc2V0dGluZ3MubWFuaWZlc3QuZ2V0QXZlcmFnZUhlaWdodCh6KSAqIHNldHRpbmdzLmFkYXB0aXZlUGFkZGluZywgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSXQncyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMDsgdXNlIGZpeGVkUGFkZGluZyBpbnN0ZWFkXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA9IHNldHRpbmdzLmZpeGVkUGFkZGluZztcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsUGFkZGluZyA9IHNldHRpbmdzLmZpeGVkUGFkZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmVydGljYWwgcGFkZGluZyBpcyBhdCBsZWFzdCA0MCwgaWYgcGx1Z2luIGljb25zIGFyZSBlbmFibGVkXG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5wYWdlVG9vbHMubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbFBhZGRpbmcgPSBNYXRoLm1heCg0MCwgdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGRldGVjdCBhIHZpZXdpbmdIaW50IG9mICdwYWdlZCcgaW4gdGhlIG1hbmlmZXN0IG9yIHNlcXVlbmNlLCBlbmFibGUgYm9vayB2aWV3IGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmluQm9va0xheW91dCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQbHVnaW4gc2V0dXAgaG9va3Mgc2hvdWxkIGJlIGJvdW5kIHRvIHRoZSBPYmplY3REaWRMb2FkIGV2ZW50XG4gICAgICAgIHB1Ymxpc2goJ09iamVjdERpZExvYWQnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSBkb2N1bWVudCBwYW5lbCBkaW1lbnNpb25zXG4gICAgICAgIHVwZGF0ZVBhbmVsU2l6ZSgpO1xuXG4gICAgICAgIHZhciBuZWVkc1hDb29yZCwgbmVlZHNZQ29vcmQ7XG5cbiAgICAgICAgdmFyIGFuY2hvcmVkVmVydGljYWxseSA9IGZhbHNlO1xuICAgICAgICB2YXIgYW5jaG9yZWRIb3Jpem9udGFsbHkgPSBmYWxzZTtcblxuICAgICAgICBpZiAobG9hZE9wdGlvbnMuZ29EaXJlY3RseVRvID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxvYWRPcHRpb25zLmdvRGlyZWN0bHlUbyA9IHNldHRpbmdzLmdvRGlyZWN0bHlUbztcbiAgICAgICAgICAgIG5lZWRzWENvb3JkID0gbmVlZHNZQ29vcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbmVlZHNYQ29vcmQgPSBsb2FkT3B0aW9ucy5ob3Jpem9udGFsT2Zmc2V0ID09IG51bGwgfHwgaXNOYU4obG9hZE9wdGlvbnMuaG9yaXpvbnRhbE9mZnNldCk7XG4gICAgICAgICAgICBuZWVkc1lDb29yZCA9IGxvYWRPcHRpb25zLnZlcnRpY2FsT2Zmc2V0ID09IG51bGwgfHwgaXNOYU4obG9hZE9wdGlvbnMudmVydGljYWxPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgb2Zmc2V0c1xuICAgICAgICBpZiAobmVlZHNYQ29vcmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IGlmIGluQm9va0xheW91dC92ZXJ0aWNhbGx5T3JpZW50ZWQgaXMgY2hhbmdlZCBieSBsb2FkT3B0aW9ucz9cbiAgICAgICAgICAgIGlmIChsb2FkT3B0aW9ucy5nb0RpcmVjdGx5VG8gPT09IDAgJiYgc2V0dGluZ3MuaW5Cb29rTGF5b3V0ICYmIHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbiBib29rIGxheW91dCwgY2VudGVyIHRoZSBmaXJzdCBvcGVuaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBsb2FkT3B0aW9ucy5ob3Jpem9udGFsT2Zmc2V0ID0gdmlld2VyU3RhdGUuaG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYW5jaG9yZWRIb3Jpem9udGFsbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvYWRPcHRpb25zLmhvcml6b250YWxPZmZzZXQgPSBnZXRYT2Zmc2V0KGxvYWRPcHRpb25zLmdvRGlyZWN0bHlUbywgXCJjZW50ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNZQ29vcmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFuY2hvcmVkVmVydGljYWxseSA9IHRydWU7XG4gICAgICAgICAgICBsb2FkT3B0aW9ucy52ZXJ0aWNhbE9mZnNldCA9IGdldFlPZmZzZXQobG9hZE9wdGlvbnMuZ29EaXJlY3RseVRvLCBcInRvcFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbG9hZFZpZXdlcihsb2FkT3B0aW9ucyk7XG5cbiAgICAgICAgLy9wcmVwIGRpbWVuc2lvbnMgb25lIGxhc3QgdGltZSBub3cgdGhhdCBwYWdlcyBoYXZlIGxvYWRlZFxuICAgICAgICB1cGRhdGVQYW5lbFNpemUoKTtcblxuICAgICAgICAvLyBGSVhNRTogVGhpcyBpcyBhIGhhY2sgdG8gZW5zdXJlIHRoYXQgdGhlIG91dGVyRWxlbWVudCBzY3JvbGxiYXJzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgICAgaWYgKHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlubmVyRWxlbWVudC5zdHlsZS5taW5XaWR0aCA9IHNldHRpbmdzLnBhbmVsV2lkdGggKyAncHgnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gc2V0dGluZ3MucGFuZWxIZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIC8vIEZJWE1FOiBJZiB0aGUgcGFnZSB3YXMgc3VwcG9zZWQgdG8gYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgd2UgbmVlZCB0b1xuICAgICAgICAvLyByZWNhbGN1bGF0ZSBpdCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgc2Nyb2xsYmFyc1xuICAgICAgICBpZiAoYW5jaG9yZWRWZXJ0aWNhbGx5IHx8IGFuY2hvcmVkSG9yaXpvbnRhbGx5KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yZWRWZXJ0aWNhbGx5KVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0ID0gZ2V0WU9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCBcInRvcFwiKTtcblxuICAgICAgICAgICAgaWYgKGFuY2hvcmVkSG9yaXpvbnRhbGx5KVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBnZXRYT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIFwiY2VudGVyXCIpO1xuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nb3RvKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0LCB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpZ25hbCB0aGF0IGV2ZXJ5dGhpbmcgc2hvdWxkIGJlIHNldCB1cCBhbmQgcmVhZHkgdG8gZ28uXG4gICAgICAgIHZpZXdlclN0YXRlLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgcHVibGlzaChcIlZpZXdlckRpZExvYWRcIiwgc2V0dGluZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgcHVibGlzaCA9IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgZGl2YS5FdmVudHMucHVibGlzaChldmVudCwgYXJncywgcHVibGljSW5zdGFuY2UpO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBGaXJzdCBmaWd1cmUgb3V0IHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGluIHRoaXMgYnJvd3NlclxuICAgICAgICAvLyBUT0RPKHdhYmFpbik6IENhY2hlIHRoaXMgc29tZXdoZXJlIGVsc2VcbiAgICAgICAgLy8gT25seSBzb21lIG9mIHRoZSBwbHVnaW5zIHJlbHkgb24gdGhpcyBub3dcbiAgICAgICAgdmlld2VyU3RhdGUuc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuXG4gICAgICAgIC8vIElmIHdpbmRvdy5vcmllbnRhdGlvbiBpcyBkZWZpbmVkLCB0aGVuIGl0J3MgcHJvYmFibHkgbW9iaWxlV2Via2l0XG4gICAgICAgIHZpZXdlclN0YXRlLm1vYmlsZVdlYmtpdCA9IHdpbmRvdy5vcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGFuIElEIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBwcmVmaXggZm9yIGFsbCB0aGUgb3RoZXIgSURzXG4gICAgICAgIHZhciBpZE51bWJlciA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgdmlld2VyU3RhdGUuSUQgPSAnZGl2YS0nICsgaWROdW1iZXIgKyAnLSc7XG4gICAgICAgIHZpZXdlclN0YXRlLnNlbGVjdG9yID0gJyMnICsgc2V0dGluZ3MuSUQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzaFBhcmFtU3VmZml4ID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBPbWl0IHRoZSBzdWZmaXggZnJvbSB0aGUgZmlyc3QgaW5zdGFuY2VcbiAgICAgICAgICAgIGlmIChpZE51bWJlciA9PT0gMSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhhc2hQYXJhbVN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGFzaFBhcmFtU3VmZml4ID0gaWROdW1iZXIgKyAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaW5uZXIgYW5kIG91dGVyIHBhbmVsc1xuICAgICAgICB2YXIgaW5uZXJFbGVtID0gZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ2lubmVyJywgeyBjbGFzczogJ2RpdmEtaW5uZXIgZGl2YS1kcmFnZ2VyJyB9KSk7XG4gICAgICAgIHZhciB2aWV3cG9ydEVsZW0gPSBlbHQoJ2RpdicsIGVsZW1BdHRycygndmlld3BvcnQnKSwgaW5uZXJFbGVtKTtcbiAgICAgICAgdmFyIG91dGVyRWxlbSA9IGVsdCgnZGl2JywgZWxlbUF0dHJzKCdvdXRlcicpLFxuICAgICAgICAgICAgdmlld3BvcnRFbGVtLFxuICAgICAgICAgICAgZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ3Rocm9iYmVyJykpKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnQgPSBpbm5lckVsZW07XG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0RWxlbWVudCA9IHZpZXdwb3J0RWxlbTtcbiAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJFbGVtZW50ID0gb3V0ZXJFbGVtO1xuXG4gICAgICAgIHZpZXdlclN0YXRlLmlubmVyT2JqZWN0ID0gJChpbm5lckVsZW0pO1xuICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCA9ICQodmlld3BvcnRFbGVtKTtcbiAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QgPSAkKG91dGVyRWxlbSk7XG5cbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0LmFwcGVuZChvdXRlckVsZW0pO1xuXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KHZpZXdlclN0YXRlLnZpZXdwb3J0RWxlbWVudCwge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uVG9sZXJhbmNlOiBzZXR0aW5ncy52aWV3cG9ydE1hcmdpblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEbyBhbGwgdGhlIHBsdWdpbiBpbml0aWFsaXNhdGlvblxuICAgICAgICBpbml0UGx1Z2lucygpO1xuXG4gICAgICAgIGhhbmRsZUV2ZW50cygpO1xuXG4gICAgICAgIC8vIFNob3cgdGhlIHRocm9iYmVyIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBtYW5pZmVzdCB0byBsb2FkXG4gICAgICAgIHNob3dUaHJvYmJlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9O1xuXG4gICAgLy8gVGVtcG9yYXJ5IGFjY2Vzc29yIGZvciB0aGUgc3RhdGUgb2YgdGhlIHZpZXdlciBjb3JlXG4gICAgLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBtb3JlIHJlc3RyaWN0ZWQgdmlldyBvZiB3aGF0ZXZlciBuZWVkc1xuICAgIC8vIGJlIGV4cG9zZWQgdGhyb3VnaCBzZXR0aW5ncyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMuZ2V0SW50ZXJuYWxTdGF0ZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdmlld2VyU3RhdGU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UHVibGljSW5zdGFuY2UgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3RhbmNlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VUb29scyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdmlld2VyU3RhdGUucGFnZVRvb2xzO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEN1cnJlbnRMYXlvdXQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnJlbmRlcmVyID8gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqIEdldCBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgZGltZW5zaW9ucyAqL1xuICAgIHRoaXMuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdmlld2VyU3RhdGUudmlld3BvcnQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogdmlld3BvcnQudG9wLFxuICAgICAgICAgICAgbGVmdDogdmlld3BvcnQubGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogdmlld3BvcnQuYm90dG9tLFxuICAgICAgICAgICAgcmlnaHQ6IHZpZXdwb3J0LnJpZ2h0LFxuXG4gICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLmFkZFBhZ2VPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAge1xuICAgICAgICB2aWV3ZXJTdGF0ZS5wYWdlT3ZlcmxheXMuYWRkT3ZlcmxheShvdmVybGF5KTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVQYWdlT3ZlcmxheSA9IGZ1bmN0aW9uIChvdmVybGF5KVxuICAgIHtcbiAgICAgICAgdmlld2VyU3RhdGUucGFnZU92ZXJsYXlzLnJlbW92ZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFnZVJlZ2lvbiA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIG9wdGlvbnMpXG4gICAge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0O1xuICAgICAgICB2YXIgcmVnaW9uID0gbGF5b3V0LmdldFBhZ2VSZWdpb24ocGFnZUluZGV4LCBvcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmluY29ycG9yYXRlVmlld3BvcnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzZWNvbmRhcnlEaW0gPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICAgICAgICAgIGlmICh2aWV3ZXJTdGF0ZS52aWV3cG9ydFtzZWNvbmRhcnlEaW1dID4gbGF5b3V0LmRpbWVuc2lvbnNbc2Vjb25kYXJ5RGltXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jT2Zmc2V0ID0gKHZpZXdlclN0YXRlLnZpZXdwb3J0W3NlY29uZGFyeURpbV0gLSBsYXlvdXQuZGltZW5zaW9uc1tzZWNvbmRhcnlEaW1dKSAvIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcmVnaW9uLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcmVnaW9uLmJvdHRvbSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVnaW9uLmxlZnQgKyBkb2NPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVnaW9uLnJpZ2h0ICsgZG9jT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHJlZ2lvbi50b3AgKyBkb2NPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHJlZ2lvbi5ib3R0b20gKyBkb2NPZmZzZXQsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlZ2lvbi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlZ2lvbi5yaWdodFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdpb247XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFnZVBvc2l0aW9uQXRWaWV3cG9ydE9mZnNldCA9IGZ1bmN0aW9uIChjb29yZHMpXG4gICAge1xuICAgICAgICB2YXIgZG9jQ29vcmRzID0ge1xuICAgICAgICAgICAgbGVmdDogY29vcmRzLmxlZnQgKyB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wICsgdmlld2VyU3RhdGUudmlld3BvcnQudG9wXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbmRlcmVkUGFnZXMgPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nZXRSZW5kZXJlZFBhZ2VzKCk7XG4gICAgICAgIHZhciBwYWdlQ291bnQgPSByZW5kZXJlZFBhZ2VzLmxlbmd0aDtcblxuICAgICAgICAvLyBGaW5kIHRoZSBwYWdlIG9uIHdoaWNoIHRoZSBjb29yZHMgb2NjdXJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGFnZUNvdW50OyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSByZW5kZXJlZFBhZ2VzW2ldO1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlUmVnaW9uKHBhZ2VJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChyZWdpb24ubGVmdCA8PSBkb2NDb29yZHMubGVmdCAmJiByZWdpb24ucmlnaHQgPj0gZG9jQ29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICByZWdpb24udG9wIDw9IGRvY0Nvb3Jkcy50b3AgJiYgcmVnaW9uLmJvdHRvbSA+PSBkb2NDb29yZHMudG9wKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBkb2NDb29yZHMubGVmdCAtIHJlZ2lvbi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBkb2NDb29yZHMudG9wIC0gcmVnaW9uLnRvcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gRklYTUU6IFdvdWxkIGJlIGJldHRlciB0byB1c2UgdGhlIGNsb3Nlc3QgcGFnZSBvciBzb21ldGhpbmdcbiAgICAgICAgdmFyIGN1cnJlbnRSZWdpb24gPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sYXlvdXQuZ2V0UGFnZVJlZ2lvbihzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5jaG9yUGFnZTogc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCxcbiAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGRvY0Nvb3Jkcy5sZWZ0IC0gY3VycmVudFJlZ2lvbi5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogZG9jQ29vcmRzLnRvcCAtIGN1cnJlbnRSZWdpb24udG9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHRoaXMuc2V0TWFuaWZlc3QgPSBmdW5jdGlvbiAobWFuaWZlc3QsIGlzSUlJRiwgbG9hZE9wdGlvbnMpXG4gICAge1xuICAgICAgICBzZXRNYW5pZmVzdChtYW5pZmVzdCwgaXNJSUlGLCBsb2FkT3B0aW9ucyB8fCB7fSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBwYWdlIHRvIHRoZSBnaXZlbiBpbmRleCwgZmlyaW5nIFZpc2libGVQYWdlRGlkQ2hhbmdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZUluZGV4XG4gICAgICovXG4gICAgdGhpcy5zZXRDdXJyZW50UGFnZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBpZiAodmlld2VyU3RhdGUuY3VycmVudFBhZ2VJbmRleCAhPT0gcGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5jdXJyZW50UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgICAgICAgcHVibGlzaChcIlZpc2libGVQYWdlRGlkQ2hhbmdlXCIsIHBhZ2VJbmRleCwgdGhpcy5nZXRQYWdlTmFtZShwYWdlSW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VOYW1lID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS5tYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdLmY7XG4gICAgfTtcblxuICAgIHRoaXMucmVsb2FkID0gZnVuY3Rpb24gKG5ld09wdGlvbnMpXG4gICAge1xuICAgICAgICByZWxvYWRWaWV3ZXIobmV3T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHRoaXMuem9vbSA9IGZ1bmN0aW9uICh6b29tTGV2ZWwsIGZvY2FsUG9pbnQpXG4gICAge1xuICAgICAgICByZXR1cm4gaGFuZGxlWm9vbSh6b29tTGV2ZWwsIGZvY2FsUG9pbnQpO1xuICAgIH07XG5cbiAgICB0aGlzLmVuYWJsZVNjcm9sbGFibGUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKCF2aWV3ZXJTdGF0ZS5pc1Njcm9sbGFibGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJpbmRNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVLZXlTY3JvbGwgPSB2aWV3ZXJTdGF0ZS5pbml0aWFsS2V5U2Nyb2xsO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVTcGFjZVNjcm9sbCA9IHZpZXdlclN0YXRlLmluaXRpYWxTcGFjZVNjcm9sbDtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlzU2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5kaXNhYmxlU2Nyb2xsYWJsZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodmlld2VyU3RhdGUuaXNTY3JvbGxhYmxlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBibG9jayBkcmFnZ2luZy9kb3VibGUtY2xpY2sgem9vbWluZ1xuICAgICAgICAgICAgaWYgKHZpZXdlclN0YXRlLmlubmVyT2JqZWN0Lmhhc0NsYXNzKCdkaXZhLWRyYWdnZXInKSlcbiAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC51bmJpbmQoJ21vdXNlZG93bicpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QudW5iaW5kKCdkYmxjbGljaycpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QudW5iaW5kKCdjb250ZXh0bWVudScpO1xuXG4gICAgICAgICAgICAvLyBkaXNhYmxlIGFsbCBvdGhlciBzY3JvbGxpbmcgYWN0aW9uc1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgICAgIC8vIGJsb2NrIHNjcm9sbGluZyBrZXlzIGJlaGF2aW9yLCByZXNwZWN0aW5nIGluaXRpYWwgc2Nyb2xsIHNldHRpbmdzXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbml0aWFsS2V5U2Nyb2xsID0gc2V0dGluZ3MuZW5hYmxlS2V5U2Nyb2xsO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaW5pdGlhbFNwYWNlU2Nyb2xsID0gc2V0dGluZ3MuZW5hYmxlU3BhY2VTY3JvbGw7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmVuYWJsZUtleVNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVTcGFjZVNjcm9sbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pc1Njcm9sbGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmlzVmFsaWRPcHRpb24gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkT3B0aW9uKGtleSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICB0aGlzLnNob3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgLy8gRklYTUU6IE5vdCB0b3RhbGx5IHN1cmUgaXQgbWFrZXMgc2Vuc2UgdG8gYWx3YXlzIGRvIHRoYXQgaGVyZVxuICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICB2YXIgZXJyb3JFbGVtZW50ID0gZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ2Vycm9yJyksIFtcbiAgICAgICAgICAgIGVsdCgnYnV0dG9uJywgZWxlbUF0dHJzKCdlcnJvci1jbG9zZScsIHsnYXJpYS1sYWJlbCc6ICdDbG9zZSBkaWFsb2cnfSkpLFxuICAgICAgICAgICAgZWx0KCdwJyxcbiAgICAgICAgICAgICAgICBlbHQoJ3N0cm9uZycsICdFcnJvcicpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZWx0KCdkaXYnLCBtZXNzYWdlKVxuICAgICAgICBdKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS5vdXRlck9iamVjdC5hcHBlbmQoZXJyb3JFbGVtZW50KTtcblxuICAgICAgICAvL2JpbmQgZGlhbG9nIGNsb3NlIGJ1dHRvblxuICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2Vycm9yLWNsb3NlJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBlcnJvckVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlcnJvckVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRYT2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgeEFuY2hvcilcbiAgICB7XG4gICAgICAgIHJldHVybiBnZXRYT2Zmc2V0KHBhZ2VJbmRleCwgeEFuY2hvcik7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0WU9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHlBbmNob3IpXG4gICAge1xuICAgICAgICByZXR1cm4gZ2V0WU9mZnNldChwYWdlSW5kZXgsIHlBbmNob3IpO1xuICAgIH07XG5cbiAgICB0aGlzLnB1Ymxpc2ggPSBwdWJsaXNoO1xuXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjbGVhclZpZXdlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFBlbmRpbmdNYW5pZmVzdFJlcXVlc3QgPSBmdW5jdGlvbiAocGVuZGluZ01hbmlmZXN0UmVxdWVzdClcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLnBlbmRpbmdNYW5pZmVzdFJlcXVlc3QgPSBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0O1xuICAgIH07XG5cbiAgICAvLyBEZXN0cm95cyB0aGlzIGluc3RhbmNlLCB0ZWxscyBwbHVnaW5zIHRvIGRvIHRoZSBzYW1lIChmb3IgdGVzdGluZylcbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gVXNlZnVsIGV2ZW50IHRvIGFjY2VzcyBlbGVtZW50cyBpbiBkaXZhIGJlZm9yZSB0aGV5IGdldCBkZXN0cm95ZWQuIFVzZWQgYnkgdGhlIGhpZ2hsaWdodCBwbHVnaW4uXG4gICAgICAgIHB1Ymxpc2goJ1ZpZXdlcldpbGxUZXJtaW5hdGUnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIHJlcXVlc3QgcmV0cmlldmluZyBhIG1hbmlmZXN0XG4gICAgICAgIGlmIChzZXR0aW5ncy5wZW5kaW5nTWFuaWZlc3RSZXF1ZXN0KVxuICAgICAgICAgICAgc2V0dGluZ3MucGVuZGluZ01hbmlmZXN0UmVxdWVzdC5hYm9ydCgpO1xuXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIGhpZGUtc2Nyb2xsYmFyIGNsYXNzIGZyb20gdGhlIGJvZHlcbiAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdkaXZhLWhpZGUtc2Nyb2xsYmFyJyk7XG5cbiAgICAgICAgLy8gRW1wdHkgdGhlIHBhcmVudCBjb250YWluZXIgYW5kIHJlbW92ZSBhbnkgZGl2YS1yZWxhdGVkIGRhdGFcbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0LnBhcmVudCgpLmVtcHR5KCkucmVtb3ZlRGF0YSgnZGl2YScpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgYWRkaXRpb25hbCBzdHlsaW5nIG9uIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICBzZXR0aW5ncy5wYXJlbnRPYmplY3QucGFyZW50KCkucmVtb3ZlQXR0cignc3R5bGUnKS5yZW1vdmVBdHRyKCdjbGFzcycpO1xuXG4gICAgICAgIHB1Ymxpc2goJ1ZpZXdlckRpZFRlcm1pbmF0ZScsIHNldHRpbmdzKTtcblxuICAgICAgICAvLyBDbGVhciB0aGUgRXZlbnRzIGNhY2hlXG4gICAgICAgIGRpdmEuRXZlbnRzLnVuc3Vic2NyaWJlQWxsKHNldHRpbmdzLklEKTtcbiAgICB9O1xuXG4gICAgLy8gQ2FsbCB0aGUgaW5pdCBmdW5jdGlvbiB3aGVuIHRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gICAgaW5pdCgpO1xufVxuXG5nZW5lcmF0ZUlkLmNvdW50ZXIgPSAxO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuICAgIHJldHVybiBnZW5lcmF0ZUlkLmNvdW50ZXIrKztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvdmlld2VyLWNvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoganNoaW50IHVudXNlZDogZmFsc2UgKi9cblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBUaGlzIGlzIGEgdmVuZG9yZWQgZGVwZW5kZW5jeSAqL1xuLypcbiAqIGpRdWVyeSBkcmFnc2Nyb2xsYWJsZSBQbHVnaW5cbiAqIHZlcnNpb246IDEuMCAoMjUtSnVuLTIwMDkpXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDkgTWlxdWVsIEhlcnJlcmFcbiAqIGh0dHA6Ly9wbHVnaW5zLmpxdWVyeS5jb20vcHJvamVjdC9EcmFnc2Nyb2xsYWJsZVxuICpcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxuICogICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICogICBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLmh0bWxcbiAqXG4gKi9cbihmdW5jdGlvbiAoJCkgeyAvLyBzZWN1cmUgJCBqUXVlcnkgYWxpYXNcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGFiaWxpdHkgdG8gbWFuYWdlIGVsZW1lbnRzIHNjcm9sbCBieSBkcmFnZ2luZ1xuICAgICAqIG9uZSBvciBtb3JlIG9mIGl0cyBkZXNjZW5kYW50IGVsZW1lbnRzLiBPcHRpb25zIHBhcmFtZXRlclxuICAgICAqIGFsbG93IHRvIHNwZWNpZmljYWxseSBzZWxlY3Qgd2hpY2ggaW5uZXIgZWxlbWVudHMgd2lsbFxuICAgICAqIHJlc3BvbmQgdG8gdGhlIGRyYWcgZXZlbnRzLlxuICAgICAqXG4gICAgICogb3B0aW9ucyBwcm9wZXJ0aWVzOlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqICBkcmFnU2VsZWN0b3IgICAgICAgICB8IGpxdWVyeSBzZWxlY3RvciB0byBhcHBseSB0byBlYWNoIHdyYXBwZWQgZWxlbWVudFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IHRvIGZpbmQgd2hpY2ggd2lsbCBiZSB0aGUgZHJhZ2dpbmcgZWxlbWVudHMuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHwgRGVmYXVsdHMgdG8gJz46Zmlyc3QnIHdoaWNoIGlzIHRoZSBmaXJzdCBjaGlsZCBvZlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IHNjcm9sbGFibGUgZWxlbWVudFxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqICBhY2NlcHRQcm9wYWdhdGVkRXZlbnR8IFdpbGwgdGhlIGRyYWdnaW5nIGVsZW1lbnQgYWNjZXB0IHByb3BhZ2F0ZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgfCBldmVudHM/IGRlZmF1bHQgaXMgeWVzLCBhIHByb3BhZ2F0ZWQgbW91c2UgZXZlbnRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgfCBvbiBhIGlubmVyIGVsZW1lbnQgd2lsbCBiZSBhY2NlcHRlZCBhbmQgcHJvY2Vzc2VkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IElmIHNldCB0byBmYWxzZSwgb25seSBldmVudHMgb3JpZ2luYXRlZCBvbiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgfCBkcmFnZ2FibGUgZWxlbWVudHMgd2lsbCBiZSBwcm9jZXNzZWQuXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIHByZXZlbnREZWZhdWx0ICAgICAgIHwgUHJldmVudHMgdGhlIGV2ZW50IHRvIHByb3BhZ2F0ZSBmdXJ0aGVyIGVmZmVjdGl2ZXlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgfCBkaXNzYWJsaW5nIG90aGVyIGRlZmF1bHQgYWN0aW9ucy4gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogIHVzYWdlIGV4YW1wbGVzOlxuICAgICAqXG4gICAgICogIFRvIGFkZCB0aGUgc2Nyb2xsIGJ5IGRyYWcgdG8gdGhlIGVsZW1lbnQgaWQ9dmlld3BvcnQgd2hlbiBkcmFnZ2luZyBpdHNcbiAgICAgKiAgZmlyc3QgY2hpbGQgYWNjZXB0aW5nIGFueSBwcm9wYWdhdGVkIGV2ZW50c1xuICAgICAqICAkKCcjdmlld3BvcnQnKS5kcmFnc2Nyb2xsYWJsZSgpO1xuICAgICAqXG4gICAgICogIFRvIGFkZCB0aGUgc2Nyb2xsIGJ5IGRyYWcgYWJpbGl0eSB0byBhbnkgZWxlbWVudCBkaXYgb2YgY2xhc3Mgdmlld3BvcnRcbiAgICAgKiAgd2hlbiBkcmFnZ2luZyBpdHMgZmlyc3QgZGVzY2VuZGFudCBvZiBjbGFzcyBkcmFnTWUgcmVzcG9uZGluZyBvbmx5IHRvXG4gICAgICogIGV2Y2VudHMgb3JpZ2luYXRlZCBvbiB0aGUgJy5kcmFnTWUnIGVsZW1lbnRzLlxuICAgICAqICAkKCdkaXYudmlld3BvcnQnKS5kcmFnc2Nyb2xsYWJsZSh7ZHJhZ1NlbGVjdG9yOicuZHJhZ01lOmZpcnN0JyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiBmYWxzZX0pO1xuICAgICAqXG4gICAgICogIE5vdGljZSB0aGF0IHNvbWUgJ3ZpZXdwb3J0cycgY291bGQgYmUgbmVzdGVkIHdpdGhpbiBvdGhlcnMgYnV0IGV2ZW50c1xuICAgICAqICB3b3VsZCBub3QgaW50ZXJmZXJlIGFzIGFjY2VwdFByb3BhZ2F0ZWRFdmVudCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICAkLmZuLmRyYWdzY3JvbGxhYmxlID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcblxuICAgICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkcmFnU2VsZWN0b3I6Jz46Zmlyc3QnLFxuICAgICAgICAgICAgICAgIGFjY2VwdFByb3BhZ2F0ZWRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgICAgICAgICAgfSxvcHRpb25zIHx8IHt9KTtcblxuXG4gICAgICAgIHZhciBkcmFnc2Nyb2xsPSB7XG4gICAgICAgICAgICBtb3VzZURvd25IYW5kbGVyIDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3VzZWRvd24sIGxlZnQgY2xpY2ssIGNoZWNrIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoIT0xIHx8XG4gICAgICAgICAgICAgICAgICAgICghZXZlbnQuZGF0YS5hY2NlcHRQcm9wYWdhdGVkRXZlbnQgJiYgZXZlbnQudGFyZ2V0ICE9IHRoaXMpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgY29vcmRpbmF0ZXMgd2lsbCBiZSB0aGUgbGFzdCB3aGVuIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5sYXN0Q29vcmQgPSB7bGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZfTtcblxuICAgICAgICAgICAgICAgICQuZXZlbnQuYWRkKCBkb2N1bWVudCwgXCJtb3VzZXVwXCIsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdzY3JvbGwubW91c2VVcEhhbmRsZXIsIGV2ZW50LmRhdGEgKTtcbiAgICAgICAgICAgICAgICAkLmV2ZW50LmFkZCggZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdzY3JvbGwubW91c2VNb3ZlSGFuZGxlciwgZXZlbnQuZGF0YSApO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2VNb3ZlSGFuZGxlciA6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIFVzZXIgaXMgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICAvLyBIb3cgbXVjaCBkaWQgdGhlIG1vdXNlIG1vdmU/XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0ge2xlZnQ6IChldmVudC5jbGllbnRYIC0gZXZlbnQuZGF0YS5sYXN0Q29vcmQubGVmdCksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogKGV2ZW50LmNsaWVudFkgLSBldmVudC5kYXRhLmxhc3RDb29yZC50b3ApfTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHdoYXQgZXZlciB0aGUgc2Nyb2xsIGlzIG5vd1xuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0KFxuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnNjcm9sbGFibGUuc2Nyb2xsTGVmdCgpIC0gZGVsdGEubGVmdCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5zY3JvbGxhYmxlLnNjcm9sbFRvcChcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5zY3JvbGxhYmxlLnNjcm9sbFRvcCgpIC0gZGVsdGEudG9wKTtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgd2hlcmUgdGhlIGN1cnNvciBpc1xuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEubGFzdENvb3JkPXtsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFl9O1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZVVwSGFuZGxlciA6IGZ1bmN0aW9uKGV2ZW50KSB7IC8vIFN0b3Agc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgJC5ldmVudC5yZW1vdmUoIGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBkcmFnc2Nyb2xsLm1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICQuZXZlbnQucmVtb3ZlKCBkb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdzY3JvbGwubW91c2VVcEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBpbml0aWFsIGV2ZW50c1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlIG9iamVjdCBkYXRhIGZvciBlYWNoIHNjcm9sbGFibGUgZWxlbWVudFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7c2Nyb2xsYWJsZSA6ICQodGhpcyksXG4gICAgICAgICAgICAgICAgYWNjZXB0UHJvcGFnYXRlZEV2ZW50IDogc2V0dGluZ3MuYWNjZXB0UHJvcGFnYXRlZEV2ZW50LFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0IDogc2V0dGluZ3MucHJldmVudERlZmF1bHQgfTtcbiAgICAgICAgICAgIC8vIFNldCBtb3VzZSBpbml0aWF0aW5nIGV2ZW50IG9uIHRoZSBkZXNpcmVkIGRlc2NlbmRhbnRcbiAgICAgICAgICAgICQodGhpcykuZmluZChzZXR0aW5ncy5kcmFnU2VsZWN0b3IpLlxuICAgICAgICAgICAgYmluZCgnbW91c2Vkb3duJywgZGF0YSwgZHJhZ3Njcm9sbC5tb3VzZURvd25IYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfTsgLy9lbmQgcGx1Z2luIGRyYWdzY3JvbGxhYmxlXG5cbn0pKCBqUXVlcnkgKTsgLy8gY29uZmluZSBzY29wZVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBUaGlzIGlzIGEgdmVuZG9yZWQgZGVwZW5kZW5jeSAqL1xuLyoqXG4galF1ZXJ5LmtpbmV0aWMgdjIuMi4xXG4gRGF2ZSBUYXlsb3IgaHR0cDovL2RhdmV0YXlscy5tZVxuXG4gQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gQHByZXNlcnZlIENvcHlyaWdodCAoYykgMjAxMiBEYXZlIFRheWxvciBodHRwOi8vZGF2ZXRheWxzLm1lXG4gKi9cbihmdW5jdGlvbiAoJCl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEFDVElWRV9DTEFTUyA9ICdraW5ldGljLWFjdGl2ZSc7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaW4gYSBjcm9zcyBicm93c2VyIHdheS5cbiAgICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgICAqL1xuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSl7XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9ICggZnVuY3Rpb24gKCl7XG5cbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrLCAvKiBET01FbGVtZW50IEVsZW1lbnQgKi8gZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSgpKTtcblxuICAgIH1cblxuICAgIC8vIGFkZCB0b3VjaCBjaGVja2VyIHRvIGpRdWVyeS5zdXBwb3J0XG4gICAgJC5zdXBwb3J0ID0gJC5zdXBwb3J0IHx8IHt9O1xuICAgICQuZXh0ZW5kKCQuc3VwcG9ydCwge1xuICAgICAgICB0b3VjaDogJ29udG91Y2hlbmQnIGluIGRvY3VtZW50XG4gICAgfSk7XG5cblxuICAgIC8vIEtJTkVUSUMgQ0xBU1MgREVGSU5JVElPTlxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHZhciBLaW5ldGljID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5lbCAgICAgICA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuJGVsICAgICAgPSAkKGVsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMuX2luaXRFbGVtZW50cygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBLaW5ldGljLkRBVEFfS0VZID0gJ2tpbmV0aWMnO1xuICAgIEtpbmV0aWMuREVGQVVMVFMgPSB7XG4gICAgICAgIGN1cnNvcjogJ21vdmUnLFxuICAgICAgICBkZWNlbGVyYXRlOiB0cnVlLFxuICAgICAgICB0cmlnZ2VySGFyZHdhcmU6IGZhbHNlLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHk6IHRydWUsXG4gICAgICAgIHg6IHRydWUsXG4gICAgICAgIHNsb3dkb3duOiAwLjksXG4gICAgICAgIG1heHZlbG9jaXR5OiA0MCxcbiAgICAgICAgdGhyb3R0bGVGUFM6IDYwLFxuICAgICAgICBpbnZlcnQ6IGZhbHNlLFxuICAgICAgICBtb3ZpbmdDbGFzczoge1xuICAgICAgICAgICAgdXA6ICdraW5ldGljLW1vdmluZy11cCcsXG4gICAgICAgICAgICBkb3duOiAna2luZXRpYy1tb3ZpbmctZG93bicsXG4gICAgICAgICAgICBsZWZ0OiAna2luZXRpYy1tb3ZpbmctbGVmdCcsXG4gICAgICAgICAgICByaWdodDogJ2tpbmV0aWMtbW92aW5nLXJpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICBkZWNlbGVyYXRpbmdDbGFzczoge1xuICAgICAgICAgICAgdXA6ICdraW5ldGljLWRlY2VsZXJhdGluZy11cCcsXG4gICAgICAgICAgICBkb3duOiAna2luZXRpYy1kZWNlbGVyYXRpbmctZG93bicsXG4gICAgICAgICAgICBsZWZ0OiAna2luZXRpYy1kZWNlbGVyYXRpbmctbGVmdCcsXG4gICAgICAgICAgICByaWdodDogJ2tpbmV0aWMtZGVjZWxlcmF0aW5nLXJpZ2h0J1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8gUHVibGljIGZ1bmN0aW9uc1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAob3B0aW9ucyl7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSAkLmV4dGVuZCh0aGlzLnNldHRpbmdzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG9wdGlvbnMudmVsb2NpdHkgfHwgdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSBvcHRpb25zLnZlbG9jaXR5WSB8fCB0aGlzLnZlbG9jaXR5WTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5kZWNlbGVyYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vdmUoKTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjZWxlcmF0ZSA9IHRydWU7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlZID0gMDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5kZWNlbGVyYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLnN0b3BwZWQpKXtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc3RvcHBlZC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB0aGlzLl9kZXRhY2hMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy4kZWxcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhBQ1RJVkVfQ0xBU1MpXG4gICAgICAgICAgICAuY3NzKCdjdXJzb3InLCAnJyk7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uICgpe1xuICAgICAgICBpZiAodGhpcy4kZWwuaGFzQ2xhc3MoQUNUSVZFX0NMQVNTKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaExpc3RlbmVycyh0aGlzLiRlbCk7XG4gICAgICAgIHRoaXMuJGVsXG4gICAgICAgICAgICAuYWRkQ2xhc3MoQUNUSVZFX0NMQVNTKVxuICAgICAgICAgICAgLmNzcygnY3Vyc29yJywgdGhpcy5zZXR0aW5ncy5jdXJzb3IpO1xuICAgIH07XG5cblxuICAgIC8vIEludGVybmFsIGZ1bmN0aW9uc1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2luaXRFbGVtZW50cyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhBQ1RJVkVfQ0xBU1MpO1xuXG4gICAgICAgICQuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHhwb3M6IG51bGwsXG4gICAgICAgICAgICBwcmV2WFBvczogZmFsc2UsXG4gICAgICAgICAgICB5cG9zOiBudWxsLFxuICAgICAgICAgICAgcHJldllQb3M6IGZhbHNlLFxuICAgICAgICAgICAgbW91c2VEb3duOiBmYWxzZSxcbiAgICAgICAgICAgIHRocm90dGxlVGltZW91dDogMTAwMCAvIHRoaXMuc2V0dGluZ3MudGhyb3R0bGVGUFMsXG4gICAgICAgICAgICBsYXN0TW92ZTogbnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnRGb2N1c2VkOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IDA7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHJlc2V0IGV2ZXJ5dGhpbmcgd2hlbiBtb3VzZSB1cFxuICAgICAgICAkKGRvY3VtZW50KVxuICAgICAgICAgICAgLm1vdXNldXAoJC5wcm94eSh0aGlzLl9yZXNldE1vdXNlLCB0aGlzKSlcbiAgICAgICAgICAgIC5jbGljaygkLnByb3h5KHRoaXMuX3Jlc2V0TW91c2UsIHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAgICAgdGhpcy4kZWwuY3NzKCdjdXJzb3InLCB0aGlzLnNldHRpbmdzLmN1cnNvcik7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHJpZ2dlckhhcmR3YXJlKXtcbiAgICAgICAgICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICAgICAgICAgICAgJy13ZWJraXQtdHJhbnNmb3JtJzogJ3RyYW5zbGF0ZTNkKDAsMCwwKScsXG4gICAgICAgICAgICAgICAgJy13ZWJraXQtcGVyc3BlY3RpdmUnOiAnMTAwMCcsXG4gICAgICAgICAgICAgICAgJy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eSc6ICdoaWRkZW4nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5ldmVudHMgPSB7XG4gICAgICAgICAgICB0b3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl91c2VUYXJnZXQoZS50YXJnZXQsIGUpKXtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2ggPSBlLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50aHJlc2hvbGQgPSBzZWxmLl90aHJlc2hvbGQoZS50YXJnZXQsIGUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zdGFydCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vdXNlRG93bil7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoID0gZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0bW92ZSh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0RG93bjogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl91c2VUYXJnZXQoZS50YXJnZXQsIGUpKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50aHJlc2hvbGQgPSBzZWxmLl90aHJlc2hvbGQoZS50YXJnZXQsIGUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zdGFydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudEZvY3VzZWQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lID09PSAnSU1HJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRFbmQ6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fdXNlVGFyZ2V0KGUudGFyZ2V0LCBlKSl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnRGb2N1c2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0TW92ZTogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vdXNlRG93bil7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0bW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY3JvbGw6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHNlbGYuc2V0dGluZ3MubW92ZWQpKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXR0aW5ncy5tb3ZlZC5jYWxsKHNlbGYsIHNlbGYuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRDbGljazogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzZWxmLnZlbG9jaXR5KSA+IDApe1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcHJldmVudCBkcmFnIGFuZCBkcm9wIGltYWdlcyBpbiBpZVxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3VzZVRhcmdldChlLnRhcmdldCwgZSkgJiYgc2VsZi5lbGVtZW50Rm9jdXNlZCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcHJldmVudCBzZWxlY3Rpb24gd2hlbiBkcmFnZ2luZ1xuICAgICAgICAgICAgc2VsZWN0U3RhcnQ6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHNlbGYuc2V0dGluZ3Muc2VsZWN0U3RhcnQpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2V0dGluZ3Muc2VsZWN0U3RhcnQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuX3VzZVRhcmdldChlLnRhcmdldCwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9hdHRhY2hMaXN0ZW5lcnModGhpcy4kZWwsIHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9pbnB1dG1vdmUgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSl7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXMuJGVsO1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgIGlmICghdGhpcy5sYXN0TW92ZSB8fCBuZXcgRGF0ZSgpID4gbmV3IERhdGUodGhpcy5sYXN0TW92ZS5nZXRUaW1lKCkgKyB0aGlzLnRocm90dGxlVGltZW91dCkpe1xuICAgICAgICAgICAgdGhpcy5sYXN0TW92ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1vdXNlRG93biAmJiAodGhpcy54cG9zIHx8IHRoaXMueXBvcykpe1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlZFggPSAoY2xpZW50WCAtIHRoaXMueHBvcyk7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVkWSA9IChjbGllbnRZIC0gdGhpcy55cG9zKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5pbnZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWRYICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZFkgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHRoaXMudGhyZXNob2xkID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlZCA9IE1hdGguc3FydChtb3ZlZFggKiBtb3ZlZFggKyBtb3ZlZFkgKiBtb3ZlZFkpO1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnRocmVzaG9sZCA+IG1vdmVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyZXNob2xkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50Rm9jdXNlZCl7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5lbGVtZW50Rm9jdXNlZCkuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRGb2N1c2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2VsZXJhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eVkgPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3AoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCh0aGlzLnNldHRpbmdzLnggPyBzY3JvbGxMZWZ0IC0gbW92ZWRYIDogc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AodGhpcy5zZXR0aW5ncy55ID8gc2Nyb2xsVG9wIC0gbW92ZWRZIDogc2Nyb2xsVG9wKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHJldlhQb3MgPSB0aGlzLnhwb3M7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2WVBvcyA9IHRoaXMueXBvcztcbiAgICAgICAgICAgICAgICB0aGlzLnhwb3MgPSBjbGllbnRYO1xuICAgICAgICAgICAgICAgIHRoaXMueXBvcyA9IGNsaWVudFk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVWZWxvY2l0aWVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0TW92ZUNsYXNzZXModGhpcy5zZXR0aW5ncy5tb3ZpbmdDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3MubW92ZWQpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5tb3ZlZC5jYWxsKHRoaXMsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fY2FsY3VsYXRlVmVsb2NpdGllcyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5fY2FwVmVsb2NpdHkodGhpcy5wcmV2WFBvcyAtIHRoaXMueHBvcywgdGhpcy5zZXR0aW5ncy5tYXh2ZWxvY2l0eSk7XG4gICAgICAgIHRoaXMudmVsb2NpdHlZID0gdGhpcy5fY2FwVmVsb2NpdHkodGhpcy5wcmV2WVBvcyAtIHRoaXMueXBvcywgdGhpcy5zZXR0aW5ncy5tYXh2ZWxvY2l0eSk7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmludmVydCkge1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSAqPSAtMTtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHlZICo9IC0xO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgaWYgKHRoaXMueHBvcyAmJiB0aGlzLnByZXZYUG9zICYmIHRoaXMuc2V0dGluZ3MuZGVjZWxlcmF0ZSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5kZWNlbGVyYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVZlbG9jaXRpZXMoKTtcbiAgICAgICAgICAgIHRoaXMueHBvcyA9IHRoaXMucHJldlhQb3MgPSB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl91c2VUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCl7XG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5maWx0ZXJUYXJnZXQpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmZpbHRlclRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgZXZlbnQpICE9PSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX3RocmVzaG9sZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50KXtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLnRocmVzaG9sZCkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudGhyZXNob2xkLmNhbGwodGhpcywgdGFyZ2V0LCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudGhyZXNob2xkO1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSl7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMucHJldlhQb3MgPSAwO1xuICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IHRoaXMucHJldllQb3MgPSAwO1xuICAgICAgICB0aGlzLnhwb3MgPSBjbGllbnRYO1xuICAgICAgICB0aGlzLnlwb3MgPSBjbGllbnRZO1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fcmVzZXRNb3VzZSA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB0aGlzLnhwb3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55cG9zID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9kZWNlbGVyYXRlVmVsb2NpdHkgPSBmdW5jdGlvbiAodmVsb2NpdHksIHNsb3dkb3duKXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5hYnModmVsb2NpdHkpKSA9PT0gMCA/IDAgLy8gaXMgdmVsb2NpdHkgbGVzcyB0aGFuIDE/XG4gICAgICAgICAgICA6IHZlbG9jaXR5ICogc2xvd2Rvd247IC8vIHJlZHVjZSBzbG93ZG93blxuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fY2FwVmVsb2NpdHkgPSBmdW5jdGlvbiAodmVsb2NpdHksIG1heCl7XG4gICAgICAgIHZhciBuZXdWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgICBpZiAodmVsb2NpdHkgPiAwKXtcbiAgICAgICAgICAgIGlmICh2ZWxvY2l0eSA+IG1heCl7XG4gICAgICAgICAgICAgICAgbmV3VmVsb2NpdHkgPSBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmVsb2NpdHkgPCAoMCAtIG1heCkpe1xuICAgICAgICAgICAgICAgIG5ld1ZlbG9jaXR5ID0gKDAgLSBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdWZWxvY2l0eTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX3NldE1vdmVDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzZXMpe1xuICAgICAgICAvLyBGSVhNRTogY29uc2lkZXIgaWYgd2Ugd2FudCB0byBhcHBseSBQTCAjNDQsIHRoaXMgc2hvdWxkIG5vdCByZW1vdmVcbiAgICAgICAgLy8gY2xhc3NlcyB3ZSBoYXZlIG5vdCBkZWZpbmVkIG9uIHRoZSBlbGVtZW50IVxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzLiRlbDtcblxuICAgICAgICAkdGhpcy5yZW1vdmVDbGFzcyhzZXR0aW5ncy5tb3ZpbmdDbGFzcy51cClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5tb3ZpbmdDbGFzcy5kb3duKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHNldHRpbmdzLm1vdmluZ0NsYXNzLmxlZnQpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2V0dGluZ3MubW92aW5nQ2xhc3MucmlnaHQpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2V0dGluZ3MuZGVjZWxlcmF0aW5nQ2xhc3MudXApXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2V0dGluZ3MuZGVjZWxlcmF0aW5nQ2xhc3MuZG93bilcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5kZWNlbGVyYXRpbmdDbGFzcy5sZWZ0KVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHNldHRpbmdzLmRlY2VsZXJhdGluZ0NsYXNzLnJpZ2h0KTtcblxuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eSA+IDApe1xuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoY2xhc3Nlcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkgPCAwKXtcbiAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKGNsYXNzZXMubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHlZID4gMCl7XG4gICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhjbGFzc2VzLmRvd24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5WSA8IDApe1xuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoY2xhc3Nlcy51cCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIC8vIGRvIHRoZSBhY3R1YWwga2luZXRpYyBtb3ZlbWVudFxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHZhciAkc2Nyb2xsZXIgPSB0aGlzLl9nZXRTY3JvbGxlcigpO1xuICAgICAgICB2YXIgc2Nyb2xsZXIgPSAkc2Nyb2xsZXJbMF07XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNldHRpbmdzID0gc2VsZi5zZXR0aW5ncztcblxuICAgICAgICAvLyBzZXQgc2Nyb2xsTGVmdFxuICAgICAgICBpZiAoc2V0dGluZ3MueCAmJiBzY3JvbGxlci5zY3JvbGxXaWR0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0KHRoaXMuc2Nyb2xsTGVmdCgpICsgdGhpcy52ZWxvY2l0eSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eSkgPiAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gc2V0dGluZ3MuZGVjZWxlcmF0ZSA/XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlY2VsZXJhdGVWZWxvY2l0eSh0aGlzLnZlbG9jaXR5LCBzZXR0aW5ncy5zbG93ZG93bikgOiB0aGlzLnZlbG9jaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2Nyb2xsVG9wXG4gICAgICAgIGlmIChzZXR0aW5ncy55ICYmIHNjcm9sbGVyLnNjcm9sbEhlaWdodCA+IDApe1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AodGhpcy5zY3JvbGxUb3AoKSArIHRoaXMudmVsb2NpdHlZKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnZlbG9jaXR5WSkgPiAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IHNldHRpbmdzLmRlY2VsZXJhdGUgP1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kZWNlbGVyYXRlVmVsb2NpdHkodGhpcy52ZWxvY2l0eVksIHNldHRpbmdzLnNsb3dkb3duKSA6IHRoaXMudmVsb2NpdHlZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fc2V0TW92ZUNsYXNzZXMoc2V0dGluZ3MuZGVjZWxlcmF0aW5nQ2xhc3MpO1xuXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oc2V0dGluZ3MubW92ZWQpKXtcbiAgICAgICAgICAgIHNldHRpbmdzLm1vdmVkLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHkpID4gMCB8fCBNYXRoLmFicyh0aGlzLnZlbG9jaXR5WSkgPiAwKXtcbiAgICAgICAgICAgIGlmICghdGhpcy5tb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gdGljayBmb3IgbmV4dCBtb3ZlbWVudFxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX21vdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGdldCBjdXJyZW50IHNjcm9sbGVyIHRvIGFwcGx5IHBvc2l0aW9uaW5nIHRvXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2dldFNjcm9sbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyICRzY3JvbGxlciA9IHRoaXMuJGVsO1xuICAgICAgICBpZiAodGhpcy4kZWwuaXMoJ2JvZHknKSB8fCB0aGlzLiRlbC5pcygnaHRtbCcpKXtcbiAgICAgICAgICAgICRzY3JvbGxlciA9ICQod2luZG93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHNjcm9sbGVyO1xuICAgIH07XG5cbiAgICAvLyBzZXQgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgIEtpbmV0aWMucHJvdG90eXBlLnNjcm9sbExlZnQgPSBmdW5jdGlvbihsZWZ0KXtcbiAgICAgICAgdmFyICRzY3JvbGxlciA9IHRoaXMuX2dldFNjcm9sbGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ251bWJlcicpe1xuICAgICAgICAgICAgJHNjcm9sbGVyLnNjcm9sbExlZnQobGVmdCk7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRzY3JvbGxlci5zY3JvbGxMZWZ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtpbmV0aWMucHJvdG90eXBlLnNjcm9sbFRvcCA9IGZ1bmN0aW9uKHRvcCl7XG4gICAgICAgIHZhciAkc2Nyb2xsZXIgPSB0aGlzLl9nZXRTY3JvbGxlcigpO1xuICAgICAgICBpZiAodHlwZW9mIHRvcCA9PT0gJ251bWJlcicpe1xuICAgICAgICAgICAgJHNjcm9sbGVyLnNjcm9sbFRvcCh0b3ApO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjcm9sbGVyLnNjcm9sbFRvcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9hdHRhY2hMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcy4kZWw7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG5cbiAgICAgICAgaWYgKCQuc3VwcG9ydC50b3VjaCl7XG4gICAgICAgICAgICAkdGhpc1xuICAgICAgICAgICAgICAgIC5iaW5kKCd0b3VjaHN0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLnRvdWNoU3RhcnQpXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNoZW5kJywgc2V0dGluZ3MuZXZlbnRzLmlucHV0RW5kKVxuICAgICAgICAgICAgICAgIC5iaW5kKCd0b3VjaG1vdmUnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hNb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAubW91c2Vkb3duKHNldHRpbmdzLmV2ZW50cy5pbnB1dERvd24pXG4gICAgICAgICAgICAubW91c2V1cChzZXR0aW5ncy5ldmVudHMuaW5wdXRFbmQpXG4gICAgICAgICAgICAubW91c2Vtb3ZlKHNldHRpbmdzLmV2ZW50cy5pbnB1dE1vdmUpO1xuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAuY2xpY2soc2V0dGluZ3MuZXZlbnRzLmlucHV0Q2xpY2spXG4gICAgICAgICAgICAuc2Nyb2xsKHNldHRpbmdzLmV2ZW50cy5zY3JvbGwpXG4gICAgICAgICAgICAuYmluZCgnc2VsZWN0c3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuc2VsZWN0U3RhcnQpXG4gICAgICAgICAgICAuYmluZCgnZHJhZ3N0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLmRyYWdTdGFydCk7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9kZXRhY2hMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcy4kZWw7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgIGlmICgkLnN1cHBvcnQudG91Y2gpe1xuICAgICAgICAgICAgJHRoaXNcbiAgICAgICAgICAgICAgICAudW5iaW5kKCd0b3VjaHN0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLnRvdWNoU3RhcnQpXG4gICAgICAgICAgICAgICAgLnVuYmluZCgndG91Y2hlbmQnLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRFbmQpXG4gICAgICAgICAgICAgICAgLnVuYmluZCgndG91Y2htb3ZlJywgc2V0dGluZ3MuZXZlbnRzLnRvdWNoTW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkdGhpc1xuICAgICAgICAgICAgLnVuYmluZCgnbW91c2Vkb3duJywgc2V0dGluZ3MuZXZlbnRzLmlucHV0RG93bilcbiAgICAgICAgICAgIC51bmJpbmQoJ21vdXNldXAnLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRFbmQpXG4gICAgICAgICAgICAudW5iaW5kKCdtb3VzZW1vdmUnLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRNb3ZlKTtcblxuICAgICAgICAkdGhpc1xuICAgICAgICAgICAgLnVuYmluZCgnY2xpY2snLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRDbGljaylcbiAgICAgICAgICAgIC51bmJpbmQoJ3Njcm9sbCcsIHNldHRpbmdzLmV2ZW50cy5zY3JvbGwpXG4gICAgICAgICAgICAudW5iaW5kKCdzZWxlY3RzdGFydCcsIHNldHRpbmdzLmV2ZW50cy5zZWxlY3RTdGFydClcbiAgICAgICAgICAgIC51bmJpbmQoJ2RyYWdzdGFydCcsIHNldHRpbmdzLmV2ZW50cy5kcmFnU3RhcnQpO1xuICAgIH07XG5cblxuICAgIC8vIEVYUE9TRSBLSU5FVElDIENPTlNUUlVDVE9SXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAkLktpbmV0aWMgPSBLaW5ldGljO1xuXG4gICAgLy8gS0lORVRJQyBQTFVHSU4gREVGSU5JVElPTlxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAkLmZuLmtpbmV0aWMgPSBmdW5jdGlvbiAob3B0aW9uLCBjYWxsT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyAgICA9ICQodGhpcyk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSAkdGhpcy5kYXRhKEtpbmV0aWMuREFUQV9LRVkpO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgID0gJC5leHRlbmQoe30sIEtpbmV0aWMuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uKTtcblxuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoS2luZXRpYy5EQVRBX0tFWSwgKGluc3RhbmNlID0gbmV3IEtpbmV0aWModGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Vbb3B0aW9uXShjYWxsT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfTtcblxufShqUXVlcnkpKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBXZSBzaG91bGQgbWF5YmUgYmUgdGVzdGluZyB0aGlzLCBidXQgcmVhbGlzdGljYWxseSB0aGF0IHdvdWxkIG1lYW4gbWFpbnRhaW5pbmcgYSByZWFsIGZvcmsgKi9cblxuLy8galF1ZXJ5LmtpbmV0aWMgY29yZSBtb2RpZmljYXRpb25zIGZvciBkaXZhLmpzIChjb21wYXRpYmxlIHdpdGggalF1ZXJ5LmtpbmV0aWMgMi4yLjEpXG4vLyB1c2UgalF1ZXJ5LmtpbmV0aWMgZm9yIHRvdWNoIGhhbmRsZXJzIG9ubHkgc2luY2Ugd2UgYXJlIHVzaW5nIGRyYWdzY3JvbGxhYmxlIGZvciBtb3VzZSBoYW5kbGVyc1xuLy8gICAgLSAoa2luZXRpYyBwcm92aWRlcyBpbmVydGlhbCBzY3JvbGxpbmcgW2Vhc2UgaW50byBzdG9wcGVkIHN0YXRlIG9uIHJlbGVhc2VdIGZvciB0b3VjaCBldmVudHMgYW5kIGRyYWdzY3JvbGxhYmxlXG4vLyAgICAgIGFsbG93cyBub24taW5lcnRpYWwgc2Nyb2xsaW5nIHdoaWNoIHdlIGxpa2UgZm9yIG1pY2UpXG5cbihmdW5jdGlvbigkKVxue1xuICAgICQuS2luZXRpYy5wcm90b3R5cGUuX2F0dGFjaExpc3RlbmVycyA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIC8vIGF0dGFjaCBvbmx5IHRvdWNoIGxpc3RlbmVyc1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzLiRlbDtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcblxuICAgICAgICBpZiAoJC5zdXBwb3J0LnRvdWNoKVxuICAgICAgICB7XG4gICAgICAgICAgICAkdGhpc1xuICAgICAgICAgICAgICAgIC5iaW5kKCd0b3VjaHN0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLnRvdWNoU3RhcnQpXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNoZW5kJywgc2V0dGluZ3MuZXZlbnRzLmlucHV0RW5kKVxuICAgICAgICAgICAgICAgIC5iaW5kKCd0b3VjaG1vdmUnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hNb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAuY2xpY2soc2V0dGluZ3MuZXZlbnRzLmlucHV0Q2xpY2spXG4gICAgICAgICAgICAuc2Nyb2xsKHNldHRpbmdzLmV2ZW50cy5zY3JvbGwpXG4gICAgICAgICAgICAuYmluZCgnc2VsZWN0c3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuc2VsZWN0U3RhcnQpXG4gICAgICAgICAgICAuYmluZCgnZHJhZ3N0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLmRyYWdTdGFydCk7XG4gICAgfTtcblxuICAgICQuS2luZXRpYy5wcm90b3R5cGUuX2RldGFjaExpc3RlbmVycyA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIC8vIGRldGFjaCBvbmx5IHRvdWNoIGxpc3RlbmVyc1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzLiRlbDtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcblxuICAgICAgICBpZiAoJC5zdXBwb3J0LnRvdWNoKVxuICAgICAgICB7XG4gICAgICAgICAgICAkdGhpc1xuICAgICAgICAgICAgICAgIC51bmJpbmQoJ3RvdWNoc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hTdGFydClcbiAgICAgICAgICAgICAgICAudW5iaW5kKCd0b3VjaGVuZCcsIHNldHRpbmdzLmV2ZW50cy5pbnB1dEVuZClcbiAgICAgICAgICAgICAgICAudW5iaW5kKCd0b3VjaG1vdmUnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hNb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAudW5iaW5kKCdjbGljaycsIHNldHRpbmdzLmV2ZW50cy5pbnB1dENsaWNrKVxuICAgICAgICAgICAgLnVuYmluZCgnc2Nyb2xsJywgc2V0dGluZ3MuZXZlbnRzLnNjcm9sbClcbiAgICAgICAgICAgIC51bmJpbmQoJ3NlbGVjdHN0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLnNlbGVjdFN0YXJ0KVxuICAgICAgICAgICAgLnVuYmluZCgnZHJhZ3N0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLmRyYWdTdGFydCk7XG4gICAgfTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3V0aWxzL2pxdWVyeS1leHRlbnNpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIEZyb20gaHR0cDovL3d3dy5hbGV4YW5kcmUtZ29tZXMuY29tLz9wPTExNSwgbW9kaWZpZWQgc2xpZ2h0bHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIGlubmVyLnN0eWxlLmhlaWdodCA9ICcyMDBweCc7XG5cbiAgICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvdXRlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgb3V0ZXIuc3R5bGUudG9wID0gJzBweCc7XG4gICAgb3V0ZXIuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBvdXRlci5zdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gICAgb3V0ZXIuc3R5bGUuaGVpZ2h0ID0gJzE1MHB4JztcbiAgICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXG4gICAgdmFyIHcxID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICB2YXIgdzIgPSBpbm5lci5vZmZzZXRXaWR0aDtcbiAgICBpZiAodzEgPT0gdzIpIHtcbiAgICAgICAgdzIgPSBvdXRlci5jbGllbnRXaWR0aDsgLy8gZm9yIElFIGkgdGhpbmtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcbiAgICByZXR1cm4gdzEgLSB3Mjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3V0aWxzL2dldC1zY3JvbGxiYXItd2lkdGguanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGljayxcbiAgICBvblBpbmNoOiBvblBpbmNoLFxuICAgIG9uRG91YmxlVGFwOiBvbkRvdWJsZVRhcFxufTtcblxudmFyIERPVUJMRV9DTElDS19USU1FT1VUID0gNTAwO1xuXG52YXIgRE9VQkxFX1RBUF9ESVNUQU5DRV9USFJFU0hPTEQgPSA1MDtcbnZhciBET1VCTEVfVEFQX1RJTUVPVVQgPSAyNTA7XG5cbmZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZWxlbSwgY2FsbGJhY2spXG57XG4gICAgZWxlbS5vbignZGJsY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICBpZiAoIWV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBnZXRSZWxhdGl2ZU9mZnNldChldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgdGhlIGNvbnRyb2wga2V5IGZvciBtYWNzIChpbiBjb25qdW5jdGlvbiB3aXRoIGRvdWJsZS1jbGlja2luZylcbiAgICAvLyBGSVhNRTogRG9lcyBhIGNsaWNrIGdldCBoYW5kbGVkIHdpdGggY3RybCBwcmVzc2VkIG9uIG5vbi1NYWNzP1xuICAgIHZhciB0cmFja2VyID0gY3JlYXRlRG91YmxlRXZlbnRUcmFja2VyKERPVUJMRV9DTElDS19USU1FT1VUKTtcblxuICAgIGVsZW0ub24oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRyYWNrZXIuaXNUcmlnZ2VyZWQoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsIGdldFJlbGF0aXZlT2Zmc2V0KGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhY2tlci50cmlnZ2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25QaW5jaChlbGVtLCBjYWxsYmFjaylcbntcbiAgICB2YXIgc3RhcnREaXN0YW5jZSA9IDA7XG5cbiAgICBlbGVtLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpXG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZShcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWxlbS5vbigndG91Y2htb3ZlJywgZnVuY3Rpb24oZXZlbnQpXG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICB2YXIgbW92ZURpc3RhbmNlID0gZGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzWzFdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgdG91Y2hlc1sxXS5jbGllbnRZXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgem9vbURlbHRhID0gbW92ZURpc3RhbmNlIC0gc3RhcnREaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHpvb21EZWx0YSkgPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaENlbnRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVg6ICh0b3VjaGVzWzBdLmNsaWVudFggKyB0b3VjaGVzWzFdLmNsaWVudFgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6ICh0b3VjaGVzWzBdLmNsaWVudFkgKyB0b3VjaGVzWzFdLmNsaWVudFkpIC8gMlxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCwgZ2V0UmVsYXRpdmVPZmZzZXQoZXZlbnQuY3VycmVudFRhcmdldCwgdG91Y2hDZW50ZXIpLCBzdGFydERpc3RhbmNlLCBtb3ZlRGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRG91YmxlVGFwKGVsZW0sIGNhbGxiYWNrKVxue1xuICAgIHZhciB0cmFja2VyID0gY3JlYXRlRG91YmxlRXZlbnRUcmFja2VyKERPVUJMRV9UQVBfVElNRU9VVCk7XG4gICAgdmFyIGZpcnN0VGFwID0gbnVsbDtcblxuICAgIGVsZW0ub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgLy8gUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGZpcmluZ1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0cmFja2VyLmlzVHJpZ2dlcmVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyYWNrZXIucmVzZXQoKTtcblxuICAgICAgICAgICAgLy8gRG91YmxldGFwIGhhcyBvY2N1cnJlZFxuICAgICAgICAgICAgdmFyIHNlY29uZFRhcCA9IHtcbiAgICAgICAgICAgICAgICBwYWdlWDogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiBldmVudC5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIGZpcnN0IHRhcCBpcyBjbG9zZSB0byBzZWNvbmQgdGFwIChwcmV2ZW50cyBpbnRlcmZlcmVuY2Ugd2l0aCBzY2FsZSBldmVudClcbiAgICAgICAgICAgIHZhciB0YXBEaXN0YW5jZSA9IGRpc3RhbmNlKGZpcnN0VGFwLnBhZ2VYLCBmaXJzdFRhcC5wYWdlWSwgc2Vjb25kVGFwLnBhZ2VYLCBzZWNvbmRUYXAucGFnZVkpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBDb3VsZCBnaXZlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdGhhbiBzZWNvbmRUYXAgdG8gY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0YXBEaXN0YW5jZSA8IERPVUJMRV9UQVBfRElTVEFOQ0VfVEhSRVNIT0xEKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBnZXRSZWxhdGl2ZU9mZnNldChldmVudC5jdXJyZW50VGFyZ2V0LCBzZWNvbmRUYXApKTtcblxuICAgICAgICAgICAgZmlyc3RUYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZmlyc3RUYXAgPSB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0cmFja2VyLnRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBQeXRoYWdvcmVhbiB0aGVvcmVtIHRvIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzICh1c2VkIGZvclxuLy8gY2FsY3VsYXRpbmcgZmluZ2VyIGRpc3RhbmNlIGZvciBkb3VibGUtdGFwIGFuZCBwaW5jaC16b29tKVxuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xufVxuXG4vLyBVdGlsaXR5IHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbiBldmVudCBoYXMgYmVlbiB0cmlnZ2VyZWQgdHdpY2Vcbi8vIGR1cmluZyBhIGEgZ2l2ZW4gZHVyYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZURvdWJsZUV2ZW50VHJhY2tlcih0aW1lb3V0RHVyYXRpb24pXG57XG4gICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc2V0VGltZW91dCgpO1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBpc1RyaWdnZXJlZDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJlZDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVzZXRUaW1lb3V0KClcbiAgICB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVPZmZzZXQoZWxlbSwgcGFnZUNvb3JkcylcbntcbiAgICB2YXIgYm91bmRzID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBhZ2VDb29yZHMucGFnZVggLSBib3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBwYWdlQ29vcmRzLnBhZ2VZIC0gYm91bmRzLnRvcFxuICAgIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL2dlc3R1cmUtZXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtYXhCeSA9IHJlcXVpcmUoJ2xvZGFzaC5tYXhieScpO1xudmFyIFBhZ2VUb29sc092ZXJsYXkgPSByZXF1aXJlKCcuL3BhZ2UtdG9vbHMtb3ZlcmxheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50SGFuZGxlcjtcblxuZnVuY3Rpb24gRG9jdW1lbnRIYW5kbGVyKHZpZXdlckNvcmUpXG57XG4gICAgdGhpcy5fdmlld2VyQ29yZSA9IHZpZXdlckNvcmU7XG4gICAgdGhpcy5fdmlld2VyU3RhdGUgPSB2aWV3ZXJDb3JlLmdldEludGVybmFsU3RhdGUoKTtcbiAgICB0aGlzLl9vdmVybGF5cyA9IFtdO1xuXG4gICAgaWYgKHZpZXdlckNvcmUuZ2V0UGFnZVRvb2xzKCkubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdmFyIG51bVBhZ2VzID0gdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpLm51bVBhZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IG51bVBhZ2VzOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvdmVybGF5ID0gbmV3IFBhZ2VUb29sc092ZXJsYXkoaSwgdmlld2VyQ29yZSk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5cy5wdXNoKG92ZXJsYXkpO1xuICAgICAgICAgICAgdmlld2VyQ29yZS5hZGRQYWdlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVVNFUiBFVkVOVFNcbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUub25Eb3VibGVDbGljayA9IGZ1bmN0aW9uIChldmVudCwgY29vcmRzKVxue1xuICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKTtcbiAgICB2YXIgbmV3Wm9vbUxldmVsID0gZXZlbnQuY3RybEtleSA/IHNldHRpbmdzLnpvb21MZXZlbCAtIDEgOiBzZXR0aW5ncy56b29tTGV2ZWwgKyAxO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fdmlld2VyQ29yZS5nZXRQYWdlUG9zaXRpb25BdFZpZXdwb3J0T2Zmc2V0KGNvb3Jkcyk7XG5cbiAgICB0aGlzLl92aWV3ZXJDb3JlLnpvb20obmV3Wm9vbUxldmVsLCBwb3NpdGlvbik7XG59O1xuXG5Eb2N1bWVudEhhbmRsZXIucHJvdG90eXBlLm9uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQsIGNvb3Jkcywgc3RhcnREaXN0YW5jZSwgZW5kRGlzdGFuY2UpXG57XG4gICAgLy8gRklYTUU6IERvIHRoaXMgY2hlY2sgaW4gYSB3YXkgd2hpY2ggaXMgbGVzcyBzcGFnaGV0dGkgY29kZS15XG4gICAgdmFyIHZpZXdlclN0YXRlID0gdGhpcy5fdmlld2VyQ29yZS5nZXRJbnRlcm5hbFN0YXRlKCk7XG4gICAgdmFyIHNldHRpbmdzID0gdGhpcy5fdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuXG4gICAgdmFyIG5ld1pvb21MZXZlbCA9IE1hdGgubG9nKE1hdGgucG93KDIsIHNldHRpbmdzLnpvb21MZXZlbCkgKiBlbmREaXN0YW5jZSAvIChzdGFydERpc3RhbmNlICogTWF0aC5sb2coMikpKSAvIE1hdGgubG9nKDIpO1xuICAgIG5ld1pvb21MZXZlbCA9IE1hdGgubWF4KHNldHRpbmdzLm1pblpvb21MZXZlbCwgbmV3Wm9vbUxldmVsKTtcbiAgICBuZXdab29tTGV2ZWwgPSBNYXRoLm1pbihzZXR0aW5ncy5tYXhab29tTGV2ZWwsIG5ld1pvb21MZXZlbCk7XG5cbiAgICBpZiAobmV3Wm9vbUxldmVsID09PSBzZXR0aW5ncy56b29tTGV2ZWwpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVBvc2l0aW9uQXRWaWV3cG9ydE9mZnNldChjb29yZHMpO1xuXG4gICAgdmFyIGxheW91dCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuICAgIHZhciBjZW50ZXJPZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZVRvVmlld3BvcnRDZW50ZXJPZmZzZXQocG9zaXRpb24uYW5jaG9yUGFnZSwgdmlld2VyU3RhdGUudmlld3BvcnQpO1xuICAgIHZhciBzY2FsZVJhdGlvID0gMSAvIE1hdGgucG93KDIsIHNldHRpbmdzLnpvb21MZXZlbCAtIG5ld1pvb21MZXZlbCk7XG5cbiAgICB0aGlzLl92aWV3ZXJDb3JlLnJlbG9hZCh7XG4gICAgICAgIHpvb21MZXZlbDogbmV3Wm9vbUxldmVsLFxuICAgICAgICBnb0RpcmVjdGx5VG86IHBvc2l0aW9uLmFuY2hvclBhZ2UsXG4gICAgICAgIGhvcml6b250YWxPZmZzZXQ6IChjZW50ZXJPZmZzZXQueCAtIHBvc2l0aW9uLm9mZnNldC5sZWZ0KSArIHBvc2l0aW9uLm9mZnNldC5sZWZ0ICogc2NhbGVSYXRpbyxcbiAgICAgICAgdmVydGljYWxPZmZzZXQ6IChjZW50ZXJPZmZzZXQueSAtIHBvc2l0aW9uLm9mZnNldC50b3ApICsgcG9zaXRpb24ub2Zmc2V0LnRvcCAqIHNjYWxlUmF0aW9cbiAgICB9KTtcbn07XG5cbi8vIFZJRVcgRVZFTlRTXG5Eb2N1bWVudEhhbmRsZXIucHJvdG90eXBlLm9uVmlld1dpbGxMb2FkID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl92aWV3ZXJDb3JlLnB1Ymxpc2goJ0RvY3VtZW50V2lsbExvYWQnLCB0aGlzLl92aWV3ZXJDb3JlLmdldFNldHRpbmdzKCkpO1xufTtcblxuRG9jdW1lbnRIYW5kbGVyLnByb3RvdHlwZS5vblZpZXdEaWRMb2FkID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBUT0RPOiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgdG8gaGFuZGxlIGNoYW5nZXMgb24gdmlldyB1cGRhdGUsIG5vdFxuICAgIC8vIGluaXRpYWwgbG9hZFxuICAgIHRoaXMuX2hhbmRsZVpvb21MZXZlbENoYW5nZSgpO1xuXG4gICAgdmFyIGN1cnJlbnRQYWdlSW5kZXggPSB0aGlzLl92aWV3ZXJDb3JlLmdldFNldHRpbmdzKCkuY3VycmVudFBhZ2VJbmRleDtcbiAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLl92aWV3ZXJDb3JlLmdldFBhZ2VOYW1lKGN1cnJlbnRQYWdlSW5kZXgpO1xuICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaChcIkRvY3VtZW50RGlkTG9hZFwiLCBjdXJyZW50UGFnZUluZGV4LCBmaWxlTmFtZSk7XG59O1xuXG5Eb2N1bWVudEhhbmRsZXIucHJvdG90eXBlLm9uVmlld0RpZFVwZGF0ZSA9IGZ1bmN0aW9uIChyZW5kZXJlZFBhZ2VzLCB0YXJnZXRQYWdlKVxue1xuICAgIHZhciBjdXJyZW50UGFnZSA9ICh0YXJnZXRQYWdlICE9PSBudWxsKSA/XG4gICAgICAgIHRhcmdldFBhZ2UgOlxuICAgICAgICBnZXRDZW50ZXJtb3N0UGFnZShyZW5kZXJlZFBhZ2VzLCB0aGlzLl92aWV3ZXJDb3JlLmdldEN1cnJlbnRMYXlvdXQoKSwgdGhpcy5fdmlld2VyQ29yZS5nZXRWaWV3cG9ydCgpKTtcblxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgY3VycmVudCBwYWdlIGlmIHRoZXJlIGlzIG5vIHBhZ2UgaW4gdGhlIHZpZXdwb3J0XG4gICAgLy8gRklYTUU6IFdvdWxkIGJlIGJldHRlciB0byBmYWxsIGJhY2sgdG8gdGhlIHBhZ2UgY2xvc2VzdCB0byB0aGUgdmlld3BvcnRcbiAgICBpZiAoY3VycmVudFBhZ2UgIT09IG51bGwpXG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUuc2V0Q3VycmVudFBhZ2UoY3VycmVudFBhZ2UpO1xuXG4gICAgaWYgKHRhcmdldFBhZ2UgIT09IG51bGwpXG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaChcIlZpZXdlckRpZEp1bXBcIiwgdGFyZ2V0UGFnZSk7XG5cbiAgICB0aGlzLl9oYW5kbGVab29tTGV2ZWxDaGFuZ2UoKTtcbn07XG5cbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZVpvb21MZXZlbENoYW5nZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIHZpZXdlclN0YXRlID0gdGhpcy5fdmlld2VyU3RhdGU7XG4gICAgdmFyIHpvb21MZXZlbCA9IHZpZXdlclN0YXRlLm9wdGlvbnMuem9vbUxldmVsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGluaXRpYWwgbG9hZCwgdHJpZ2dlciB0aGUgem9vbSBldmVudHNcbiAgICBpZiAodmlld2VyU3RhdGUub2xkWm9vbUxldmVsICE9PSB6b29tTGV2ZWwgJiYgdmlld2VyU3RhdGUub2xkWm9vbUxldmVsID49IDApXG4gICAge1xuICAgICAgICBpZiAodmlld2VyU3RhdGUub2xkWm9vbUxldmVsIDwgem9vbUxldmVsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl92aWV3ZXJDb3JlLnB1Ymxpc2goXCJWaWV3ZXJEaWRab29tSW5cIiwgem9vbUxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaChcIlZpZXdlckRpZFpvb21PdXRcIiwgem9vbUxldmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaChcIlZpZXdlckRpZFpvb21cIiwgem9vbUxldmVsKTtcbiAgICB9XG5cbiAgICB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPSB6b29tTGV2ZWw7XG59O1xuXG5Eb2N1bWVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX292ZXJsYXlzLmZvckVhY2goZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAge1xuICAgICAgICB0aGlzLl92aWV3ZXJDb3JlLnJlbW92ZVBhZ2VPdmVybGF5KG92ZXJsYXkpO1xuICAgIH0sIHRoaXMpO1xufTtcblxuZnVuY3Rpb24gZ2V0Q2VudGVybW9zdFBhZ2UocmVuZGVyZWRQYWdlcywgbGF5b3V0LCB2aWV3cG9ydClcbntcbiAgICB2YXIgY2VudGVyWSA9IHZpZXdwb3J0LnRvcCArICh2aWV3cG9ydC5oZWlnaHQgLyAyKTtcbiAgICB2YXIgY2VudGVyWCA9IHZpZXdwb3J0LmxlZnQgKyAodmlld3BvcnQud2lkdGggLyAyKTtcblxuICAgIC8vIEZpbmQgdGhlIG1pbmltdW0gZGlzdGFuY2UgZnJvbSB0aGUgdmlld3BvcnQgY2VudGVyIHRvIGEgcGFnZS5cbiAgICAvLyBDb21wdXRlIG1pbnVzIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGZyb20gdmlld3BvcnQgY2VudGVyIHRvIHRoZSBwYWdlJ3MgYm9yZGVyLlxuICAgIC8vIGh0dHA6Ly9nYW1lZGV2LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80NDQ4My9ob3ctZG8taS1jYWxjdWxhdGUtZGlzdGFuY2UtYmV0d2Vlbi1hLXBvaW50LWFuZC1hbi1heGlzLWFsaWduZWQtcmVjdGFuZ2xlXG4gICAgdmFyIGNlbnRlclBhZ2UgPSBtYXhCeShyZW5kZXJlZFBhZ2VzLCBmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGRpbXMgPSBsYXlvdXQuZ2V0UGFnZURpbWVuc2lvbnMocGFnZUluZGV4KTtcbiAgICAgICAgdmFyIGltYWdlT2Zmc2V0ID0gbGF5b3V0LmdldFBhZ2VPZmZzZXQocGFnZUluZGV4LCB7ZXhjbHVkZVBhZGRpbmc6IGZhbHNlfSk7XG5cbiAgICAgICAgdmFyIG1pZFggPSBpbWFnZU9mZnNldC5sZWZ0ICsgKGRpbXMuaGVpZ2h0IC8gMik7XG4gICAgICAgIHZhciBtaWRZID0gaW1hZ2VPZmZzZXQudG9wICsgKGRpbXMud2lkdGggLyAyKTtcblxuICAgICAgICB2YXIgZHggPSBNYXRoLm1heChNYXRoLmFicyhjZW50ZXJYIC0gbWlkWCkgLSAoZGltcy53aWR0aCAvIDIpLCAwKTtcbiAgICAgICAgdmFyIGR5ID0gTWF0aC5tYXgoTWF0aC5hYnMoY2VudGVyWSAtIG1pZFkpIC0gKGRpbXMuaGVpZ2h0IC8gMiksIDApO1xuXG4gICAgICAgIHJldHVybiAtKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjZW50ZXJQYWdlICE9IG51bGwgPyBjZW50ZXJQYWdlIDogbnVsbDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvZG9jdW1lbnQtaGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2VpdGVyYXRlZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgKSkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzIHRvIG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA+IG90aGVyO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV1cbiAqICBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAqXG4gKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gKiAvLyA9PiB7ICduJzogMiB9XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gKiAvLyA9PiB7ICduJzogMiB9XG4gKi9cbmZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlKSwgYmFzZUd0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1heEJ5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoLm1heGJ5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJ2xvZGFzaC5fc3RyaW5ndG9wYXRoJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xudmFyIG9iamVjdFR5cGVzID0ge1xuICAnZnVuY3Rpb24nOiB0cnVlLFxuICAnb2JqZWN0JzogdHJ1ZVxufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSlcbiAgPyBleHBvcnRzXG4gIDogdW5kZWZpbmVkO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSlcbiAgPyBtb2R1bGVcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHdpbmRvd2AuICovXG52YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG5cbi8qKiBEZXRlY3QgYHRoaXNgIGFzIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG5cbi8qKlxuICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBUaGUgYHRoaXNgIHZhbHVlIGlzIHVzZWQgaWYgaXQncyB0aGUgZ2xvYmFsIG9iamVjdCB0byBhdm9pZCBHcmVhc2Vtb25rZXknc1xuICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fFxuICAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHxcbiAgICBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBnbG9iYWwgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyBgdmFsdWVgIGlmIGl0J3MgYSBnbG9iYWwgb2JqZWN0LCBlbHNlIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUgJiYgY2FjaGUuX19kYXRhX18ubGVuZ3RoID09IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUoY2FjaGUuX19kYXRhX18pO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gIC8vIEF2b2lkIGEgYnVnIGluIElFIDEwLTExIHdoZXJlIG9iamVjdHMgd2l0aCBhIFtbUHJvdG90eXBlXV0gb2YgYG51bGxgLFxuICAvLyB0aGF0IGFyZSBjb21wb3NlZCBlbnRpcmVseSBvZiBpbmRleCBwcm9wZXJ0aWVzLCByZXR1cm4gYGZhbHNlYCBmb3JcbiAgLy8gYGhhc093blByb3BlcnR5YCBjaGVja3Mgb2YgdGhlbS5cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpIHx8XG4gICAgKHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiYga2V5IGluIG9iamVjdCAmJiBnZXRQcm90b3R5cGUob2JqZWN0KSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtib29sZWFufSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy5cbiAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAqICAgICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAgICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICBpZiAoIW9iaklzQXJyKSB7XG4gICAgb2JqVGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIH1cbiAgaWYgKCFvdGhJc0Fycikge1xuICAgIG90aFRhZyA9IGdldFRhZyhvdGhlcik7XG4gICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG4gIH1cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG9iamVjdCksXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvdGhlciksXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRywgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHNraXAgdGhlIGNvbnN0cnVjdG9yXG4gKiBwcm9wZXJ0eSBvZiBwcm90b3R5cGVzIG9yIHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICByZXR1cm4gbmF0aXZlS2V5cyhPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCB1bmRlZmluZWQsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgIH1cbiAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghc2Vlbi5oYXMob3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLmFkZChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWJlcnMsIGRhdGVzIHRvIG1pbGxpc2Vjb25kcyBhbmRcbiAgICAgIC8vIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzXG4gICAgICAvLyBub3QgZXF1YWwuXG4gICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgcmV0dXJuIChvYmplY3QgIT0gK29iamVjdCkgPyBvdGhlciAhPSArb3RoZXIgOiBvYmplY3QgPT0gK290aGVyO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHJldHVybiBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGJhc2VIYXMob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGFcbiAqIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKSB0aGF0IGFmZmVjdHNcbiAqIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gdG9QYWlycyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICByZXN1bHRbbGVuZ3RoXVsyXSA9IGlzU3RyaWN0Q29tcGFyYWJsZShyZXN1bHRbbGVuZ3RoXVsxXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYFtbUHJvdG90eXBlXV1gIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBgW1tQcm90b3R5cGVdXWAuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3RvdHlwZSh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlKE9iamVjdCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIHJlc3VsdCxcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNTdHJpbmcob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGluZGV4IGtleXMgZm9yIGBvYmplY3RgIHZhbHVlcyBvZiBhcnJheXMsXG4gKiBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgc3RyaW5ncywgb3RoZXJ3aXNlIGBudWxsYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fG51bGx9IFJldHVybnMgaW5kZXgga2V5cywgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGluZGV4S2V5cyhvYmplY3QpIHtcbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiB1bmRlZmluZWQ7XG4gIGlmIChpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzU3RyaW5nKG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBpbmNvcnJlY3RseSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgd2VhayBtYXAgY29uc3RydWN0b3JzLFxuICAvLyBhbmQgUGhhbnRvbUpTIDEuOSB3aGljaCByZXR1cm5zICdmdW5jdGlvbicgZm9yIGBOb2RlTGlzdGAgaW5zdGFuY2VzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHVzZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KTtcbiAgaWYgKCEoaXNQcm90byB8fCBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgIHJldHVybiBiYXNlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciBpbmRleGVzID0gaW5kZXhLZXlzKG9iamVjdCksXG4gICAgICBza2lwSW5kZXhlcyA9ICEhaW5kZXhlcyxcbiAgICAgIHJlc3VsdCA9IGluZGV4ZXMgfHwgW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoYmFzZUhhcyhvYmplY3QsIGtleSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkgJiZcbiAgICAgICAgIShpc1Byb3RvICYmIGtleSA9PSAnY29uc3RydWN0b3InKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGVudHJpZXNcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG52YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoLl9iYXNlaXRlcmF0ZWUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2V0b3N0cmluZycpO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xudmFyIG9iamVjdFR5cGVzID0ge1xuICAnZnVuY3Rpb24nOiB0cnVlLFxuICAnb2JqZWN0JzogdHJ1ZVxufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSlcbiAgPyBleHBvcnRzXG4gIDogdW5kZWZpbmVkO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSlcbiAgPyBtb2R1bGVcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHdpbmRvd2AuICovXG52YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG5cbi8qKiBEZXRlY3QgYHRoaXNgIGFzIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG5cbi8qKlxuICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBUaGUgYHRoaXNgIHZhbHVlIGlzIHVzZWQgaWYgaXQncyB0aGUgZ2xvYmFsIG9iamVjdCB0byBhdm9pZCBHcmVhc2Vtb25rZXknc1xuICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fFxuICAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHxcbiAgICBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBnbG9iYWwgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyBgdmFsdWVgIGlmIGl0J3MgYSBnbG9iYWwgb2JqZWN0LCBlbHNlIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCB3ZWFrIG1hcCBjb25zdHJ1Y3RvcnMsXG4gIC8vIGFuZCBQaGFudG9tSlMgMS45IHdoaWNoIHJldHVybnMgJ2Z1bmN0aW9uJyBmb3IgYE5vZGVMaXN0YCBpbnN0YW5jZXMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC5fc3RyaW5ndG9wYXRoL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xudmFyIG9iamVjdFR5cGVzID0ge1xuICAnZnVuY3Rpb24nOiB0cnVlLFxuICAnb2JqZWN0JzogdHJ1ZVxufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSlcbiAgPyBleHBvcnRzXG4gIDogdW5kZWZpbmVkO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSlcbiAgPyBtb2R1bGVcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHdpbmRvd2AuICovXG52YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG5cbi8qKiBEZXRlY3QgYHRoaXNgIGFzIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG5cbi8qKlxuICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBUaGUgYHRoaXNgIHZhbHVlIGlzIHVzZWQgaWYgaXQncyB0aGUgZ2xvYmFsIG9iamVjdCB0byBhdm9pZCBHcmVhc2Vtb25rZXknc1xuICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fFxuICAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHxcbiAgICBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBnbG9iYWwgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyBgdmFsdWVgIGlmIGl0J3MgYSBnbG9iYWwgb2JqZWN0LCBlbHNlIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoLl9zdHJpbmd0b3BhdGgvfi9sb2Rhc2guX2Jhc2V0b3N0cmluZy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlVG9vbHNPdmVybGF5O1xuXG5mdW5jdGlvbiBQYWdlVG9vbHNPdmVybGF5KHBhZ2VJbmRleCwgdmlld2VyQ29yZSlcbntcbiAgICB0aGlzLnBhZ2UgPSBwYWdlSW5kZXg7XG5cbiAgICB0aGlzLl92aWV3ZXJDb3JlID0gdmlld2VyQ29yZTtcblxuICAgIHRoaXMuX2lubmVyRWxlbWVudCA9IHZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKS5pbm5lckVsZW1lbnQ7XG4gICAgdGhpcy5fcGFnZVRvb2xzRWxlbSA9IG51bGw7XG59XG5cblBhZ2VUb29sc092ZXJsYXkucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fcGFnZVRvb2xzRWxlbSA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5faW5pdGlhbGl6ZVBhZ2VUb29sQnV0dG9ucygpO1xuXG4gICAgICAgIHRoaXMuX3BhZ2VUb29sc0VsZW0gPSBlbHQoJ2RpdicsIHtjbGFzczogJ2RpdmEtcGFnZS10b29scy13cmFwcGVyJ30sXG4gICAgICAgICAgICBlbHQoJ2RpdicsIHtjbGFzczogJ2RpdmEtcGFnZS10b29scyd9LCBidXR0b25zKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHRoaXMuX2lubmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wYWdlVG9vbHNFbGVtKTtcbn07XG5cblBhZ2VUb29sc092ZXJsYXkucHJvdG90eXBlLl9pbml0aWFsaXplUGFnZVRvb2xCdXR0b25zID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBDYWxsYmFjayBwYXJhbWV0ZXJzXG4gICAgdmFyIHNldHRpbmdzID0gdGhpcy5fdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICB2YXIgcGFnZUluZGV4ID0gdGhpcy5wYWdlO1xuXG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVRvb2xzKCkubWFwKGZ1bmN0aW9uIChwbHVnaW4pXG4gICAge1xuICAgICAgICAvLyBJZiB0aGUgdGl0bGUgdGV4dCBpcyB1bmRlZmluZWQsIHVzZSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luXG4gICAgICAgIHZhciB0aXRsZVRleHQgPSBwbHVnaW4udGl0bGVUZXh0IHx8IHBsdWdpbi5wbHVnaW5OYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBwbHVnaW4ucGx1Z2luTmFtZS5zdWJzdHJpbmcoMSkgKyBcIiBwbHVnaW5cIjtcblxuICAgICAgICB2YXIgYnV0dG9uID0gZWx0KCdkaXYnLCB7XG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtJyArIHBsdWdpbi5wbHVnaW5OYW1lICsgJy1pY29uJyxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZVRleHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBwbHVnaW4uaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBldmVudCwgc2V0dGluZ3MsIHB1YmxpY0luc3RhbmNlLCBwYWdlSW5kZXgpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGZpcmluZyBvZiBlbXVsYXRlZCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHBsdWdpbi5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50LCBzZXR0aW5ncywgcHVibGljSW5zdGFuY2UsIHBhZ2VJbmRleCk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH0sIHRoaXMpO1xufTtcblxuUGFnZVRvb2xzT3ZlcmxheS5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5faW5uZXJFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3BhZ2VUb29sc0VsZW0pO1xufTtcblxuUGFnZVRvb2xzT3ZlcmxheS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIHBvcyA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVJlZ2lvbih0aGlzLnBhZ2UsIHtcbiAgICAgICAgZXhjbHVkZVBhZGRpbmc6IHRydWUsXG4gICAgICAgIGluY29ycG9yYXRlVmlld3BvcnQ6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuX3BhZ2VUb29sc0VsZW0uc3R5bGUudG9wID0gcG9zLnRvcCArICdweCc7XG4gICAgdGhpcy5fcGFnZVRvb2xzRWxlbS5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyAncHgnO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvcGFnZS10b29scy1vdmVybGF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtYXhCeSA9IHJlcXVpcmUoJ2xvZGFzaC5tYXhieScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWRIYW5kbGVyO1xuXG5mdW5jdGlvbiBHcmlkSGFuZGxlcih2aWV3ZXJDb3JlKVxue1xuICAgIHRoaXMuX3ZpZXdlckNvcmUgPSB2aWV3ZXJDb3JlO1xufVxuXG4vLyBVU0VSIEVWRU5UU1xuR3JpZEhhbmRsZXIucHJvdG90eXBlLm9uRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQsIGNvb3JkcylcbntcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl92aWV3ZXJDb3JlLmdldFBhZ2VQb3NpdGlvbkF0Vmlld3BvcnRPZmZzZXQoY29vcmRzKTtcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLl92aWV3ZXJDb3JlLmdldEN1cnJlbnRMYXlvdXQoKTtcbiAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3ZXJDb3JlLmdldFZpZXdwb3J0KCk7XG4gICAgdmFyIHBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0ID0gbGF5b3V0LmdldFBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0KHBvc2l0aW9uLmFuY2hvclBhZ2UsIHZpZXdwb3J0KTtcblxuICAgIHRoaXMuX3ZpZXdlckNvcmUucmVsb2FkKHtcbiAgICAgICAgaW5HcmlkOiBmYWxzZSxcbiAgICAgICAgZ29EaXJlY3RseVRvOiBwb3NpdGlvbi5hbmNob3JQYWdlLFxuICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBwYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldC54ICsgcG9zaXRpb24ub2Zmc2V0LmxlZnQsXG4gICAgICAgIHZlcnRpY2FsT2Zmc2V0OiBwYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldC55ICsgcG9zaXRpb24ub2Zmc2V0LnRvcFxuICAgIH0pO1xufTtcblxuR3JpZEhhbmRsZXIucHJvdG90eXBlLm9uUGluY2ggPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3ZpZXdlckNvcmUucmVsb2FkKHsgaW5HcmlkOiBmYWxzZSB9KTtcbn07XG5cbi8vIFZJRVcgRVZFTlRTXG5HcmlkSGFuZGxlci5wcm90b3R5cGUub25WaWV3V2lsbExvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIEZJWE1FKHdhYmFpbik6IFNob3VsZCBzb21ldGhpbmcgaGFwcGVuIGhlcmU/XG4gICAgLyogTm8tb3AgKi9cbn07XG5cbkdyaWRIYW5kbGVyLnByb3RvdHlwZS5vblZpZXdEaWRMb2FkID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBGSVhNRSh3YWJhaW4pOiBTaG91bGQgc29tZXRoaW5nIGhhcHBlbiBoZXJlP1xuICAgIC8qIE5vLW9wICovXG59O1xuXG5HcmlkSGFuZGxlci5wcm90b3R5cGUub25WaWV3RGlkVXBkYXRlID0gZnVuY3Rpb24gKHJlbmRlcmVkUGFnZXMsIHRhcmdldFBhZ2UpXG57XG4gICAgaWYgKHRhcmdldFBhZ2UgIT09IG51bGwpXG4gICAge1xuICAgICAgICB0aGlzLl92aWV3ZXJDb3JlLnNldEN1cnJlbnRQYWdlKHRhcmdldFBhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2VsZWN0IHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgZmlyc3Qgcm93IGlmIGl0IGlzIGZ1bGx5IHZpc2libGUsIG9yIGZyb21cbiAgICAvLyB0aGUgc2Vjb25kIHJvdyBpZiBpdCBpcyBmdWxseSB2aXNpYmxlLCBvciBmcm9tIHRoZSBjZW50ZXJtb3N0IHJvdyBvdGhlcndpc2UuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgcGFnZSBpcyBpbiB0aGF0IGdyb3VwIHRoZW4gZG9uJ3QgY2hhbmdlIGl0LiBPdGhlcndpc2UsIHNldFxuICAgIC8vIHRoZSBjdXJyZW50IHBhZ2UgdG8gdGhlIGdyb3VwJ3MgZmlyc3QgcGFnZS5cblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLl92aWV3ZXJDb3JlLmdldEN1cnJlbnRMYXlvdXQoKTtcbiAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgcmVuZGVyZWRQYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZ3JvdXAgPSBsYXlvdXQuZ2V0UGFnZUluZm8ocGFnZUluZGV4KS5ncm91cDtcbiAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPT09IDAgfHwgZ3JvdXAgIT09IGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0pXG4gICAgICAgICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3ZXJDb3JlLmdldFZpZXdwb3J0KCk7XG4gICAgdmFyIGNob3Nlbkdyb3VwO1xuXG4gICAgaWYgKGdyb3Vwcy5sZW5ndGggPT09IDEgfHwgZ3JvdXBzWzBdLnJlZ2lvbi50b3AgPj0gdmlld3BvcnQudG9wKVxuICAgICAgICBjaG9zZW5Hcm91cCA9IGdyb3Vwc1swXTtcbiAgICBlbHNlIGlmIChncm91cHNbMV0ucmVnaW9uLmJvdHRvbSA8PSB2aWV3cG9ydC5ib3R0b20pXG4gICAgICAgIGNob3Nlbkdyb3VwID0gZ3JvdXBzWzFdO1xuICAgIGVsc2VcbiAgICAgICAgY2hvc2VuR3JvdXAgPSBnZXRDZW50ZXJtb3N0R3JvdXAoZ3JvdXBzLCB2aWV3cG9ydCk7XG5cbiAgICB2YXIgY3VycmVudFBhZ2UgPSB0aGlzLl92aWV3ZXJDb3JlLmdldFNldHRpbmdzKCkuY3VycmVudFBhZ2VJbmRleDtcblxuICAgIHZhciBoYXNDdXJyZW50UGFnZSA9IGNob3Nlbkdyb3VwLnBhZ2VzLnNvbWUoZnVuY3Rpb24gKHBhZ2UpXG4gICAge1xuICAgICAgICByZXR1cm4gcGFnZS5pbmRleCA9PT0gY3VycmVudFBhZ2U7XG4gICAgfSk7XG5cbiAgICBpZiAoIWhhc0N1cnJlbnRQYWdlKVxuICAgICAgICB0aGlzLl92aWV3ZXJDb3JlLnNldEN1cnJlbnRQYWdlKGNob3Nlbkdyb3VwLnBhZ2VzWzBdLmluZGV4KTtcbn07XG5cbkdyaWRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBOby1vcFxufTtcblxuZnVuY3Rpb24gZ2V0Q2VudGVybW9zdEdyb3VwKGdyb3Vwcywgdmlld3BvcnQpXG57XG4gICAgdmFyIHZpZXdwb3J0TWlkZGxlID0gdmlld3BvcnQudG9wICsgdmlld3BvcnQuaGVpZ2h0IC8gMjtcblxuICAgIHJldHVybiBtYXhCeShncm91cHMsIGZ1bmN0aW9uIChncm91cClcbiAgICB7XG4gICAgICAgIHZhciBncm91cE1pZGRsZSA9IGdyb3VwLnJlZ2lvbi50b3AgKyBncm91cC5kaW1lbnNpb25zLmhlaWdodCAvIDI7XG4gICAgICAgIHJldHVybiAtTWF0aC5hYnModmlld3BvcnRNaWRkbGUgLSBncm91cE1pZGRsZSk7XG4gICAgfSk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL2dyaWQtaGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFBhZ2VPdmVybGF5TWFuYWdlcjtcblxuLyoqXG4gKiBNYW5hZ2VzIGEgY29sbGVjdGlvbiBvZiBwYWdlIG92ZXJsYXlzLCB3aGljaCBpbXBsZW1lbnQgYSBsb3ctbGV2ZWxcbiAqIEFQSSBmb3Igc3luY2hyb25pemluZyBIVE1MIHBhZ2VzIHRvIHRoZSBjYW52YXMuIEVhY2ggb3ZlcmxheSBuZWVkc1xuICogdG8gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvdG9jb2w6XG4gKlxuICogICBtb3VudCgpOiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgZmlyc3QgcmVuZGVyZWRcbiAqICAgcmVmcmVzaCgpOiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgbW92ZWRcbiAqICAgdW5tb3VudCgpOiBDYWxsZWQgd2hlbiBhIHByZXZpb3VzbHkgcmVuZGVyZWQgcGFnZSBoYXMgc3RvcHBlZCBiZWluZyByZW5kZXJlZFxuICpcbiAqIEBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIFBhZ2VPdmVybGF5TWFuYWdlcigpXG57XG4gICAgdGhpcy5fcGFnZXMgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlZFBhZ2VzID0gW107XG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlTWFwID0ge307XG59XG5cblBhZ2VPdmVybGF5TWFuYWdlci5wcm90b3R5cGUuYWRkT3ZlcmxheSA9IGZ1bmN0aW9uIChvdmVybGF5KVxue1xuICAgIHZhciBvdmVybGF5c0J5UGFnZSA9IHRoaXMuX3BhZ2VzW292ZXJsYXkucGFnZV0gfHwgKHRoaXMuX3BhZ2VzW292ZXJsYXkucGFnZV0gPSBbXSk7XG5cbiAgICBvdmVybGF5c0J5UGFnZS5wdXNoKG92ZXJsYXkpO1xuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkUGFnZU1hcFtvdmVybGF5LnBhZ2VdKVxuICAgICAgICBvdmVybGF5Lm1vdW50KCk7XG59O1xuXG5QYWdlT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZU92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcmxheSlcbntcbiAgICB2YXIgcGFnZSA9IG92ZXJsYXkucGFnZTtcbiAgICB2YXIgb3ZlcmxheXNCeVBhZ2UgPSB0aGlzLl9wYWdlc1twYWdlXTtcblxuICAgIGlmICghb3ZlcmxheXNCeVBhZ2UpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBvdmVybGF5SW5kZXggPSBvdmVybGF5c0J5UGFnZS5pbmRleE9mKG92ZXJsYXkpO1xuXG4gICAgaWYgKG92ZXJsYXlJbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZFBhZ2VNYXBbcGFnZV0pXG4gICAgICAgIG92ZXJsYXlzQnlQYWdlW292ZXJsYXlJbmRleF0udW5tb3VudCgpO1xuXG4gICAgb3ZlcmxheXNCeVBhZ2Uuc3BsaWNlKG92ZXJsYXlJbmRleCwgMSk7XG5cbiAgICBpZiAob3ZlcmxheXNCeVBhZ2UubGVuZ3RoID09PSAwKVxuICAgICAgICBkZWxldGUgdGhpcy5fcGFnZXNbcGFnZV07XG59O1xuXG5QYWdlT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU92ZXJsYXlzID0gZnVuY3Rpb24gKHJlbmRlcmVkUGFnZXMpXG57XG4gICAgdmFyIHByZXZpb3VzbHlSZW5kZXJlZCA9IHRoaXMuX3JlbmRlcmVkUGFnZXM7XG4gICAgdmFyIG5ld1JlbmRlcmVkTWFwID0ge307XG5cbiAgICByZW5kZXJlZFBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIG5ld1JlbmRlcmVkTWFwW3BhZ2VJbmRleF0gPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZWRQYWdlTWFwW3BhZ2VJbmRleF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkUGFnZU1hcFtwYWdlSW5kZXhdID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5faW52b2tlT25PdmVybGF5cyhwYWdlSW5kZXgsIGZ1bmN0aW9uIChvdmVybGF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkubW91bnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBwcmV2aW91c2x5UmVuZGVyZWQuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKG5ld1JlbmRlcmVkTWFwW3BhZ2VJbmRleF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZU9uT3ZlcmxheXMocGFnZUluZGV4LCBmdW5jdGlvbiAob3ZlcmxheSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5LnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVkUGFnZU1hcFtwYWdlSW5kZXhdO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnZva2VPbk92ZXJsYXlzKHBhZ2VJbmRleCwgZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS51bm1vdW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlcyA9IHJlbmRlcmVkUGFnZXM7XG59O1xuXG5QYWdlT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLl9pbnZva2VPbk92ZXJsYXlzID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgZnVuYylcbntcbiAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLl9wYWdlc1twYWdlSW5kZXhdO1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgb3ZlcmxheXMuZm9yRWFjaChmdW5jLCB0aGlzKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3BhZ2Utb3ZlcmxheS1tYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpSZW5kZXJlcicpO1xudmFyIGRlYnVnUGFpbnRzID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpSZW5kZXJlcjpwYWludHMnKTtcblxudmFyIGVsdCA9IHJlcXVpcmUoJy4vdXRpbHMvZWx0Jyk7XG5cbnZhciBDb21wb3NpdGVJbWFnZSA9IHJlcXVpcmUoJy4vY29tcG9zaXRlLWltYWdlJyk7XG52YXIgRG9jdW1lbnRMYXlvdXQgPSByZXF1aXJlKCcuL2RvY3VtZW50LWxheW91dCcpO1xudmFyIEltYWdlQ2FjaGUgPSByZXF1aXJlKCcuL2ltYWdlLWNhY2hlJyk7XG52YXIgSW1hZ2VSZXF1ZXN0SGFuZGxlciA9IHJlcXVpcmUoJy4vaW1hZ2UtcmVxdWVzdC1oYW5kbGVyJyk7XG52YXIgSW50ZXJwb2xhdGVBbmltYXRpb24gPSByZXF1aXJlKCcuL2ludGVycG9sYXRlLWFuaW1hdGlvbicpO1xuXG52YXIgUkVRVUVTVF9ERUJPVU5DRV9JTlRFUlZBTCA9IDI1MDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zLCBob29rcylcbntcbiAgICB0aGlzLl92aWV3cG9ydCA9IG9wdGlvbnMudmlld3BvcnQ7XG4gICAgdGhpcy5fb3V0ZXJFbGVtZW50ID0gb3B0aW9ucy5vdXRlckVsZW1lbnQ7XG4gICAgdGhpcy5fZG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5pbm5lckVsZW1lbnQ7XG5cbiAgICB0aGlzLl9ob29rcyA9IGhvb2tzIHx8IHt9O1xuXG4gICAgdGhpcy5fY2FudmFzID0gZWx0KCdjYW52YXMnLCB7IGNsYXNzOiAnZGl2YS12aWV3ZXItY2FudmFzJyB9KTtcbiAgICB0aGlzLl9jdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHRoaXMubGF5b3V0ID0gbnVsbDtcblxuICAgIHRoaXMuX3NvdXJjZVJlc29sdmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZFBhZ2VzID0gbnVsbDtcbiAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgIHRoaXMuX3pvb21MZXZlbCA9IG51bGw7XG4gICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZFRpbGVzID0gbnVsbDtcbiAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuXG4gICAgLy8gRklYTUUod2FiYWluKTogV2hhdCBsZXZlbCBzaG91bGQgdGhpcyBiZSBtYWludGFpbmVkIGF0P1xuICAgIC8vIERpdmEgZ2xvYmFsP1xuICAgIHRoaXMuX2NhY2hlID0gbmV3IEltYWdlQ2FjaGUoKTtcbiAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMgPSB7fTtcbn1cblxuUmVuZGVyZXIuZ2V0Q29tcGF0aWJpbGl0eUVycm9ycyA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ1lvdXIgYnJvd3NlciBsYWNrcyBzdXBwb3J0IGZvciB0aGUgJywgZWx0KCdwcmUnLCAnY2FudmFzJyksXG4gICAgICAgICcgZWxlbWVudC4gUGxlYXNlIHVwZ3JhZGUgeW91ciBicm93c2VyLidcbiAgICBdO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29uZmlnLCB2aWV3cG9ydFBvc2l0aW9uLCBzb3VyY2VSZXNvbHZlcilcbntcbiAgICB0aGlzLl9jbGVhckFuaW1hdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuX2hvb2tzLm9uVmlld1dpbGxMb2FkKVxuICAgICAgICB0aGlzLl9ob29rcy5vblZpZXdXaWxsTG9hZCgpO1xuXG4gICAgdGhpcy5fc291cmNlUmVzb2x2ZXIgPSBzb3VyY2VSZXNvbHZlcjtcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzID0ge307XG4gICAgdGhpcy5fc2V0TGF5b3V0VG9ab29tTGV2ZWwodmlld3BvcnRQb3NpdGlvbi56b29tTGV2ZWwpO1xuXG4gICAgLy8gRklYTUUod2FiYWluKTogUmVtb3ZlIHRoaXMgd2hlbiB0aGVyZSdzIG1vcmUgY29uZmlkZW5jZSB0aGUgY2hlY2sgc2hvdWxkbid0IGJlIG5lZWRlZFxuICAgIGlmICghdGhpcy5sYXlvdXQuZ2V0UGFnZUluZm8odmlld3BvcnRQb3NpdGlvbi5hbmNob3JQYWdlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhZ2U6ICcgKyB2aWV3cG9ydFBvc2l0aW9uLmFuY2hvclBhZ2UpO1xuXG4gICAgaWYgKHRoaXMuX2NhbnZhcy53aWR0aCAhPT0gdGhpcy5fdmlld3BvcnQud2lkdGggfHwgdGhpcy5fY2FudmFzLmhlaWdodCAhPT0gdGhpcy5fdmlld3BvcnQuaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgZGVidWcoJ0NhbnZhcyBkaW1lbnNpb24gY2hhbmdlOiAoJXMsICVzKSAtPiAoJXMsICVzKScsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0LndpZHRoLCB0aGlzLl92aWV3cG9ydC5oZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHRoaXMuX3ZpZXdwb3J0LndpZHRoO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gdGhpcy5fdmlld3BvcnQuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdSZWxvYWQsIG5vIHNpemUgY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IFdoYXQgaG9va3Mgc2hvdWxkIGJlIGNhbGxlZCBoZXJlP1xuICAgIHRoaXMuZ290byh2aWV3cG9ydFBvc2l0aW9uLmFuY2hvclBhZ2UsIHZpZXdwb3J0UG9zaXRpb24udmVydGljYWxPZmZzZXQsIHZpZXdwb3J0UG9zaXRpb24uaG9yaXpvbnRhbE9mZnNldCk7XG5cbiAgICBpZiAodGhpcy5fY2FudmFzLnBhcmVudE5vZGUgIT09IHRoaXMuX291dGVyRWxlbWVudClcbiAgICAgICAgdGhpcy5fb3V0ZXJFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9jYW52YXMsIHRoaXMuX291dGVyRWxlbWVudC5maXJzdENoaWxkKTtcblxuICAgIGlmICh0aGlzLl9ob29rcy5vblZpZXdEaWRMb2FkKVxuICAgICAgICB0aGlzLl9ob29rcy5vblZpZXdEaWRMb2FkKCk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX3NldFZpZXdwb3J0UG9zaXRpb24gPSBmdW5jdGlvbiAodmlld3BvcnRQb3NpdGlvbilcbntcbiAgICBpZiAodmlld3BvcnRQb3NpdGlvbi56b29tTGV2ZWwgIT09IHRoaXMuX3pvb21MZXZlbClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl96b29tTGV2ZWwgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY3VycmVudCB2aWV3IGlzIG5vdCB6b29tYWJsZScpO1xuICAgICAgICBlbHNlIGlmICh2aWV3cG9ydFBvc2l0aW9uLnpvb21MZXZlbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjdXJyZW50IHZpZXcgcmVxdWlyZXMgYSB6b29tIGxldmVsJyk7XG5cbiAgICAgICAgdGhpcy5fc2V0TGF5b3V0VG9ab29tTGV2ZWwodmlld3BvcnRQb3NpdGlvbi56b29tTGV2ZWwpO1xuICAgIH1cblxuICAgIHRoaXMuX2dvdG8odmlld3BvcnRQb3NpdGlvbi5hbmNob3JQYWdlLCB2aWV3cG9ydFBvc2l0aW9uLnZlcnRpY2FsT2Zmc2V0LCB2aWV3cG9ydFBvc2l0aW9uLmhvcml6b250YWxPZmZzZXQpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9zZXRMYXlvdXRUb1pvb21MZXZlbCA9IGZ1bmN0aW9uICh6b29tTGV2ZWwpXG57XG4gICAgdGhpcy5sYXlvdXQgPSBuZXcgRG9jdW1lbnRMYXlvdXQodGhpcy5fY29uZmlnLCB6b29tTGV2ZWwpO1xuICAgIHRoaXMuX3pvb21MZXZlbCA9IHpvb21MZXZlbDtcblxuICAgIGVsdC5zZXRBdHRyaWJ1dGVzKHRoaXMuX2RvY3VtZW50RWxlbWVudCwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmxheW91dC5kaW1lbnNpb25zLmhlaWdodCArICdweCcsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5sYXlvdXQuZGltZW5zaW9ucy53aWR0aCArICdweCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdmlld3BvcnQuc2V0SW5uZXJEaW1lbnNpb25zKHRoaXMubGF5b3V0LmRpbWVuc2lvbnMpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmFkanVzdCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pXG57XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb24oKTtcblxuICAgIHRoaXMuX3JlbmRlcihkaXJlY3Rpb24pO1xuXG4gICAgaWYgKHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSh0aGlzLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCksIG51bGwpO1xuICAgIH1cbn07XG5cbi8vIEZJWE1FKHdhYmFpbik6IFJlbW92ZSB0aGUgZGlyZWN0aW9uIGFyZ3VtZW50IGlmIGl0IGRvZXNuJ3QgZW5kIHVwIGJlaW5nIG5lZWRlZC5cblJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGRpcmVjdGlvbikgLy8ganNoaW50IGlnbm9yZTpsaW5lXG57XG4gICAgdmFyIG5ld1JlbmRlcmVkUGFnZXMgPSBbXTtcbiAgICB0aGlzLmxheW91dC5wYWdlR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWV3cG9ydC5pbnRlcnNlY3RzUmVnaW9uKGdyb3VwLnJlZ2lvbikpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIHZpc2libGVQYWdlcyA9IGdyb3VwLnBhZ2VzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGFnZVZpc2libGUocGFnZS5pbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocGFnZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFnZS5pbmRleDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ld1JlbmRlcmVkUGFnZXMucHVzaC5hcHBseShuZXdSZW5kZXJlZFBhZ2VzLCB2aXNpYmxlUGFnZXMpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuX3BhaW50T3V0bGluZShuZXdSZW5kZXJlZFBhZ2VzKTtcblxuICAgIG5ld1JlbmRlcmVkUGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb3NpdGVJbWFnZXNbcGFnZUluZGV4XSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLmxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHpvb21MZXZlbHMgPSB0aGlzLl9zb3VyY2VSZXNvbHZlci5nZXRBbGxab29tTGV2ZWxzRm9yUGFnZShwYWdlKTtcbiAgICAgICAgICAgIHZhciBjb21wb3NpdGUgPSBuZXcgQ29tcG9zaXRlSW1hZ2Uoem9vbUxldmVscyk7XG4gICAgICAgICAgICBjb21wb3NpdGUudXBkYXRlRnJvbUNhY2hlKHRoaXMuX2NhY2hlKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdID0gY29tcG9zaXRlO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9pbml0aWF0ZVRpbGVSZXF1ZXN0cyhuZXdSZW5kZXJlZFBhZ2VzKTtcblxuICAgIHZhciBjaGFuZ2VzID0gZmluZENoYW5nZXModGhpcy5fcmVuZGVyZWRQYWdlcyB8fCBbXSwgbmV3UmVuZGVyZWRQYWdlcyk7XG5cbiAgICBjaGFuZ2VzLnJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlcyA9IG5ld1JlbmRlcmVkUGFnZXM7XG4gICAgdGhpcy5fcGFpbnQoKTtcblxuICAgIGlmICh0aGlzLl9ob29rcy5vblBhZ2VXaWxsTG9hZClcbiAgICB7XG4gICAgICAgIGNoYW5nZXMuYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9ob29rcy5vblBhZ2VXaWxsTG9hZChwYWdlSW5kZXgpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX3BhaW50ID0gZnVuY3Rpb24gKClcbntcbiAgICBkZWJ1ZygnUmVwYWludGluZycpO1xuXG4gICAgdmFyIHJlbmRlcmVkVGlsZXMgPSBbXTtcblxuICAgIHRoaXMuX3JlbmRlcmVkUGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzW3BhZ2VJbmRleF0uZ2V0VGlsZXModGhpcy5fem9vbUxldmVsKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzY2FsZWQgPSBnZXRTY2FsZWRUaWxlUmVjb3JkKHNvdXJjZSwgdGhpcy5fem9vbUxldmVsKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVZpc2libGUocGFnZUluZGV4LCBzY2FsZWQpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVGlsZXMucHVzaChzb3VyY2UudXJsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3VGlsZShwYWdlSW5kZXgsIHNjYWxlZCwgdGhpcy5fY2FjaGUuZ2V0KHNvdXJjZS51cmwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcblxuICAgIHZhciBjaGFuZ2VzID0gZmluZENoYW5nZXModGhpcy5fcmVuZGVyZWRUaWxlcyB8fCBbXSwgcmVuZGVyZWRUaWxlcyk7XG5cbiAgICBjaGFuZ2VzLmFkZGVkLmZvckVhY2goZnVuY3Rpb24gKHVybClcbiAgICB7XG4gICAgICAgIGNhY2hlLmFjcXVpcmUodXJsKTtcbiAgICB9KTtcblxuICAgIGNoYW5nZXMucmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpXG4gICAge1xuICAgICAgICBjYWNoZS5yZWxlYXNlKHVybCk7XG4gICAgfSk7XG5cbiAgICBpZiAoY2hhbmdlcy5yZW1vdmVkKVxuICAgIHtcbiAgICAgICAgLy8gRklYTUU6IFNob3VsZCBvbmx5IG5lZWQgdG8gdXBkYXRlIHRoZSBjb21wb3NpdGUgaW1hZ2VzXG4gICAgICAgIC8vIGZvciB3aGljaCB0aWxlcyB3ZXJlIHJlbW92ZWRcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRQYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdLnVwZGF0ZUZyb21DYWNoZSh0aGlzLl9jYWNoZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcmVkVGlsZXMgPSByZW5kZXJlZFRpbGVzO1xufTtcblxuLy8gUGFpbnQgYSBwYWdlIG91dGxpbmUgd2hpbGUgdGhlIHRpbGVzIGFyZSBsb2FkaW5nLlxuUmVuZGVyZXIucHJvdG90eXBlLl9wYWludE91dGxpbmUgPSBmdW5jdGlvbiAocGFnZXMpXG57XG4gICAgcGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5sYXlvdXQuZ2V0UGFnZUluZm8ocGFnZUluZGV4KTtcbiAgICAgICAgdmFyIHBhZ2VPZmZzZXQgPSB0aGlzLl9nZXRJbWFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZG9jdW1lbnQgaXMgZHJhd24gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgdmFyIHZpZXdwb3J0UGFkZGluZ1ggPSBNYXRoLm1heCgwLCAodGhpcy5fdmlld3BvcnQud2lkdGggLSB0aGlzLmxheW91dC5kaW1lbnNpb25zLndpZHRoKSAvIDIpO1xuICAgICAgICB2YXIgdmlld3BvcnRQYWRkaW5nWSA9IE1hdGgubWF4KDAsICh0aGlzLl92aWV3cG9ydC5oZWlnaHQgLSB0aGlzLmxheW91dC5kaW1lbnNpb25zLmhlaWdodCkgLyAyKTtcblxuICAgICAgICB2YXIgdmlld3BvcnRPZmZzZXRYID0gcGFnZU9mZnNldC5sZWZ0IC0gdGhpcy5fdmlld3BvcnQubGVmdCArIHZpZXdwb3J0UGFkZGluZ1g7XG4gICAgICAgIHZhciB2aWV3cG9ydE9mZnNldFkgPSBwYWdlT2Zmc2V0LnRvcCAtIHRoaXMuX3ZpZXdwb3J0LnRvcCArIHZpZXdwb3J0UGFkZGluZ1k7XG5cbiAgICAgICAgdmFyIGRlc3RYT2Zmc2V0ID0gdmlld3BvcnRPZmZzZXRYIDwgMCA/IC12aWV3cG9ydE9mZnNldFggOiAwO1xuICAgICAgICB2YXIgZGVzdFlPZmZzZXQgPSB2aWV3cG9ydE9mZnNldFkgPCAwID8gLXZpZXdwb3J0T2Zmc2V0WSA6IDA7XG5cbiAgICAgICAgdmFyIGNhbnZhc1ggPSBNYXRoLm1heCgwLCB2aWV3cG9ydE9mZnNldFgpO1xuICAgICAgICB2YXIgY2FudmFzWSA9IE1hdGgubWF4KDAsIHZpZXdwb3J0T2Zmc2V0WSk7XG5cbiAgICAgICAgdmFyIGRlc3RXaWR0aCA9IHBhZ2VJbmZvLmRpbWVuc2lvbnMud2lkdGggLSBkZXN0WE9mZnNldDtcbiAgICAgICAgdmFyIGRlc3RIZWlnaHQgPSBwYWdlSW5mby5kaW1lbnNpb25zLmhlaWdodCAtIGRlc3RZT2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICcjQUFBJztcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gZ2V0IGEgMXB4IHdpZGUgbGluZSB1c2luZyBzdHJva2VzLCB3ZSBuZWVkIHRvIHN0YXJ0IGF0IGEgJ2hhbGYgcGl4ZWwnXG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VSZWN0KGNhbnZhc1ggKyAwLjUsIGNhbnZhc1kgKyAwLjUsIGRlc3RXaWR0aCwgZGVzdEhlaWdodCk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vLyBUaGlzIG1ldGhvZCBzaG91bGQgYmUgc2VudCBhbGwgdmlzaWJsZSBwYWdlcyBhdCBvbmNlIGJlY2F1c2UgaXQgd2lsbCBpbml0aWF0ZVxuLy8gYWxsIGltYWdlIHJlcXVlc3RzIGFuZCBjYW5jZWwgYW55IHJlbWFpbmluZyBpbWFnZSByZXF1ZXN0cy4gSW4gdGhlIGNhc2UgdGhhdFxuLy8gYSByZXF1ZXN0IGlzIG9uZ29pbmcgYW5kIHRoZSB0aWxlIGlzIHN0aWxsIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LCB0aGUgb2xkIHJlcXVlc3Rcbi8vIGlzIGtlcHQgYWN0aXZlIGluc3RlYWQgb2YgcmVzdGFydGluZyBpdC4gVGhlIGltYWdlIHJlcXVlc3RzIGFyZSBnaXZlbiBhIHRpbWVvdXRcbi8vIGJlZm9yZSBsb2FkaW5nIGluIG9yZGVyIHRvIGRlYm91bmNlIHRoZW0gYW5kIGhhdmUgYSBzbWFsbCByZWFjdGlvbiB0aW1lXG4vLyB0byBjYW5jZWwgdGhlbSBhbmQgYXZvaWQgdXNlbGVzcyByZXF1ZXN0cy5cblJlbmRlcmVyLnByb3RvdHlwZS5faW5pdGlhdGVUaWxlUmVxdWVzdHMgPSBmdW5jdGlvbihwYWdlcylcbntcbiAgICAvLyBPbmx5IHJlcXVlc3RzIGluIHRoaXMgb2JqZWN0IGFyZSBrZXB0IGFsaXZlLCBzaW5jZSBhbGwgb3RoZXJzIGFyZSBub3QgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgbmV3UGVuZGluZ1JlcXVlc3RzID0ge307XG5cbiAgICAvLyBVc2VkIGxhdGVyIGFzIGEgY2xvc3VyZSB0byBpbml0aWF0ZSB0aGUgaW1hZ2UgcmVxdWVzdHMgd2l0aCB0aGUgcmlnaHQgc291cmNlIGFuZCBwYWdlSW5kZXhcbiAgICB2YXIgaW5pdGlhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHNvdXJjZSwgcGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGNvbXBvc2l0ZSA9IHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdO1xuXG4gICAgICAgIG5ld1BlbmRpbmdSZXF1ZXN0c1tzb3VyY2UudXJsXSA9IG5ldyBJbWFnZVJlcXVlc3RIYW5kbGVyKHtcbiAgICAgICAgICAgIHVybDogc291cmNlLnVybCxcbiAgICAgICAgICAgIHRpbWVvdXRUaW1lOiBSRVFVRVNUX0RFQk9VTkNFX0lOVEVSVkFMLFxuICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24gKGltZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLnB1dChzb3VyY2UudXJsLCBpbWcpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXdrd2FyZCB3YXkgdG8gY2hlY2sgZm9yIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRlID09PSB0aGlzLl9jb21wb3NpdGVJbWFnZXNbcGFnZUluZGV4XSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZS51cGRhdGVXaXRoTG9hZGVkVXJscyhbc291cmNlLnVybF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1RpbGVGb3JTb3VyY2VWaXNpYmxlKHBhZ2VJbmRleCwgc291cmNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnUGFpbnRzKCdQYWdlICVzLCB0aWxlICVzIG5vIGxvbmdlciB2aXNpYmxlIG9uIGltYWdlIGxvYWQnLCBwYWdlSW5kZXgsIHNvdXJjZS51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IENvdWxkIG1ha2UgYSBsaW1pdGVkIG51bWJlciBvZiByZXRyaWVzLCBldGMuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1tzb3VyY2UudXJsXTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHBhZ2VJbmRleCA9IHBhZ2VzW2ldO1xuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLl9zb3VyY2VSZXNvbHZlci5nZXRCZXN0Wm9vbUxldmVsRm9yUGFnZSh0aGlzLmxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpKS50aWxlcztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpbGVzLmxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gdGlsZXNbal07XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKHNvdXJjZS51cmwpIHx8ICF0aGlzLl9pc1RpbGVGb3JTb3VyY2VWaXNpYmxlKHBhZ2VJbmRleCwgc291cmNlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgY3JlYXRlIGEgbmV3IHJlcXVlc3QgaWYgdGhlIHRpbGUgaXMgYWxyZWFkeSBiZWluZyBsb2FkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVxdWVzdHNbc291cmNlLnVybF0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3UGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdID0gdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbc291cmNlLnVybF07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIGNsb3N1cmUgc2luY2UgdGhlIGxvYWQgYW5kIGVycm9yIG1ldGhvZHMgYXJlIGdvaW5nIHRvIGJlIGNhbGxlZCBsYXRlciBhbmRcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8ga2VlcCB0aGUgcmlnaHQgcmVmZXJlbmNlIHRvIHRoZSBzb3VyY2UgYW5kIHRoZSBwYWdlIGluZGV4XG4gICAgICAgICAgICBpbml0aWF0ZVJlcXVlc3Qoc291cmNlLCBwYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgdXJsIGluIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cylcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3VybF0uYWJvcnQoKTtcbiAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMgPSBuZXdQZW5kaW5nUmVxdWVzdHM7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2RyYXdUaWxlID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgc2NhbGVkVGlsZSwgaW1nKVxue1xuICAgIHZhciB0aWxlT2Zmc2V0ID0gdGhpcy5fZ2V0VGlsZVRvRG9jdW1lbnRPZmZzZXQocGFnZUluZGV4LCBzY2FsZWRUaWxlKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgZG9jdW1lbnQgaXMgZHJhd24gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nWCA9IE1hdGgubWF4KDAsICh0aGlzLl92aWV3cG9ydC53aWR0aCAtIHRoaXMubGF5b3V0LmRpbWVuc2lvbnMud2lkdGgpIC8gMik7XG4gICAgdmFyIHZpZXdwb3J0UGFkZGluZ1kgPSBNYXRoLm1heCgwLCAodGhpcy5fdmlld3BvcnQuaGVpZ2h0IC0gdGhpcy5sYXlvdXQuZGltZW5zaW9ucy5oZWlnaHQpIC8gMik7XG5cbiAgICB2YXIgdmlld3BvcnRPZmZzZXRYID0gdGlsZU9mZnNldC5sZWZ0IC0gdGhpcy5fdmlld3BvcnQubGVmdCArIHZpZXdwb3J0UGFkZGluZ1g7XG4gICAgdmFyIHZpZXdwb3J0T2Zmc2V0WSA9IHRpbGVPZmZzZXQudG9wIC0gdGhpcy5fdmlld3BvcnQudG9wICsgdmlld3BvcnRQYWRkaW5nWTtcblxuICAgIHZhciBkZXN0WE9mZnNldCA9IHZpZXdwb3J0T2Zmc2V0WCA8IDAgPyAtdmlld3BvcnRPZmZzZXRYIDogMDtcbiAgICB2YXIgZGVzdFlPZmZzZXQgPSB2aWV3cG9ydE9mZnNldFkgPCAwID8gLXZpZXdwb3J0T2Zmc2V0WSA6IDA7XG5cbiAgICB2YXIgc291cmNlWE9mZnNldCA9IGRlc3RYT2Zmc2V0IC8gc2NhbGVkVGlsZS5zY2FsZVJhdGlvO1xuICAgIHZhciBzb3VyY2VZT2Zmc2V0ID0gZGVzdFlPZmZzZXQgLyBzY2FsZWRUaWxlLnNjYWxlUmF0aW87XG5cbiAgICB2YXIgY2FudmFzWCA9IE1hdGgubWF4KDAsIHZpZXdwb3J0T2Zmc2V0WCk7XG4gICAgdmFyIGNhbnZhc1kgPSBNYXRoLm1heCgwLCB2aWV3cG9ydE9mZnNldFkpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNwZWNpZmllZCBkaW1lbnNpb25zIGFyZSBubyBncmVhdGVyIHRoYW4gdGhlIGFjdHVhbFxuICAgIC8vIHNpemUgb2YgdGhlIGltYWdlLiBTYWZhcmkgd29uJ3QgZGlzcGxheSB0aGUgdGlsZSBpZiB0aGV5IGFyZS5cbiAgICB2YXIgZGVzdFdpZHRoID0gTWF0aC5taW4oc2NhbGVkVGlsZS5kaW1lbnNpb25zLndpZHRoLCBpbWcud2lkdGggKiBzY2FsZWRUaWxlLnNjYWxlUmF0aW8pIC0gZGVzdFhPZmZzZXQ7XG4gICAgdmFyIGRlc3RIZWlnaHQgPSBNYXRoLm1pbihzY2FsZWRUaWxlLmRpbWVuc2lvbnMuaGVpZ2h0LCBpbWcuaGVpZ2h0ICogc2NhbGVkVGlsZS5zY2FsZVJhdGlvKSAtIGRlc3RZT2Zmc2V0O1xuXG4gICAgdmFyIHNvdXJjZVdpZHRoID0gZGVzdFdpZHRoIC8gc2NhbGVkVGlsZS5zY2FsZVJhdGlvO1xuICAgIHZhciBzb3VyY2VIZWlnaHQgPSBkZXN0SGVpZ2h0IC8gc2NhbGVkVGlsZS5zY2FsZVJhdGlvO1xuXG4gICAgaWYgKGRlYnVnUGFpbnRzLmVuYWJsZWQpIHtcbiAgICAgICAgZGVidWdQYWludHMoJ0RyYXdpbmcgcGFnZSAlcywgdGlsZSAlc3ggKCVzLCAlcykgZnJvbSAlcywgJXMgdG8gdmlld3BvcnQgYXQgJXMsICVzLCBzY2FsZSAlcyUlJyxcbiAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgIHNjYWxlZFRpbGUuc291cmNlWm9vbUxldmVsLCBzY2FsZWRUaWxlLnJvdywgc2NhbGVkVGlsZS5jb2wsXG4gICAgICAgICAgICBzb3VyY2VYT2Zmc2V0LCBzb3VyY2VZT2Zmc2V0LFxuICAgICAgICAgICAgY2FudmFzWCwgY2FudmFzWSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoc2NhbGVkVGlsZS5zY2FsZVJhdGlvICogMTAwKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3R4LmRyYXdJbWFnZShcbiAgICAgICAgaW1nLFxuICAgICAgICBzb3VyY2VYT2Zmc2V0LCBzb3VyY2VZT2Zmc2V0LFxuICAgICAgICBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LFxuICAgICAgICBjYW52YXNYLCBjYW52YXNZLFxuICAgICAgICBkZXN0V2lkdGgsIGRlc3RIZWlnaHQpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9pc1RpbGVGb3JTb3VyY2VWaXNpYmxlID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgdGlsZVNvdXJjZSlcbntcbiAgICByZXR1cm4gdGhpcy5faXNUaWxlVmlzaWJsZShwYWdlSW5kZXgsIGdldFNjYWxlZFRpbGVSZWNvcmQodGlsZVNvdXJjZSwgdGhpcy5fem9vbUxldmVsKSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2lzVGlsZVZpc2libGUgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBzY2FsZWRUaWxlKVxue1xuICAgIHZhciB0aWxlT2Zmc2V0ID0gdGhpcy5fZ2V0VGlsZVRvRG9jdW1lbnRPZmZzZXQocGFnZUluZGV4LCBzY2FsZWRUaWxlKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IFRoaXMgY2hlY2sgaXMgaW5zdWZmaWNpZW50IGR1cmluZyBhIHpvb20gdHJhbnNpdGlvblxuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydC5pbnRlcnNlY3RzUmVnaW9uKHtcbiAgICAgICAgdG9wOiB0aWxlT2Zmc2V0LnRvcCxcbiAgICAgICAgYm90dG9tOiB0aWxlT2Zmc2V0LnRvcCArIHNjYWxlZFRpbGUuZGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IHRpbGVPZmZzZXQubGVmdCxcbiAgICAgICAgcmlnaHQ6IHRpbGVPZmZzZXQubGVmdCArIHNjYWxlZFRpbGUuZGltZW5zaW9ucy53aWR0aFxuICAgIH0pO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9nZXRUaWxlVG9Eb2N1bWVudE9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHNjYWxlZFRpbGUpXG57XG4gICAgdmFyIGltYWdlT2Zmc2V0ID0gdGhpcy5fZ2V0SW1hZ2VPZmZzZXQocGFnZUluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogaW1hZ2VPZmZzZXQudG9wICsgc2NhbGVkVGlsZS5vZmZzZXQudG9wLFxuICAgICAgICBsZWZ0OiBpbWFnZU9mZnNldC5sZWZ0ICsgc2NhbGVkVGlsZS5vZmZzZXQubGVmdFxuICAgIH07XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2dldEltYWdlT2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbntcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgsIHtleGNsdWRlUGFkZGluZzogdHJ1ZX0pO1xufTtcblxuLy8gVE9ETzogVXBkYXRlIHNpZ25hdHVyZVxuUmVuZGVyZXIucHJvdG90eXBlLmdvdG8gPSBmdW5jdGlvbiAocGFnZUluZGV4LCB2ZXJ0aWNhbE9mZnNldCwgaG9yaXpvbnRhbE9mZnNldClcbntcbiAgICB0aGlzLl9jbGVhckFuaW1hdGlvbigpO1xuICAgIHRoaXMuX2dvdG8ocGFnZUluZGV4LCB2ZXJ0aWNhbE9mZnNldCwgaG9yaXpvbnRhbE9mZnNldCk7XG4gICAgaWYgKHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSh0aGlzLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCksIHBhZ2VJbmRleCk7XG4gICAgfVxufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9nb3RvID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgdmVydGljYWxPZmZzZXQsIGhvcml6b250YWxPZmZzZXQpXG57XG4gICAgLy8gRklYTUUod2FiYWluKTogTW92ZSB0aGlzIGxvZ2ljIHRvIHRoZSB2aWV3ZXJcbiAgICB2YXIgcGFnZU9mZnNldCA9IHRoaXMubGF5b3V0LmdldFBhZ2VPZmZzZXQocGFnZUluZGV4KTtcblxuICAgIHZhciBkZXNpcmVkVmVydGljYWxDZW50ZXIgPSBwYWdlT2Zmc2V0LnRvcCArIHZlcnRpY2FsT2Zmc2V0O1xuICAgIHZhciB0b3AgPSBkZXNpcmVkVmVydGljYWxDZW50ZXIgLSBwYXJzZUludCh0aGlzLl92aWV3cG9ydC5oZWlnaHQgLyAyLCAxMCk7XG5cbiAgICB2YXIgZGVzaXJlZEhvcml6b250YWxDZW50ZXIgPSBwYWdlT2Zmc2V0LmxlZnQgKyBob3Jpem9udGFsT2Zmc2V0O1xuICAgIHZhciBsZWZ0ID0gZGVzaXJlZEhvcml6b250YWxDZW50ZXIgLSBwYXJzZUludCh0aGlzLl92aWV3cG9ydC53aWR0aCAvIDIsIDEwKTtcblxuICAgIHRoaXMuX3ZpZXdwb3J0LnRvcCA9IHRvcDtcbiAgICB0aGlzLl92aWV3cG9ydC5sZWZ0ID0gbGVmdDtcblxuICAgIHRoaXMuX3JlbmRlcigwKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50cmFuc2l0aW9uVmlld3BvcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKVxue1xuICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uKCk7XG5cbiAgICB2YXIgZ2V0UG9zaXRpb24gPSBvcHRpb25zLmdldFBvc2l0aW9uO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblZpZXdEaWRUcmFuc2l0aW9uID0gdGhpcy5faG9va3Mub25WaWV3RGlkVHJhbnNpdGlvbjtcblxuICAgIHRoaXMuX2FuaW1hdGlvbiA9IEludGVycG9sYXRlQW5pbWF0aW9uLmFuaW1hdGUoe1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgcGFyYW1ldGVyczogb3B0aW9ucy5wYXJhbWV0ZXJzLFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlcylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETzogRG8gaW1hZ2UgcHJlbG9hZGluZywgd29yayB3aXRoIHRoYXRcbiAgICAgICAgICAgIHNlbGYuX3NldFZpZXdwb3J0UG9zaXRpb24oZ2V0UG9zaXRpb24odmFsdWVzKSk7XG5cbiAgICAgICAgICAgIGlmIChvblZpZXdEaWRUcmFuc2l0aW9uKVxuICAgICAgICAgICAgICAgIG9uVmlld0RpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbmQ6IGZ1bmN0aW9uIChpbmZvKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkVuZClcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uRW5kKGluZm8pO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5faG9va3Mub25WaWV3RGlkVXBkYXRlICYmICFpbmZvLmludGVycnVwdGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGYuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZShzZWxmLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2NsZWFyQW5pbWF0aW9uID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fYW5pbWF0aW9uKVxuICAgIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuICAgIH1cbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBUT0RPXG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaXNQYWdlVmlzaWJsZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG57XG4gICAgaWYgKCF0aGlzLmxheW91dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHBhZ2UgPSB0aGlzLmxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpO1xuXG4gICAgaWYgKCFwYWdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQuaW50ZXJzZWN0c1JlZ2lvbih0aGlzLmxheW91dC5nZXRQYWdlUmVnaW9uKHBhZ2VJbmRleCkpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmdldFJlbmRlcmVkUGFnZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb24oKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IEkgZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgZG8gdGhpc1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cykuZm9yRWFjaChmdW5jdGlvbiAocmVxKVxuICAgIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbcmVxXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1tyZXFdO1xuXG4gICAgICAgIGhhbmRsZXIuYWJvcnQoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcyk7XG59O1xuXG5mdW5jdGlvbiBnZXRTY2FsZWRUaWxlUmVjb3JkKHNvdXJjZSwgc2NhbGVGYWN0b3IpXG57XG4gICAgdmFyIHNjYWxlUmF0aW87XG5cbiAgICBpZiAoc2NhbGVGYWN0b3IgPT09IG51bGwpXG4gICAgICAgIHNjYWxlUmF0aW8gPSAxO1xuICAgIGVsc2VcbiAgICAgICAgc2NhbGVSYXRpbyA9IE1hdGgucG93KDIsIHNjYWxlRmFjdG9yIC0gc291cmNlLnpvb21MZXZlbCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2Vab29tTGV2ZWw6IHNvdXJjZS56b29tTGV2ZWwsXG4gICAgICAgIHNjYWxlUmF0aW86IHNjYWxlUmF0aW8sXG4gICAgICAgIHJvdzogc291cmNlLnJvdyxcbiAgICAgICAgY29sOiBzb3VyY2UuY29sLFxuICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICB3aWR0aDogc291cmNlLmRpbWVuc2lvbnMud2lkdGggKiBzY2FsZVJhdGlvLFxuICAgICAgICAgICAgaGVpZ2h0OiBzb3VyY2UuZGltZW5zaW9ucy5oZWlnaHQgKiBzY2FsZVJhdGlvXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgbGVmdDogc291cmNlLm9mZnNldC5sZWZ0ICogc2NhbGVSYXRpbyxcbiAgICAgICAgICAgIHRvcDogc291cmNlLm9mZnNldC50b3AgKiBzY2FsZVJhdGlvXG4gICAgICAgIH0sXG4gICAgICAgIHVybDogc291cmNlLnVybFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGFuZ2VzKG9sZEFycmF5LCBuZXdBcnJheSlcbntcbiAgICBpZiAob2xkQXJyYXkgPT09IG5ld0FycmF5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZGVkOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlbW92ZWQgPSBvbGRBcnJheS5maWx0ZXIoZnVuY3Rpb24gKG9sZEVudHJ5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ld0FycmF5LmluZGV4T2Yob2xkRW50cnkpID09PSAtMTtcbiAgICB9KTtcblxuICAgIHZhciBhZGRlZCA9IG5ld0FycmF5LmZpbHRlcihmdW5jdGlvbiAobmV3RW50cnkpXG4gICAge1xuICAgICAgICByZXR1cm4gb2xkQXJyYXkuaW5kZXhPZihuZXdFbnRyeSkgPT09IC0xO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICByZW1vdmVkOiByZW1vdmVkXG4gICAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvcmVuZGVyZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZGVidWcvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2RlYnVnL2RlYnVnLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21zL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRlSW1hZ2U7XG5cbi8qKlxuICogQGNsYXNzIENvbXBvc2l0ZUltYWdlXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFV0aWxpdHkgY2xhc3MgdG8gY29tcG9zaXRlIHRpbGVzIGludG8gYSBjb21wbGV0ZSBpbWFnZVxuICogYW5kIHRyYWNrIHRoZSByZW5kZXJlZCBzdGF0ZSBvZiBhbiBpbWFnZSBhcyBuZXcgdGlsZXNcbiAqIGxvYWQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gbGV2ZWxzIHtBcnJheS48QXJyYXkuPFRpbGU+Pn1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb21wb3NpdGVJbWFnZShsZXZlbHMpXG57XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzOyAgLy8gQXNzdW1lIGxldmVscyBzb3J0ZWQgaGlnaC1yZXMgZmlyc3RcbiAgICB2YXIgdXJsc1RvVGlsZXMgPSB0aGlzLl91cmxzVG9UaWxlcyA9IHt9O1xuXG4gICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKVxuICAgIHtcbiAgICAgICAgbGV2ZWwudGlsZXMuZm9yRWFjaChmdW5jdGlvbiAodGlsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsc1RvVGlsZXNbdGlsZS51cmxdID0ge1xuICAgICAgICAgICAgICAgIHpvb21MZXZlbDogbGV2ZWwuem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIHJvdzogdGlsZS5yb3csXG4gICAgICAgICAgICAgICAgY29sOiB0aWxlLmNvbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbkNvbXBvc2l0ZUltYWdlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGxvYWRlZEJ5TGV2ZWwgPSB0aGlzLl9sb2FkZWRCeUxldmVsID0ge307XG5cbiAgICB0aGlzLl9sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpXG4gICAge1xuICAgICAgICBsb2FkZWRCeUxldmVsW2xldmVsLnpvb21MZXZlbF0gPSBuZXcgVGlsZUNvdmVyYWdlTWFwKGxldmVsLnJvd3MsIGxldmVsLmNvbHMpO1xuICAgIH0pO1xufTtcblxuQ29tcG9zaXRlSW1hZ2UucHJvdG90eXBlLmdldFRpbGVzID0gZnVuY3Rpb24gKGJhc2Vab29tTGV2ZWwpXG57XG4gICAgdmFyIHRvUmVuZGVyQnlMZXZlbCA9IFtdO1xuICAgIHZhciBoaWdoZXN0Wm9vbUxldmVsID0gdGhpcy5fbGV2ZWxzWzBdLnpvb21MZXZlbDtcbiAgICB2YXIgY292ZXJlZCA9IG5ldyBUaWxlQ292ZXJhZ2VNYXAodGhpcy5fbGV2ZWxzWzBdLnJvd3MsIHRoaXMuX2xldmVsc1swXS5jb2xzKTtcblxuICAgIHZhciBiZXN0TGV2ZWxJbmRleDtcblxuICAgIC8vIERlZmF1bHQgdG8gdGhlIGxvd2VzdCB6b29tIGxldmVsXG4gICAgaWYgKGJhc2Vab29tTGV2ZWwgPT09IG51bGwpXG4gICAge1xuICAgICAgICBiZXN0TGV2ZWxJbmRleCA9IDA7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBjZWlsTGV2ZWwgPSBNYXRoLmNlaWwoYmFzZVpvb21MZXZlbCk7XG4gICAgICAgIGJlc3RMZXZlbEluZGV4ID0gZmluZEluZGV4KHRoaXMuX2xldmVscywgZnVuY3Rpb24gKGxldmVsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWwuem9vbUxldmVsIDw9IGNlaWxMZXZlbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvLyBUaGUgYmVzdCBsZXZlbCwgZm9sbG93ZWQgYnkgaGlnaGVyLXJlcyBsZXZlbHMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHJlc29sdXRpb24sXG4gICAgLy8gZm9sbG93ZWQgYnkgbG93ZXItcmVzIGxldmVscyBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHJlc29sdXRpb25cbiAgICB2YXIgbGV2ZWxzQnlQcmVmZXJlbmNlID0gdGhpcy5fbGV2ZWxzLnNsaWNlKDAsIGJlc3RMZXZlbEluZGV4ICsgMSkucmV2ZXJzZSgpXG4gICAgICAgIC5jb25jYXQodGhpcy5fbGV2ZWxzLnNsaWNlKGJlc3RMZXZlbEluZGV4ICsgMSkpO1xuXG4gICAgbGV2ZWxzQnlQcmVmZXJlbmNlLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKVxuICAgIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMuX2xvYWRlZEJ5TGV2ZWxbbGV2ZWwuem9vbUxldmVsXTtcblxuICAgICAgICB2YXIgYWRkaXRpb25hbFRpbGVzID0gbGV2ZWwudGlsZXMuZmlsdGVyKGZ1bmN0aW9uICh0aWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkLmlzTG9hZGVkKHRpbGUucm93LCB0aWxlLmNvbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgZW50aXJlbHkgY292ZXJlZCB0aWxlc1xuXG4gICAgICAgIC8vIEZJWE1FOiBJcyBpdCBiZXR0ZXIgdG8gZHJhdyBhbGwgb2YgYSBwYXJ0aWFsbHkgY292ZXJlZCB0aWxlLFxuICAgICAgICAvLyB3aXRoIHNvbWUgb2YgaXQgdWx0aW1hdGVseSBjb3ZlcmVkLCBvciB0byBwaWNrIG91dCB0aGUgcmVnaW9uXG4gICAgICAgIC8vIHdoaWNoIG5lZWRzIHRvIGJlIGRyYXduP1xuXG4gICAgICAgIHZhciBzY2FsZVJhdGlvID0gTWF0aC5wb3coMiwgaGlnaGVzdFpvb21MZXZlbCAtIGxldmVsLnpvb21MZXZlbCk7XG5cbiAgICAgICAgYWRkaXRpb25hbFRpbGVzID0gYWRkaXRpb25hbFRpbGVzLmZpbHRlcihmdW5jdGlvbiAodGlsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlzTmVlZGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBoaWdoUmVzUm93ID0gdGlsZS5yb3cgKiBzY2FsZVJhdGlvO1xuICAgICAgICAgICAgdmFyIGhpZ2hSZXNDb2wgPSB0aWxlLmNvbCAqIHNjYWxlUmF0aW87XG5cbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHNjYWxlUmF0aW87IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGogPCBzY2FsZVJhdGlvOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvdmVyZWQuaXNMb2FkZWQoaGlnaFJlc1JvdyArIGksIGhpZ2hSZXNDb2wgKyBqKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5zZXQoaGlnaFJlc1JvdyArIGksIGhpZ2hSZXNDb2wgKyBqLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzTmVlZGVkO1xuICAgICAgICB9KTtcblxuICAgICAgICB0b1JlbmRlckJ5TGV2ZWwucHVzaChhZGRpdGlvbmFsVGlsZXMpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gTGVzcy1wcmVmZXJyZWQgdGlsZXMgc2hvdWxkIGNvbWUgZmlyc3RcbiAgICB0b1JlbmRlckJ5TGV2ZWwucmV2ZXJzZSgpO1xuXG4gICAgdmFyIHRpbGVzID0gW107XG5cbiAgICB0b1JlbmRlckJ5TGV2ZWwuZm9yRWFjaChmdW5jdGlvbiAoYnlMZXZlbClcbiAgICB7XG4gICAgICAgIHRpbGVzLnB1c2guYXBwbHkodGlsZXMsIGJ5TGV2ZWwpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRpbGVzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbXBvc2l0ZSBpbWFnZSB0byB0YWtlIGludG8gYWNjb3VudCBhbGwgdGhlIFVSTHNcbiAqIGxvYWRlZCBpbiBhbiBpbWFnZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gY2FjaGUge0ltYWdlQ2FjaGV9XG4gKi9cbkNvbXBvc2l0ZUltYWdlLnByb3RvdHlwZS51cGRhdGVGcm9tQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpXG57XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgdGhpcy5fbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKVxuICAgIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMuX2xvYWRlZEJ5TGV2ZWxbbGV2ZWwuem9vbUxldmVsXTtcblxuICAgICAgICBsZXZlbC50aWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0aWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY2FjaGUuaGFzKHRpbGUudXJsKSlcbiAgICAgICAgICAgICAgICBsb2FkZWQuc2V0KHRpbGUucm93LCB0aWxlLmNvbCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xufTtcblxuQ29tcG9zaXRlSW1hZ2UucHJvdG90eXBlLnVwZGF0ZVdpdGhMb2FkZWRVcmxzID0gZnVuY3Rpb24gKHVybHMpXG57XG4gICAgdXJscy5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpXG4gICAge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl91cmxzVG9UaWxlc1t1cmxdO1xuICAgICAgICB0aGlzLl9sb2FkZWRCeUxldmVsW2VudHJ5Lnpvb21MZXZlbF0uc2V0KGVudHJ5LnJvdywgZW50cnkuY29sLCB0cnVlKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIFRpbGVDb3ZlcmFnZU1hcChyb3dzLCBjb2xzKVxue1xuICAgIHRoaXMuX3Jvd3MgPSByb3dzO1xuICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuXG4gICAgdGhpcy5fbWFwID0gZmlsbChyb3dzKS5tYXAoZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBmaWxsKGNvbHMsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuVGlsZUNvdmVyYWdlTWFwLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uIChyb3csIGNvbClcbntcbiAgICAvLyBSZXR1cm4gdHJ1ZSBmb3Igb3V0IG9mIGJvdW5kcyB0aWxlcyBiZWNhdXNlIHRoZXlcbiAgICAvLyBkb24ndCBuZWVkIHRvIGxvYWQuIChVbmZvcnR1bmF0ZWx5IHRoaXMgd2lsbCBhbHNvXG4gICAgLy8gbWFzayBsb2dpY2FsIGVycm9ycy4pXG4gICAgaWYgKHJvdyA+PSB0aGlzLl9yb3dzIHx8IGNvbCA+PSB0aGlzLl9jb2xzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLl9tYXBbcm93XVtjb2xdO1xufTtcblxuVGlsZUNvdmVyYWdlTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocm93LCBjb2wsIHZhbHVlKVxue1xuICAgIHRoaXMuX21hcFtyb3ddW2NvbF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGZpbGwoY291bnQsIHZhbHVlKVxue1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoY291bnQpO1xuXG4gICAgZm9yICh2YXIgaT0wOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgYXJyW2ldID0gdmFsdWU7XG5cbiAgICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSlcbntcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldLCBpKSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvY29tcG9zaXRlLWltYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRMYXlvdXQ7XG5cbi8qKlxuICogVHJhbnNsYXRlIHBhZ2UgbGF5b3V0cywgYXMgZ2VuZXJhdGVkIGJ5IHBhZ2UtbGF5b3V0cywgaW50byBhblxuICogb2JqZWN0IHdoaWNoIGNvbXB1dGVzIGxheW91dCBpbmZvcm1hdGlvbiBmb3IgdGhlIGRvY3VtZW50IGFzXG4gKiBhIHdob2xlLlxuICovXG5mdW5jdGlvbiBEb2N1bWVudExheW91dChjb25maWcsIHpvb21MZXZlbClcbntcbiAgICB2YXIgY29tcHV0ZWRMYXlvdXQgPSBnZXRDb21wdXRlZExheW91dChjb25maWcsIHpvb21MZXZlbCk7XG5cbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBjb21wdXRlZExheW91dC5kaW1lbnNpb25zO1xuICAgIHRoaXMucGFnZUdyb3VwcyA9IGNvbXB1dGVkTGF5b3V0LnBhZ2VHcm91cHM7XG4gICAgdGhpcy5fcGFnZUxvb2t1cCA9IGdldFBhZ2VMb29rdXAoY29tcHV0ZWRMYXlvdXQucGFnZUdyb3Vwcyk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFnZUluZm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleFxuICogQHByb3BlcnR5IHt7aW5kZXgsIGRpbWVuc2lvbnMsIHBhZ2VzLCByZWdpb24sIHBhZGRpbmd9fSBncm91cFxuICogQHByb3BlcnR5IHt7aGVpZ2h0OiBudW1iZXIsIHdpZHRoOiBudW1iZXJ9fSBkaW1lbnNpb25zXG4gKiBAcHJvcGVydHkge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gZ3JvdXBPZmZzZXRcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSBwYWdlSW5kZXhcbiAqIEByZXR1cm5zIHtQYWdlSW5mb3xudWxsfVxuICovXG5Eb2N1bWVudExheW91dC5wcm90b3R5cGUuZ2V0UGFnZUluZm8gPSBmdW5jdGlvbiAocGFnZUluZGV4KVxue1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9va3VwW3BhZ2VJbmRleF0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIGEgcGFnZVxuICpcbiAqIEBwYXJhbSBwYWdlSW5kZXhcbiAqIEByZXR1cm5zIHt7aGVpZ2h0OiBudW1iZXIsIHdpZHRoOiBudW1iZXJ9fVxuICovXG5Eb2N1bWVudExheW91dC5wcm90b3R5cGUuZ2V0UGFnZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxue1xuICAgIGlmICghdGhpcy5fcGFnZUxvb2t1cCB8fCAhdGhpcy5fcGFnZUxvb2t1cFtwYWdlSW5kZXhdKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhciByZWdpb24gPSBnZXRQYWdlUmVnaW9uRnJvbVBhZ2VJbmZvKHRoaXMuX3BhZ2VMb29rdXBbcGFnZUluZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IHJlZ2lvbi5ib3R0b20gLSByZWdpb24udG9wLFxuICAgICAgICB3aWR0aDogcmVnaW9uLnJpZ2h0IC0gcmVnaW9uLmxlZnRcbiAgICB9O1xufTtcblxuLy8gVE9ETyh3YWJhaW4pOiBHZXQgcmlkIG9mIHRoaXM7IGl0J3MgYSBzdWJzZXQgb2YgdGhlIHBhZ2UgcmVnaW9uLCBzb1xuLy8gZ2l2ZSB0aGF0IGluc3RlYWRcbi8qKlxuICogR2V0IHRoZSB0b3AtbGVmdCBjb29yZGluYXRlcyBvZiBhIHBhZ2UsIGluY2x1ZGluZyoqKiBwYWRkaW5nXG4gKlxuICogQHBhcmFtIHBhZ2VJbmRleFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn0gfCBudWxsfVxuICovXG5Eb2N1bWVudExheW91dC5wcm90b3R5cGUuZ2V0UGFnZU9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIG9wdGlvbnMpXG57XG4gICAgdmFyIHJlZ2lvbiA9IHRoaXMuZ2V0UGFnZVJlZ2lvbihwYWdlSW5kZXgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFyZWdpb24pXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWdpb24udG9wLFxuICAgICAgICBsZWZ0OiByZWdpb24ubGVmdFxuICAgIH07XG59O1xuXG5Eb2N1bWVudExheW91dC5wcm90b3R5cGUuZ2V0UGFnZVJlZ2lvbiA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIG9wdGlvbnMpXG57XG4gICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5fcGFnZUxvb2t1cFtwYWdlSW5kZXhdO1xuXG4gICAgaWYgKCFwYWdlSW5mbylcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcmVnaW9uID0gZ2V0UGFnZVJlZ2lvbkZyb21QYWdlSW5mbyhwYWdlSW5mbyk7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmV4Y2x1ZGVQYWRkaW5nKVxuICAgIHtcbiAgICAgICAgLy8gRklYTUU/XG4gICAgICAgIHZhciBwYWRkaW5nID0gcGFnZUluZm8uZ3JvdXAucGFkZGluZztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiByZWdpb24udG9wICsgcGFkZGluZy50b3AsXG4gICAgICAgICAgICBsZWZ0OiByZWdpb24ubGVmdCArIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogcmVnaW9uLmJvdHRvbSxcbiAgICAgICAgICAgIHJpZ2h0OiByZWdpb24ucmlnaHRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaW9uO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcC1yaWdodCBvZiB0aGUgcGFnZSB0byB0aGUgY2VudGVyIG9mIHRoZVxuICogc3BlY2lmaWVkIHZpZXdwb3J0IHJlZ2lvblxuICpcbiAqIEBwYXJhbSBwYWdlSW5kZXhcbiAqIEBwYXJhbSB2aWV3cG9ydCB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX1cbiAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICovXG5Eb2N1bWVudExheW91dC5wcm90b3R5cGUuZ2V0UGFnZVRvVmlld3BvcnRDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiAocGFnZUluZGV4LCB2aWV3cG9ydClcbntcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IHZpZXdwb3J0LmxlZnQ7XG4gICAgdmFyIGVsZW1lbnRXaWR0aCA9IHZpZXdwb3J0LnJpZ2h0IC0gdmlld3BvcnQubGVmdDtcblxuICAgIHZhciBvZmZzZXQgPSB0aGlzLmdldFBhZ2VPZmZzZXQocGFnZUluZGV4KTtcblxuICAgIHZhciB4ID0gc2Nyb2xsTGVmdCAtIG9mZnNldC5sZWZ0ICsgcGFyc2VJbnQoZWxlbWVudFdpZHRoIC8gMiwgMTApO1xuXG4gICAgdmFyIHNjcm9sbFRvcCA9IHZpZXdwb3J0LnRvcDtcbiAgICB2YXIgZWxlbWVudEhlaWdodCA9IHZpZXdwb3J0LmJvdHRvbSAtIHZpZXdwb3J0LnRvcDtcblxuICAgIHZhciB5ID0gc2Nyb2xsVG9wIC0gb2Zmc2V0LnRvcCArIHBhcnNlSW50KGVsZW1lbnRIZWlnaHQgLyAyLCAxMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFBhZ2VSZWdpb25Gcm9tUGFnZUluZm8ocGFnZSlcbntcbiAgICB2YXIgdG9wICAgID0gcGFnZS5ncm91cE9mZnNldC50b3AgICsgcGFnZS5ncm91cC5yZWdpb24udG9wO1xuICAgIHZhciBib3R0b20gPSB0b3AgKyBwYWdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIHZhciBsZWZ0ICAgPSBwYWdlLmdyb3VwT2Zmc2V0LmxlZnQgKyBwYWdlLmdyb3VwLnJlZ2lvbi5sZWZ0O1xuICAgIHZhciByaWdodCAgPSBsZWZ0ICsgcGFnZS5kaW1lbnNpb25zLndpZHRoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHRcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYWdlTG9va3VwKHBhZ2VHcm91cHMpXG57XG4gICAgdmFyIHBhZ2VMb29rdXAgPSB7fTtcblxuICAgIHBhZ2VHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApXG4gICAge1xuICAgICAgICBncm91cC5wYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICB7XG4gICAgICAgICAgICBwYWdlTG9va3VwW3BhZ2UuaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYWdlLmluZGV4LFxuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBwYWdlLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHBhZ2UuZ3JvdXBPZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhZ2VMb29rdXA7XG59XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkTGF5b3V0KGNvbmZpZywgem9vbUxldmVsKVxue1xuICAgIHZhciBzY2FsZWRMYXlvdXRzID0gem9vbUxldmVsID09PSBudWxsID8gY29uZmlnLnBhZ2VMYXlvdXRzIDogZ2V0U2NhbGVkUGFnZUxheW91dHMoY29uZmlnLCB6b29tTGV2ZWwpO1xuXG4gICAgdmFyIGRvY3VtZW50U2Vjb25kYXJ5RXh0ZW50ID0gZ2V0RXh0ZW50QWxvbmdTZWNvbmRhcnlBeGlzKGNvbmZpZywgc2NhbGVkTGF5b3V0cyk7XG5cbiAgICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQgYWxvbmcgdGhlIHByaW1hcnkgYXhpc1xuICAgIHZhciBwcmltYXJ5RG9jUG9zaXRpb24gPSBjb25maWcudmVydGljYWxseU9yaWVudGVkID9cbiAgICAgICAgY29uZmlnLnBhZGRpbmcuZG9jdW1lbnQudG9wIDpcbiAgICAgICAgY29uZmlnLnBhZGRpbmcuZG9jdW1lbnQubGVmdDtcblxuICAgIHZhciBwYWdlR3JvdXBzID0gW107XG5cbiAgICAvLyBUT0RPOiBVc2UgYm90dG9tLCByaWdodCBhcyB3ZWxsXG4gICAgdmFyIHBhZ2VQYWRkaW5nID0ge1xuICAgICAgICB0b3A6IGNvbmZpZy5wYWRkaW5nLnBhZ2UudG9wLFxuICAgICAgICBsZWZ0OiBjb25maWcucGFkZGluZy5wYWdlLmxlZnRcbiAgICB9O1xuXG4gICAgc2NhbGVkTGF5b3V0cy5mb3JFYWNoKGZ1bmN0aW9uIChsYXlvdXQsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIHRvcCwgbGVmdDtcblxuICAgICAgICBpZiAoY29uZmlnLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdG9wID0gcHJpbWFyeURvY1Bvc2l0aW9uO1xuICAgICAgICAgICAgbGVmdCA9IChkb2N1bWVudFNlY29uZGFyeUV4dGVudCAtIGxheW91dC5kaW1lbnNpb25zLndpZHRoKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0b3AgPSAoZG9jdW1lbnRTZWNvbmRhcnlFeHRlbnQgLSBsYXlvdXQuZGltZW5zaW9ucy5oZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIGxlZnQgPSBwcmltYXJ5RG9jUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVnaW9uID0ge1xuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICBib3R0b206IHRvcCArIHBhZ2VQYWRkaW5nLnRvcCArIGxheW91dC5kaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogbGVmdCArIHBhZ2VQYWRkaW5nLmxlZnQgKyBsYXlvdXQuZGltZW5zaW9ucy53aWR0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHBhZ2VHcm91cHMucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiBsYXlvdXQuZGltZW5zaW9ucyxcbiAgICAgICAgICAgIHBhZ2VzOiBsYXlvdXQucGFnZXMsXG4gICAgICAgICAgICByZWdpb246IHJlZ2lvbixcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZ2VQYWRkaW5nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByaW1hcnlEb2NQb3NpdGlvbiA9IGNvbmZpZy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyByZWdpb24uYm90dG9tIDogcmVnaW9uLnJpZ2h0O1xuICAgIH0pO1xuXG4gICAgdmFyIGhlaWdodCwgd2lkdGg7XG5cbiAgICBpZiAoY29uZmlnLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICB7XG4gICAgICAgIGhlaWdodCA9IHByaW1hcnlEb2NQb3NpdGlvbiArIHBhZ2VQYWRkaW5nLnRvcDtcbiAgICAgICAgd2lkdGggPSBkb2N1bWVudFNlY29uZGFyeUV4dGVudDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaGVpZ2h0ID0gZG9jdW1lbnRTZWNvbmRhcnlFeHRlbnQ7XG4gICAgICAgIHdpZHRoID0gcHJpbWFyeURvY1Bvc2l0aW9uICsgcGFnZVBhZGRpbmcubGVmdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICB9LFxuICAgICAgICBwYWdlR3JvdXBzOiBwYWdlR3JvdXBzXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGVkUGFnZUxheW91dHMoY29uZmlnLCB6b29tTGV2ZWwpXG57XG4gICAgdmFyIHNjYWxlUmF0aW8gPSBNYXRoLnBvdygyLCB6b29tTGV2ZWwgLSBjb25maWcubWF4Wm9vbUxldmVsKTtcblxuICAgIHJldHVybiBjb25maWcucGFnZUxheW91dHMubWFwKGZ1bmN0aW9uIChncm91cClcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb25zOiBzY2FsZURpbWVuc2lvbnMoZ3JvdXAuZGltZW5zaW9ucywgc2NhbGVSYXRpbyksXG4gICAgICAgICAgICBwYWdlczogZ3JvdXAucGFnZXMubWFwKGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYWdlLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBncm91cE9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBNYXRoLmZsb29yKHBhZ2UuZ3JvdXBPZmZzZXQudG9wICogc2NhbGVSYXRpbyksXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLmZsb29yKHBhZ2UuZ3JvdXBPZmZzZXQubGVmdCAqIHNjYWxlUmF0aW8pXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHNjYWxlRGltZW5zaW9ucyhwYWdlLmRpbWVuc2lvbnMsIHNjYWxlUmF0aW8pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBzY2FsZVJhdGlvKVxue1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogTWF0aC5mbG9vcihkaW1lbnNpb25zLmhlaWdodCAqIHNjYWxlUmF0aW8pLFxuICAgICAgICB3aWR0aDogTWF0aC5mbG9vcihkaW1lbnNpb25zLndpZHRoICogc2NhbGVSYXRpbylcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFeHRlbnRBbG9uZ1NlY29uZGFyeUF4aXMoY29uZmlnLCBzY2FsZWRMYXlvdXRzKVxue1xuICAgIC8vIEdldCB0aGUgZXh0ZW50IG9mIHRoZSBkb2N1bWVudCBhbG9uZyB0aGUgc2Vjb25kYXJ5IGF4aXNcbiAgICB2YXIgc2Vjb25kYXJ5RGltLCBzZWNvbmRhcnlQYWRkaW5nO1xuICAgIHZhciBkb2NQYWRkaW5nID0gY29uZmlnLnBhZGRpbmcuZG9jdW1lbnQ7XG5cbiAgICBpZiAoY29uZmlnLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICB7XG4gICAgICAgIHNlY29uZGFyeURpbSA9ICd3aWR0aCc7XG4gICAgICAgIHNlY29uZGFyeVBhZGRpbmcgPSBkb2NQYWRkaW5nLmxlZnQgKyBkb2NQYWRkaW5nLnJpZ2h0O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBzZWNvbmRhcnlEaW0gPSAnaGVpZ2h0JztcbiAgICAgICAgc2Vjb25kYXJ5UGFkZGluZyA9IGRvY1BhZGRpbmcudG9wICsgZG9jUGFkZGluZy5ib3R0b207XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY29uZGFyeVBhZGRpbmcgKyBzY2FsZWRMYXlvdXRzLnJlZHVjZShmdW5jdGlvbiAobWF4RGltLCBsYXlvdXQpXG4gICAge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgobGF5b3V0LmRpbWVuc2lvbnNbc2Vjb25kYXJ5RGltXSwgbWF4RGltKTtcbiAgICB9LCAwKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvZG9jdW1lbnQtbGF5b3V0LmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpJbWFnZUNhY2hlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VDYWNoZTtcblxuLyogRklYTUUod2FiYWluKTogVGhlIGNhY2hpbmcgc3RyYXRlZ3kgaGVyZSBpcyBjb21wbGV0ZWx5XG4gKiBhcmJpdHJhcnkgYW5kIHRoZSBpbXBsZW1lbnRhdGlvbiBpc24ndCBlc3BlY2lhbGx5IGVmZmljaWVudC5cbiAqL1xuXG52YXIgREVGQVVMVF9NQVhfS0VZUyA9IDEwMDtcblxuZnVuY3Rpb24gSW1hZ2VDYWNoZShvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgbWF4S2V5czogREVGQVVMVF9NQVhfS0VZUyB9O1xuICAgIHRoaXMubWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cyB8fCBERUZBVUxUX01BWF9LRVlTO1xuXG4gICAgdGhpcy5faGVsZCA9IHt9O1xuICAgIHRoaXMuX3VybHMgPSB7fTtcbiAgICB0aGlzLl9scnUgPSBbXTtcbn1cblxuSW1hZ2VDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybClcbntcbiAgICB2YXIgcmVjb3JkID0gdGhpcy5fdXJsc1t1cmxdO1xuICAgIHJldHVybiByZWNvcmQgPyByZWNvcmQuaW1nIDogbnVsbDtcbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh1cmwpXG57XG4gICAgcmV0dXJuICEhdGhpcy5fdXJsc1t1cmxdO1xufTtcblxuSW1hZ2VDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHVybCwgaW1nKVxue1xuICAgIHZhciByZWNvcmQgPSB0aGlzLl91cmxzW3VybF07XG4gICAgaWYgKHJlY29yZClcbiAgICB7XG4gICAgICAgIC8vIEZJWE1FOiBEb2VzIHRoaXMgbWFrZSBzZW5zZSBmb3IgdGhpcyB1c2UgY2FzZT9cbiAgICAgICAgcmVjb3JkLmltZyA9IGltZztcbiAgICAgICAgdGhpcy5fcHJvbW90ZShyZWNvcmQpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZWNvcmQgPSB7XG4gICAgICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fdXJsc1t1cmxdID0gcmVjb3JkO1xuICAgICAgICB0aGlzLl90cnlFdmljdCgxKTtcbiAgICAgICAgdGhpcy5fbHJ1LnVuc2hpZnQocmVjb3JkKTtcbiAgICB9XG59O1xuXG5JbWFnZUNhY2hlLnByb3RvdHlwZS5fcHJvbW90ZSA9IGZ1bmN0aW9uIChyZWNvcmQpXG57XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbHJ1LmluZGV4T2YocmVjb3JkKTtcbiAgICB0aGlzLl9scnUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9scnUudW5zaGlmdChyZWNvcmQpO1xufTtcblxuSW1hZ2VDYWNoZS5wcm90b3R5cGUuX3RyeUV2aWN0ID0gZnVuY3Rpb24gKGV4dHJhQ2FwYWNpdHkpXG57XG4gICAgdmFyIGFsbG93ZWRFbnRyeUNvdW50ID0gdGhpcy5tYXhLZXlzIC0gZXh0cmFDYXBhY2l0eTtcblxuICAgIGlmICh0aGlzLl9scnUubGVuZ3RoIDw9IGFsbG93ZWRFbnRyeUNvdW50KVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgZXZpY3Rpb25JbmRleCA9IHRoaXMuX2xydS5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7OylcbiAgICB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9scnVbZXZpY3Rpb25JbmRleF07XG5cbiAgICAgICAgaWYgKCF0aGlzLl9oZWxkW3RhcmdldC51cmxdKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWJ1ZygnRXZpY3RpbmcgaW1hZ2UgJXMnLCB0YXJnZXQudXJsKTtcbiAgICAgICAgICAgIHRoaXMuX2xydS5zcGxpY2UoZXZpY3Rpb25JbmRleCwgMSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdXJsc1t0YXJnZXQudXJsXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xydS5sZW5ndGggPD0gYWxsb3dlZEVudHJ5Q291bnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZpY3Rpb25JbmRleCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGRlYnVnLmVuYWJsZWQgJiYgZGVidWcoJ0NhY2hlIG92ZXJmdWxsIGJ5ICVzIChhbGwgZW50cmllcyBhcmUgYmVpbmcgaGVsZCknLFxuICAgICAgICAgICAgICAgIHRoaXMuX2xydS5sZW5ndGggLSBhbGxvd2VkRW50cnlDb3VudCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZpY3Rpb25JbmRleC0tO1xuICAgIH1cbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIHRoaXMuX2hlbGRbdXJsXSA9ICh0aGlzLl9oZWxkW3VybF0gfHwgMCkgKyAxO1xuICAgIHRoaXMuX3Byb21vdGUodGhpcy5fdXJsc1t1cmxdKTtcbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIHZhciBjb3VudCA9IHRoaXMuX2hlbGRbdXJsXTtcblxuICAgIGlmIChjb3VudCA+IDEpXG4gICAgICAgIHRoaXMuX2hlbGRbdXJsXS0tO1xuICAgIGVsc2VcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlbGRbdXJsXTtcblxuICAgIHRoaXMuX3RyeUV2aWN0KDApO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvaW1hZ2UtY2FjaGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpJbWFnZVJlcXVlc3RIYW5kbGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VSZXF1ZXN0SGFuZGxlcjtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciB0aGUgcmVxdWVzdCBmb3IgYW4gaW1hZ2UgdGlsZVxuICpcbiAqIEBwYXJhbSB1cmxcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEltYWdlUmVxdWVzdEhhbmRsZXIob3B0aW9ucylcbntcbiAgICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLl9jYWxsYmFjayA9IG9wdGlvbnMubG9hZDtcbiAgICB0aGlzLl9lcnJvckNhbGxiYWNrID0gb3B0aW9ucy5lcnJvcjtcbiAgICB0aGlzLnRpbWVvdXRUaW1lID0gb3B0aW9ucy50aW1lb3V0VGltZSB8fCAwO1xuICAgIHRoaXMuX2Fib3J0ZWQgPSB0aGlzLl9jb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLy9Vc2UgYSB0aW1lb3V0IHRvIGFsbG93IHRoZSByZXF1ZXN0cyB0byBiZSBkZWJvdW5jZWQgKGFzIHRoZXkgYXJlIGluIHJlbmRlcmVyKVxuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gSW5pdGlhdGUgdGhlIHJlcXVlc3RcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdGhpcy5faW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgICB0aGlzLl9pbWFnZS5vbmxvYWQgPSB0aGlzLl9oYW5kbGVMb2FkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2ltYWdlLm9uZXJyb3IgPSB0aGlzLl9oYW5kbGVFcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9pbWFnZS5zcmMgPSBvcHRpb25zLnVybDtcblxuICAgICAgICBkZWJ1ZygnUmVxdWVzdGluZyBpbWFnZSAlcycsIG9wdGlvbnMudXJsKTtcbiAgICB9LmJpbmQodGhpcyksIHRoaXMudGltZW91dFRpbWUpO1xufVxuXG5JbWFnZVJlcXVlc3RIYW5kbGVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpXG57XG4gICAgZGVidWcoJ0Fib3J0aW5nIHJlcXVlc3QgdG8gJXMnLCB0aGlzLl91cmwpO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG5cbiAgICAvLyBGSVhNRVxuICAgIC8vIFBlb3BsZSBvbiB0aGUgSW50ZXJuZXQgc2F5IHRoYXQgZG9pbmcgdGhpcyB7e3Nob3VsZC9zaG91bGQgbm90fX0gYWJvcnQgdGhlIHJlcXVlc3QuIEkgYmVsaWV2ZVxuICAgIC8vIGl0IGNvcnJlc3BvbmRzIHRvIHdoYXQgdGhlIFdIQVRXRyBIVE1MIHNwZWMgc2F5cyBzaG91bGQgaGFwcGVuIHdoZW4gdGhlIFVBXG4gICAgLy8gdXBkYXRlcyB0aGUgaW1hZ2UgZGF0YSBpZiBzZWxlY3RlZCBzb3VyY2UgaXMgbnVsbC5cbiAgICAvL1xuICAgIC8vIFNvdXJjZXM6XG4gICAgLy9cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGhlLWltZy1lbGVtZW50XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzkwODg4L2RvZXMtY2hhbmdpbmctdGhlLXNyYy1hdHRyaWJ1dGUtb2YtYW4taW1hZ2Utc3RvcC10aGUtaW1hZ2UtZnJvbS1kb3dubG9hZGluZ1xuICAgIGlmICh0aGlzLl9pbWFnZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2ltYWdlLm9ubG9hZCA9IHRoaXMuX2ltYWdlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2ltYWdlLnNyYyA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xufTtcblxuSW1hZ2VSZXF1ZXN0SGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9hYm9ydGVkKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2VSZXF1ZXN0SGFuZGxlciBpbnZva2VkIG9uIGNhbmNlbGxlZCByZXF1ZXN0IGZvciAnICsgdGhpcy5fdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb21wbGV0ZSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltYWdlUmVxdWVzdEhhbmRsZXIgaW52b2tlZCBvbiBjb21wbGV0ZWQgcmVxdWVzdCBmb3IgJyArIHRoaXMuX3VybCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XG5cbiAgICBkZWJ1ZygnUmVjZWl2ZWQgaW1hZ2UgJXMnLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMuX2ltYWdlKTtcbn07XG5cbkltYWdlUmVxdWVzdEhhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uICgpXG57XG4gICAgZGVidWcoJ0ZhaWxlZCB0byBsb2FkIGltYWdlICVzJywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9lcnJvckNhbGxiYWNrKHRoaXMuX2ltYWdlKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL2ltYWdlLXJlcXVlc3QtaGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgcGVyZm9ybWFuY2UgKi9cblxuLy8gVE9ETzogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZhbGxiYWNrXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFuaW1hdGU6IGFuaW1hdGUsXG4gICAgZWFzaW5nOiB7XG4gICAgICAgIGxpbmVhcjogbGluZWFyRWFzaW5nXG4gICAgfVxufTtcblxuZnVuY3Rpb24gYW5pbWF0ZShvcHRpb25zKVxue1xuICAgIHZhciBkdXJhdGlvbk1zID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgICB2YXIgcGFyYW1ldGVycyA9IG9wdGlvbnMucGFyYW1ldGVycztcbiAgICB2YXIgb25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIHZhciBvbkVuZCA9IG9wdGlvbnMub25FbmQ7XG5cbiAgICAvLyBTZXR1cFxuICAgIC8vIFRpbWVzIGFyZSBpbiBtaWxsaXNlY29uZHMgZnJvbSBhIGJhc2ljYWxseSBhcmJpdHJhcnkgc3RhcnRcbiAgICB2YXIgc3RhcnQgPSBub3coKTtcbiAgICB2YXIgZW5kID0gc3RhcnQgKyBkdXJhdGlvbk1zO1xuXG4gICAgdmFyIHR3ZWVuRm5zID0ge307XG4gICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgIHZhciBwYXJhbUtleXMgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKTtcblxuICAgIHBhcmFtS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICB2YXIgY29uZmlnID0gcGFyYW1ldGVyc1trZXldO1xuICAgICAgICB0d2VlbkZuc1trZXldID0gaW50ZXJwb2xhdGUoY29uZmlnLmZyb20sIGNvbmZpZy50bywgY29uZmlnLmVhc2luZyB8fCBsaW5lYXJFYXNpbmcpO1xuICAgIH0pO1xuXG4gICAgLy8gUnVuIGl0IVxuICAgIHZhciByZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RJZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUFuaW1hdGlvbkNvbXBsZXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpXG4gICAge1xuICAgICAgICB2YXIgY3VycmVudCA9IG5vdygpO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IE1hdGgubWluKChjdXJyZW50IC0gc3RhcnQpIC8gZHVyYXRpb25NcywgMSk7XG5cbiAgICAgICAgdXBkYXRlVmFsdWVzKGVsYXBzZWQpO1xuICAgICAgICBvblVwZGF0ZSh2YWx1ZXMpO1xuXG4gICAgICAgIGlmIChjdXJyZW50IDwgZW5kKVxuICAgICAgICAgICAgcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGhhbmRsZUFuaW1hdGlvbkNvbXBsZXRpb24oe1xuICAgICAgICAgICAgICAgIGludGVycnVwdGVkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWVzKGVsYXBzZWQpXG4gICAge1xuICAgICAgICBwYXJhbUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHR3ZWVuRm5zW2tleV0oZWxhcHNlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUFuaW1hdGlvbkNvbXBsZXRpb24oaW5mbylcbiAgICB7XG4gICAgICAgIHJlcXVlc3RJZCA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9uRW5kKVxuICAgICAgICAgICAgb25FbmQoaW5mbyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBlYXNpbmcpXG57XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGFwc2VkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGVhc2luZyhlbGFwc2VkKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBsaW5lYXJFYXNpbmcoZSlcbntcbiAgICByZXR1cm4gZTtcbn1cblxudmFyIG5vdztcblxuaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KVxue1xuICAgIG5vdyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbn1cbmVsc2VcbntcbiAgICBub3cgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvaW50ZXJwb2xhdGUtYW5pbWF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRCb29rTGF5b3V0R3JvdXBzID0gcmVxdWlyZSgnLi9ib29rLWxheW91dCcpO1xudmFyIGdldFNpbmdsZXNMYXlvdXRHcm91cHMgPSByZXF1aXJlKCcuL3NpbmdsZXMtbGF5b3V0Jyk7XG52YXIgZ2V0R3JpZExheW91dEdyb3VwcyA9IHJlcXVpcmUoJy4vZ3JpZC1sYXlvdXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQYWdlTGF5b3V0cztcblxuLyoqIEdldCB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcGFnZXMgZm9yIHRoZSBjdXJyZW50IHZpZXcgKi9cbmZ1bmN0aW9uIGdldFBhZ2VMYXlvdXRzKHNldHRpbmdzKVxue1xuICAgIGlmIChzZXR0aW5ncy5pbkdyaWQpXG4gICAge1xuICAgICAgICByZXR1cm4gZ2V0R3JpZExheW91dEdyb3VwcyhwbHVjayhzZXR0aW5ncywgW1xuICAgICAgICAgICAgJ21hbmlmZXN0JyxcbiAgICAgICAgICAgICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAncGFnZXNQZXJSb3cnLFxuICAgICAgICAgICAgJ2ZpeGVkSGVpZ2h0R3JpZCcsXG4gICAgICAgICAgICAnZml4ZWRQYWRkaW5nJyxcbiAgICAgICAgICAgICdzaG93Tm9uUGFnZWRQYWdlcydcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgY29uZmlnID0gcGx1Y2soc2V0dGluZ3MsIFsnbWFuaWZlc3QnLCAndmVydGljYWxseU9yaWVudGVkJywgJ3Nob3dOb25QYWdlZFBhZ2VzJ10pO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5pbkJvb2tMYXlvdXQpXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qm9va0xheW91dEdyb3Vwcyhjb25maWcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZ2V0U2luZ2xlc0xheW91dEdyb3Vwcyhjb25maWcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGx1Y2sob2JqLCBrZXlzKVxue1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIG91dFtrZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRQYWdlRGltZW5zaW9ucyA9IHJlcXVpcmUoJy4vcGFnZS1kaW1lbnNpb25zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Qm9va0xheW91dEdyb3VwcztcblxuZnVuY3Rpb24gZ2V0Qm9va0xheW91dEdyb3Vwcyh2aWV3ZXJDb25maWcpXG57XG4gICAgdmFyIGdyb3VwaW5ncyA9IGdldEdyb3VwaW5ncyh2aWV3ZXJDb25maWcpO1xuXG4gICAgcmV0dXJuIGdyb3VwaW5ncy5tYXAoZnVuY3Rpb24gKGdyb3VwaW5nKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGdldEdyb3VwTGF5b3V0c0Zyb21QYWdlR3JvdXBpbmcodmlld2VyQ29uZmlnLCBncm91cGluZyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwaW5ncyh2aWV3ZXJDb25maWcpXG57XG4gICAgdmFyIG1hbmlmZXN0ID0gdmlld2VyQ29uZmlnLm1hbmlmZXN0O1xuXG4gICAgdmFyIHBhZ2VzQnlHcm91cCA9IFtdO1xuICAgIHZhciBsZWZ0UGFnZSA9IG51bGw7XG4gICAgdmFyIG5vblBhZ2VkUGFnZXMgPSBbXTsgLy8gUGFnZXMgdG8gZGlzcGxheSBiZWxvdyB0aGUgY3VycmVudCBncm91cFxuXG4gICAgdmFyIF9hZGROb25QYWdlZFBhZ2VzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25QYWdlZFBhZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwYWdlc0J5R3JvdXAucHVzaChbIG5vblBhZ2VkUGFnZXNbaV0gXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9uUGFnZWRQYWdlcyA9IFtdO1xuICAgIH07XG5cbiAgICBtYW5pZmVzdC5wYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBwYWdlUmVjb3JkID0ge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZGltZW5zaW9uczogZ2V0UGFnZURpbWVuc2lvbnMoaW5kZXgsIG1hbmlmZXN0KSxcbiAgICAgICAgICAgIHBhZ2VkOiAoIW1hbmlmZXN0LnBhZ2VkIHx8IHBhZ2UucGFnZWQpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gT25seSBkaXNwbGF5IG5vbi1wYWdlZCBwYWdlcyBpZiBzcGVjaWZpZWQgaW4gdGhlIHNldHRpbmdzXG4gICAgICAgIGlmICghdmlld2VyQ29uZmlnLnNob3dOb25QYWdlZFBhZ2VzICYmICFwYWdlUmVjb3JkLnBhZ2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICghcGFnZVJlY29yZC5wYWdlZClcbiAgICAgICAge1xuICAgICAgICAgICAgbm9uUGFnZWRQYWdlcy5wdXNoKHBhZ2VSZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSAwIHx8IHBhZ2UuZmFjaW5nUGFnZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYWdlIGlzIHBsYWNlZCBvbiBpdHMgb3duXG4gICAgICAgICAgICBwYWdlc0J5R3JvdXAucHVzaChbcGFnZVJlY29yZF0pO1xuICAgICAgICAgICAgX2FkZE5vblBhZ2VkUGFnZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0UGFnZSA9PT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgbGVmdFBhZ2UgPSBwYWdlUmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZXNCeUdyb3VwLnB1c2goW2xlZnRQYWdlLCBwYWdlUmVjb3JkXSk7XG4gICAgICAgICAgICBsZWZ0UGFnZSA9IG51bGw7XG4gICAgICAgICAgICBfYWRkTm9uUGFnZWRQYWdlcygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGbHVzaCBhIGZpbmFsIGxlZnQgcGFnZVxuICAgIGlmIChsZWZ0UGFnZSAhPT0gbnVsbClcbiAgICB7XG4gICAgICAgIHBhZ2VzQnlHcm91cC5wdXNoKFtsZWZ0UGFnZV0pO1xuICAgICAgICBfYWRkTm9uUGFnZWRQYWdlcygpO1xuICAgIH1cblxuICAgIHJldHVybiBwYWdlc0J5R3JvdXA7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwTGF5b3V0c0Zyb21QYWdlR3JvdXBpbmcodmlld2VyQ29uZmlnLCBncm91cGluZylcbntcbiAgICB2YXIgdmVydGljYWxseU9yaWVudGVkID0gdmlld2VyQ29uZmlnLnZlcnRpY2FsbHlPcmllbnRlZDtcblxuICAgIGlmIChncm91cGluZy5sZW5ndGggPT09IDIpXG4gICAgICAgIHJldHVybiBnZXRGYWNpbmdQYWdlR3JvdXAoZ3JvdXBpbmdbMF0sIGdyb3VwaW5nWzFdLCB2ZXJ0aWNhbGx5T3JpZW50ZWQpO1xuXG4gICAgdmFyIHBhZ2UgPSBncm91cGluZ1swXTtcbiAgICB2YXIgcGFnZURpbXMgPSBwYWdlLmRpbWVuc2lvbnM7XG5cbiAgICAvLyBUaGUgZmlyc3QgcGFnZSBpcyBwbGFjZWQgb24gaXRzIG93biB0byB0aGUgcmlnaHQgaW4gdmVydGljYWwgb3JpZW50YXRpb24uXG4gICAgLy8gTkIgdGhhdCB0aGlzIG5lZWRzIHRvIGJlIHRoZSBwYWdlIHdpdGggaW5kZXggMDsgaWYgdGhlIGZpcnN0IHBhZ2UgaXMgZXhjbHVkZWRcbiAgICAvLyBmcm9tIHRoZSBsYXlvdXQgdGhlbiB0aGlzIHNwZWNpYWwgY2FzZSBzaG91bGRuJ3QgYXBwbHkuXG4gICAgLy8gSWYgdGhlIHBhZ2UgaXMgdGFnZ2VkIGFzICdub24tcGFnZWQnLCBjZW50ZXIgaXQgaG9yaXpvbnRhbGx5XG4gICAgdmFyIGxlZnRPZmZzZXQ7XG4gICAgaWYgKHBhZ2UucGFnZWQpXG4gICAgICAgIGxlZnRPZmZzZXQgPSAocGFnZS5pbmRleCA9PT0gMCAmJiB2ZXJ0aWNhbGx5T3JpZW50ZWQpID8gcGFnZURpbXMud2lkdGggOiAwO1xuICAgIGVsc2VcbiAgICAgICAgbGVmdE9mZnNldCA9ICh2ZXJ0aWNhbGx5T3JpZW50ZWQpID8gcGFnZURpbXMud2lkdGggLyAyIDogMDtcblxuICAgIHZhciBzaG91bGRCZUhvcml6b250YWxseUFkanVzdGVkID1cbiAgICAgICAgdmVydGljYWxseU9yaWVudGVkICYmICF2aWV3ZXJDb25maWcubWFuaWZlc3QucGFnZXNbcGFnZS5pbmRleF0uZmFjaW5nUGFnZXM7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGxlZnQtYWxpZ24gdGhlIHBhZ2UgaW4gdmVydGljYWwgb3JpZW50YXRpb24sIHNvIHdlIGRvdWJsZVxuICAgIC8vIHRoZSBncm91cCB3aWR0aFxuICAgIHJldHVybiB7XG4gICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgIGhlaWdodDogcGFnZURpbXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHNob3VsZEJlSG9yaXpvbnRhbGx5QWRqdXN0ZWQgPyBwYWdlRGltcy53aWR0aCAqIDIgOiBwYWdlRGltcy53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBwYWdlczogW3tcbiAgICAgICAgICAgIGluZGV4OiBwYWdlLmluZGV4LFxuICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdE9mZnNldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBhZ2VEaW1zXG4gICAgICAgIH1dXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjaW5nUGFnZUdyb3VwKGxlZnRQYWdlLCByaWdodFBhZ2UsIHZlcnRpY2FsbHlPcmllbnRlZClcbntcbiAgICB2YXIgbGVmdERpbXMgPSBsZWZ0UGFnZS5kaW1lbnNpb25zO1xuICAgIHZhciByaWdodERpbXMgPSByaWdodFBhZ2UuZGltZW5zaW9ucztcblxuICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChsZWZ0RGltcy5oZWlnaHQsIHJpZ2h0RGltcy5oZWlnaHQpO1xuXG4gICAgdmFyIHdpZHRoLCBmaXJzdExlZnRPZmZzZXQsIHNlY29uZExlZnRPZmZzZXQ7XG5cbiAgICBpZiAodmVydGljYWxseU9yaWVudGVkKVxuICAgIHtcbiAgICAgICAgdmFyIG1pZFdpZHRoID0gTWF0aC5tYXgobGVmdERpbXMud2lkdGgsIHJpZ2h0RGltcy53aWR0aCk7XG5cbiAgICAgICAgd2lkdGggPSBtaWRXaWR0aCAqIDI7XG5cbiAgICAgICAgZmlyc3RMZWZ0T2Zmc2V0ID0gbWlkV2lkdGggLSBsZWZ0RGltcy53aWR0aDtcbiAgICAgICAgc2Vjb25kTGVmdE9mZnNldCA9IG1pZFdpZHRoO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB3aWR0aCA9IGxlZnREaW1zLndpZHRoICsgcmlnaHREaW1zLndpZHRoO1xuICAgICAgICBmaXJzdExlZnRPZmZzZXQgPSAwO1xuICAgICAgICBzZWNvbmRMZWZ0T2Zmc2V0ID0gbGVmdERpbXMud2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgcGFnZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleDogbGVmdFBhZ2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogbGVmdERpbXMsXG4gICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmaXJzdExlZnRPZmZzZXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4OiByaWdodFBhZ2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcmlnaHREaW1zLFxuICAgICAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2Vjb25kTGVmdE9mZnNldFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9ib29rLWxheW91dC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBhZ2VEaW1lbnNpb25zKHBhZ2VJbmRleCwgbWFuaWZlc3QpXG57XG4gICAgdmFyIGRpbXMgPSBtYW5pZmVzdC5nZXRNYXhQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IE1hdGguZmxvb3IoZGltcy53aWR0aCksXG4gICAgICAgIGhlaWdodDogTWF0aC5mbG9vcihkaW1zLmhlaWdodClcbiAgICB9O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL3BhZ2UtZGltZW5zaW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0UGFnZURpbWVuc2lvbnMgPSByZXF1aXJlKCcuL3BhZ2UtZGltZW5zaW9ucycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNpbmdsZXNMYXlvdXRHcm91cHModmlld2VyQ29uZmlnKVxue1xuICAgIHZhciBtYW5pZmVzdCA9IHZpZXdlckNvbmZpZy5tYW5pZmVzdDtcblxuICAgIC8vIFJlbmRlciBlYWNoIHBhZ2UgYWxvbmUgaW4gYSBncm91cFxuICAgIHZhciBwYWdlcyA9IFtdO1xuICAgIG1hbmlmZXN0LnBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2UsIGluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKCF2aWV3ZXJDb25maWcuc2hvd05vblBhZ2VkUGFnZXMgJiYgbWFuaWZlc3QucGFnZWQgJiYgIXBhZ2UucGFnZWQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIHBhZ2VEaW1zID0gZ2V0UGFnZURpbWVuc2lvbnMoaW5kZXgsIG1hbmlmZXN0KTtcblxuICAgICAgICBwYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBhZ2VEaW1zLFxuICAgICAgICAgICAgcGFnZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHt0b3A6IDAsIGxlZnQ6IDB9LFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBwYWdlRGltc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFnZXM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvc2luZ2xlcy1sYXlvdXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBnZXRHcmlkTGF5b3V0R3JvdXBzO1xuXG5mdW5jdGlvbiBnZXRHcmlkTGF5b3V0R3JvdXBzKHZpZXdlckNvbmZpZylcbntcbiAgICB2YXIgdmlld3BvcnRXaWR0aCA9IHZpZXdlckNvbmZpZy52aWV3cG9ydC53aWR0aDtcbiAgICB2YXIgbWFuaWZlc3QgPSB2aWV3ZXJDb25maWcubWFuaWZlc3Q7XG4gICAgdmFyIHBhZ2VzUGVyUm93ID0gdmlld2VyQ29uZmlnLnBhZ2VzUGVyUm93O1xuICAgIHZhciBmaXhlZEhlaWdodEdyaWQgPSB2aWV3ZXJDb25maWcuZml4ZWRIZWlnaHRHcmlkO1xuICAgIHZhciBmaXhlZFBhZGRpbmcgPSB2aWV3ZXJDb25maWcuZml4ZWRQYWRkaW5nO1xuICAgIHZhciBzaG93Tm9uUGFnZWRQYWdlcyA9IHZpZXdlckNvbmZpZy5zaG93Tm9uUGFnZWRQYWdlcztcblxuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IGZpeGVkUGFkZGluZyAqIChwYWdlc1BlclJvdyArIDEpO1xuICAgIHZhciBwYWdlV2lkdGggPSAodmlld3BvcnRXaWR0aCAtIGhvcml6b250YWxQYWRkaW5nKSAvIHBhZ2VzUGVyUm93O1xuICAgIHZhciBncmlkUGFnZVdpZHRoID0gcGFnZVdpZHRoO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByb3cgaGVpZ2h0IGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gZml4IHRoZSB3aWR0aCBvciB0aGUgaGVpZ2h0XG4gICAgdmFyIHJvd0hlaWdodCA9IChmaXhlZEhlaWdodEdyaWQpID8gZml4ZWRQYWRkaW5nICsgbWFuaWZlc3QubWluUmF0aW8gKiBwYWdlV2lkdGggOiBmaXhlZFBhZGRpbmcgKyBtYW5pZmVzdC5tYXhSYXRpbyAqIHBhZ2VXaWR0aDtcblxuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICB2YXIgY3VycmVudFBhZ2VzID0gW107XG5cbiAgICB2YXIgZ2V0R3JpZFBhZ2VEaW1lbnNpb25zID0gZnVuY3Rpb24gKHBhZ2VEYXRhKVxuICAgIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBob3Jpem9udGFsIHBsYWNlbWVudCBvZiB0aGlzIHBhZ2VcbiAgICAgICAgLy8gR2V0IGRpbWVuc2lvbnMgYXQgbWF4IHpvb20gbGV2ZWwsIGFsdGhvdWdoIGFueSBsZXZlbCBzaG91bGQgYmUgZmluZVxuICAgICAgICB2YXIgcGFnZURpbWVuRGF0YSA9IHBhZ2VEYXRhLmRbcGFnZURhdGEuZC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGhlaWdodFRvV2lkdGhSYXRpbyA9IHBhZ2VEaW1lbkRhdGEuaCAvIHBhZ2VEaW1lbkRhdGEudztcblxuICAgICAgICB2YXIgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0O1xuXG4gICAgICAgIGlmIChmaXhlZEhlaWdodEdyaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCA9IChyb3dIZWlnaHQgLSBmaXhlZFBhZGRpbmcpIC8gaGVpZ2h0VG9XaWR0aFJhdGlvO1xuICAgICAgICAgICAgcGFnZUhlaWdodCA9IHJvd0hlaWdodCAtIGZpeGVkUGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCA9IGdyaWRQYWdlV2lkdGg7XG4gICAgICAgICAgICBwYWdlSGVpZ2h0ID0gcGFnZVdpZHRoICogaGVpZ2h0VG9XaWR0aFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHBhZ2VXaWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQocGFnZUhlaWdodClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHJvd0RpbWVuc2lvbnMgPSB7XG4gICAgICAgIGhlaWdodDogcm93SGVpZ2h0LFxuICAgICAgICB3aWR0aDogdmlld3BvcnRXaWR0aFxuICAgIH07XG5cbiAgICBtYW5pZmVzdC5wYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlLCBwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBpZiAoIXNob3dOb25QYWdlZFBhZ2VzICYmIG1hbmlmZXN0LnBhZ2VkICYmICFwYWdlLnBhZ2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgd2lkdGgsIGhlaWdodCBhbmQgaG9yaXpvbnRhbCBwbGFjZW1lbnQgb2YgdGhpcyBwYWdlXG4gICAgICAgIHZhciBwYWdlRGltZW5zID0gZ2V0R3JpZFBhZ2VEaW1lbnNpb25zKHBhZ2UpO1xuICAgICAgICB2YXIgbGVmdE9mZnNldCA9IE1hdGguZmxvb3IoY3VycmVudFBhZ2VzLmxlbmd0aCAqIChmaXhlZFBhZGRpbmcgKyBncmlkUGFnZVdpZHRoKSArIGZpeGVkUGFkZGluZyk7XG5cbiAgICAgICAgLy8gQ2VudGVyIHRoZSBwYWdlIGlmIHRoZSBoZWlnaHQgaXMgZml4ZWQgKG90aGVyd2lzZSwgdGhlcmUgaXMgbm8gaG9yaXpvbnRhbCBwYWRkaW5nKVxuICAgICAgICBpZiAoZml4ZWRIZWlnaHRHcmlkKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ICs9IChncmlkUGFnZVdpZHRoIC0gcGFnZURpbWVucy53aWR0aCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogUHJlY29tcHV0ZSBwYWdlIGRpbWVuc2lvbnMgZXZlcnl3aGVyZVxuICAgICAgICBjdXJyZW50UGFnZXMucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZURpbWVucyxcbiAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnRPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlcy5sZW5ndGggPT09IHBhZ2VzUGVyUm93KVxuICAgICAgICB7XG4gICAgICAgICAgICBncm91cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcm93RGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBwYWdlczogY3VycmVudFBhZ2VzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY3VycmVudFBhZ2VzID0gW107XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjdXJyZW50UGFnZXMubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHJvd0RpbWVuc2lvbnMsXG4gICAgICAgICAgICBwYWdlczogY3VycmVudFBhZ2VzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cHM7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9ncmlkLWxheW91dC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldHRpbmdzVmlldztcblxuZnVuY3Rpb24gY3JlYXRlU2V0dGluZ3NWaWV3KHNvdXJjZXMpXG57XG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpXG4gICAge1xuICAgICAgICByZWdpc3Rlck1peGluKG9iaiwgc291cmNlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTWl4aW4ob2JqLCBtaXhpbilcbntcbiAgICBPYmplY3Qua2V5cyhtaXhpbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peGluW2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgZXZlcnl0aGluZyBzdHJpY3QgbW9kZSBzbyB0aGlzIGlzbid0IG5lZWRlZFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgc2V0dGluZ3MuJyArIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9zZXR0aW5ncy12aWV3LmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBleHRlbmQgPSByZXF1aXJlKCdqcXVlcnknKS5leHRlbmQ7XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblJ1bm5lcjtcblxuZnVuY3Rpb24gVmFsaWRhdGlvblJ1bm5lcihvcHRpb25zKVxue1xuICAgIHRoaXMud2hpdGVsaXN0ZWRLZXlzID0gb3B0aW9ucy53aGl0ZWxpc3RlZEtleXMgfHwgW107XG4gICAgdGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyA9IG9wdGlvbnMuYWRkaXRpb25hbFByb3BlcnRpZXMgfHwgW107XG4gICAgdGhpcy52YWxpZGF0aW9ucyA9IG9wdGlvbnMudmFsaWRhdGlvbnM7XG59XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgc2V0dGluZ3MpXG57XG4gICAgLy8gR2V0IHRoZSB2YWxpZGF0aW9uIGluZGV4XG4gICAgdmFyIHZhbGlkYXRpb25JbmRleCA9IG51bGw7XG5cbiAgICB0aGlzLnZhbGlkYXRpb25zLnNvbWUoZnVuY3Rpb24gKHZhbGlkYXRpb24sIGluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbGlkYXRpb24ua2V5ICE9PSBrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFsaWRhdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKHZhbGlkYXRpb25JbmRleCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSdW4gdGhlIHZhbGlkYXRpb25cbiAgICB2YXIgZHVtbXlDaGFuZ2VzID0ge307XG4gICAgZHVtbXlDaGFuZ2VzW2tleV0gPSB2YWx1ZTtcbiAgICB2YXIgcHJveGllciA9IGNyZWF0ZVNldHRpbmdzUHJveGllcihzZXR0aW5ncywgZHVtbXlDaGFuZ2VzLCB0aGlzKTtcblxuICAgIHJldHVybiAhdGhpcy5fcnVuVmFsaWRhdGlvbih2YWxpZGF0aW9uSW5kZXgsIHZhbHVlLCBwcm94aWVyKTtcbn07XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHNldHRpbmdzKVxue1xuICAgIHRoaXMuX3ZhbGlkYXRlT3B0aW9ucyh7fSwgc2V0dGluZ3MpO1xufTtcblxuVmFsaWRhdGlvblJ1bm5lci5wcm90b3R5cGUuZ2V0VmFsaWRhdGVkT3B0aW9ucyA9IGZ1bmN0aW9uIChzZXR0aW5ncywgb3B0aW9ucylcbntcbiAgICB2YXIgY2xvbmVkID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB0aGlzLl92YWxpZGF0ZU9wdGlvbnMoc2V0dGluZ3MsIGNsb25lZCk7XG4gICAgcmV0dXJuIGNsb25lZDtcbn07XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLl92YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIG9wdGlvbnMpXG57XG4gICAgdmFyIHNldHRpbmdzUHJveGllciA9IGNyZWF0ZVNldHRpbmdzUHJveGllcihzZXR0aW5ncywgb3B0aW9ucywgdGhpcyk7XG4gICAgdGhpcy5fYXBwbHlWYWxpZGF0aW9ucyhvcHRpb25zLCBzZXR0aW5nc1Byb3hpZXIpO1xufTtcblxuVmFsaWRhdGlvblJ1bm5lci5wcm90b3R5cGUuX2FwcGx5VmFsaWRhdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywgcHJveGllcilcbntcbiAgICB0aGlzLnZhbGlkYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRpb24sIGluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KHZhbGlkYXRpb24ua2V5KSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgaW5wdXQgPSBvcHRpb25zW3ZhbGlkYXRpb24ua2V5XTtcbiAgICAgICAgdmFyIGNvcnJlY3RlZCA9IHRoaXMuX3J1blZhbGlkYXRpb24oaW5kZXgsIGlucHV0LCBwcm94aWVyKTtcblxuICAgICAgICBpZiAoY29ycmVjdGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNvcnJlY3RlZC53YXJuaW5nU3VwcHJlc3NlZClcbiAgICAgICAgICAgICAgICBlbWl0V2FybmluZyh2YWxpZGF0aW9uLmtleSwgaW5wdXQsIGNvcnJlY3RlZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIG9wdGlvbnNbdmFsaWRhdGlvbi5rZXldID0gY29ycmVjdGVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59O1xuXG5WYWxpZGF0aW9uUnVubmVyLnByb3RvdHlwZS5fcnVuVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgaW5wdXQsIHByb3hpZXIpXG57XG4gICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRpb25zW2luZGV4XTtcblxuICAgIHByb3hpZXIuaW5kZXggPSBpbmRleDtcblxuICAgIHZhciB3YXJuaW5nU3VwcHJlc3NlZCA9IGZhbHNlO1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIHN1cHByZXNzV2FybmluZzogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgd2FybmluZ1N1cHByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvdXRwdXRWYWx1ZSA9IHZhbGlkYXRpb24udmFsaWRhdGUoaW5wdXQsIHByb3hpZXIucHJveHksIGNvbmZpZyk7XG5cbiAgICBpZiAob3V0cHV0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvdXRwdXRWYWx1ZSA9PT0gaW5wdXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG91dHB1dFZhbHVlLFxuICAgICAgICB3YXJuaW5nU3VwcHJlc3NlZDogd2FybmluZ1N1cHByZXNzZWRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBUaGUgc2V0dGluZ3MgcHJveHkgd3JhcHMgdGhlIHNldHRpbmdzIG9iamVjdCBhbmQgZW5zdXJlcyB0aGF0XG4gKiBvbmx5IHZhbHVlcyB3aGljaCBoYXZlIHByZXZpb3VzbHkgYmVlbiB2YWxpZGF0ZWQgYXJlIGFjY2Vzc2VkLFxuICogdGhyb3dpbmcgYSBUeXBlRXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEZJWE1FKHdhYmFpbik6IElzIGl0IHdvcnRoIGtlZXBpbmcgdGhpcz8gV2hlbiBJIHdyb3RlIGl0IEkgaGFkXG4gKiBtdWx0aXBsZSB2YWxpZGF0aW9uIHN0YWdlcyBhbmQgaXQgd2FzIGEgbG90IGhhcmRlciB0byBrZWVwIHRyYWNrXG4gKiBvZiBldmVyeXRoaW5nLCBzbyB0aGlzIHdhcyBtb3JlIHZhbHVhYmxlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTZXR0aW5nc1Byb3hpZXIoc2V0dGluZ3MsIG9wdGlvbnMsIHJ1bm5lcilcbntcbiAgICB2YXIgcHJveGllciA9IHtcbiAgICAgICAgcHJveHk6IHt9LFxuICAgICAgICBpbmRleDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgbG9va3VwID0gbG9va3VwVmFsdWUuYmluZChudWxsLCBzZXR0aW5ncywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgcnVubmVyLndoaXRlbGlzdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uICh3aGl0ZWxpc3RlZClcbiAgICB7XG4gICAgICAgIHByb3BlcnRpZXNbd2hpdGVsaXN0ZWRdID0ge1xuICAgICAgICAgICAgZ2V0OiBsb29rdXAuYmluZChudWxsLCB3aGl0ZWxpc3RlZClcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJ1bm5lci5hZGRpdGlvbmFsUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChhZGRpdGlvbmFsKVxuICAgIHtcbiAgICAgICAgcHJvcGVydGllc1thZGRpdGlvbmFsLmtleV0gPSB7XG4gICAgICAgICAgICBnZXQ6IGFkZGl0aW9uYWwuZ2V0XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBydW5uZXIudmFsaWRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdGlvbiwgdmFsaWRhdGlvbkluZGV4KVxuICAgIHtcbiAgICAgICAgcHJvcGVydGllc1t2YWxpZGF0aW9uLmtleV0gPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25JbmRleCA8IHByb3hpZXIuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb29rdXAodmFsaWRhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBydW5uZXIudmFsaWRhdGlvbnNbcHJveGllci5pbmRleF0ua2V5O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhY2Nlc3Mgc2V0dGluZyAnICsgdmFsaWRhdGlvbi5rZXkgKyAnIHdoaWxlIHZhbGlkYXRpbmcgJyArIGN1cnJlbnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJveGllci5wcm94eSwgcHJvcGVydGllcyk7XG5cbiAgICByZXR1cm4gcHJveGllcjtcbn1cblxuZnVuY3Rpb24gZW1pdFdhcm5pbmcoa2V5LCBvcmlnaW5hbCwgY29ycmVjdGVkKVxue1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCB2YWx1ZSBmb3IgJyArIGtleSArICc6ICcgKyBvcmlnaW5hbCArICcuIFVzaW5nICcgKyBjb3JyZWN0ZWQgKyAnIGluc3RlYWQuJyk7XG59XG5cbmZ1bmN0aW9uIGxvb2t1cFZhbHVlKGJhc2UsIGV4dGVuc2lvbiwga2V5KVxue1xuICAgIGlmIChrZXkgaW4gZXh0ZW5zaW9uKVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uW2tleV07XG5cbiAgICByZXR1cm4gYmFzZVtrZXldO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy92YWxpZGF0aW9uLXJ1bm5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0O1xuXG5mdW5jdGlvbiBWaWV3cG9ydChvdXRlciwgb3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuaW50ZXJzZWN0aW9uVG9sZXJhbmNlID0gb3B0aW9ucy5pbnRlcnNlY3Rpb25Ub2xlcmFuY2UgfHwgMDtcbiAgICB0aGlzLm1heEV4dGVudCA9IG9wdGlvbnMubWF4RXh0ZW50IHx8IDIwMDA7XG5cbiAgICB0aGlzLm91dGVyID0gb3V0ZXI7XG5cbiAgICB0aGlzLl90b3AgPSB0aGlzLl9sZWZ0ID0gdGhpcy5fd2lkdGggPSB0aGlzLl9oZWlnaHQgPSB0aGlzLl9pbm5lckRpbWVuc2lvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG59XG5cblZpZXdwb3J0LnByb3RvdHlwZS5pbnRlcnNlY3RzUmVnaW9uID0gZnVuY3Rpb24gKHJlZ2lvbilcbntcbiAgICByZXR1cm4gdGhpcy5oYXNIb3Jpem9udGFsT3ZlcmxhcChyZWdpb24pICYmIHRoaXMuaGFzVmVydGljYWxPdmVybGFwKHJlZ2lvbik7XG59O1xuXG5WaWV3cG9ydC5wcm90b3R5cGUuaGFzVmVydGljYWxPdmVybGFwID0gZnVuY3Rpb24gKHJlZ2lvbilcbntcbiAgICB2YXIgdG9wID0gdGhpcy50b3AgLSB0aGlzLmludGVyc2VjdGlvblRvbGVyYW5jZTtcbiAgICB2YXIgYm90dG9tID0gdGhpcy5ib3R0b20gKyB0aGlzLmludGVyc2VjdGlvblRvbGVyYW5jZTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIGZhbGxzQmV0d2VlbihyZWdpb24udG9wLCB0b3AsIGJvdHRvbSkgfHxcbiAgICAgICAgZmFsbHNCZXR3ZWVuKHJlZ2lvbi5ib3R0b20sIHRvcCwgYm90dG9tKSB8fFxuICAgICAgICAocmVnaW9uLnRvcCA8PSB0b3AgJiYgcmVnaW9uLmJvdHRvbSA+PSBib3R0b20pXG4gICAgKTtcbn07XG5cblZpZXdwb3J0LnByb3RvdHlwZS5oYXNIb3Jpem9udGFsT3ZlcmxhcCA9IGZ1bmN0aW9uIChyZWdpb24pXG57XG4gICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQgLSB0aGlzLmludGVyc2VjdGlvblRvbGVyYW5jZTtcbiAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0ICsgdGhpcy5pbnRlcnNlY3Rpb25Ub2xlcmFuY2U7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICBmYWxsc0JldHdlZW4ocmVnaW9uLmxlZnQsIGxlZnQsIHJpZ2h0KSB8fFxuICAgICAgICBmYWxsc0JldHdlZW4ocmVnaW9uLnJpZ2h0LCBsZWZ0LCByaWdodCkgfHxcbiAgICAgICAgKHJlZ2lvbi5sZWZ0IDw9IGxlZnQgJiYgcmVnaW9uLnJpZ2h0ID49IHJpZ2h0KVxuICAgICk7XG59O1xuXG5WaWV3cG9ydC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gRklYTUU6IFNob3VsZCB0aGlzIGNoZWNrIHRoZSBpbm5lciBkaW1lbnNpb25zIGFzIHdlbGw/XG4gICAgdGhpcy5fd2lkdGggPSBjbGFtcE1heCh0aGlzLm91dGVyLmNsaWVudFdpZHRoLCB0aGlzLm1heEV4dGVudCk7XG4gICAgdGhpcy5faGVpZ2h0ID0gY2xhbXBNYXgodGhpcy5vdXRlci5jbGllbnRIZWlnaHQsIHRoaXMubWF4RXh0ZW50KTtcblxuICAgIHRoaXMuX3RvcCA9IHRoaXMub3V0ZXIuc2Nyb2xsVG9wO1xuICAgIHRoaXMuX2xlZnQgPSB0aGlzLm91dGVyLnNjcm9sbExlZnQ7XG59O1xuXG5WaWV3cG9ydC5wcm90b3R5cGUuc2V0SW5uZXJEaW1lbnNpb25zID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMpXG57XG4gICAgdGhpcy5faW5uZXJEaW1lbnNpb25zID0gZGltZW5zaW9ucztcblxuICAgIGlmIChkaW1lbnNpb25zKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdG9wID0gY2xhbXAodGhpcy5fdG9wLCAwLCBkaW1lbnNpb25zLmhlaWdodCAtIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBjbGFtcCh0aGlzLl9sZWZ0LCAwLCBkaW1lbnNpb25zLndpZHRoIC0gdGhpcy5fd2lkdGgpO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZpZXdwb3J0LnByb3RvdHlwZSwge1xuICAgIHRvcDogZ2V0Q29vcmRpbmF0ZURlc2NyaXB0b3IoJ3RvcCcsICdoZWlnaHQnKSxcbiAgICBsZWZ0OiBnZXRDb29yZGluYXRlRGVzY3JpcHRvcignbGVmdCcsICd3aWR0aCcpLFxuXG4gICAgd2lkdGg6IGdldERpbWVuc2lvbkRlc2NyaXB0b3IoJ3dpZHRoJyksXG4gICAgaGVpZ2h0OiBnZXREaW1lbnNpb25EZXNjcmlwdG9yKCdoZWlnaHQnKSxcblxuICAgIGJvdHRvbToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3AgKyB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQgKyB0aGlzLl93aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlRGVzY3JpcHRvcihjb29yZCwgYXNzb2NpYXRlZERpbWVuc2lvbilcbntcbiAgICB2YXIgcHJpdmF0ZVByb3AgPSAnXycgKyBjb29yZDtcbiAgICB2YXIgc291cmNlID0gJ3Njcm9sbCcgKyBjb29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNvb3JkLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twcml2YXRlUHJvcF07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lubmVyRGltZW5zaW9ucylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4QWxsb3dlZCA9IHRoaXMuX2lubmVyRGltZW5zaW9uc1thc3NvY2lhdGVkRGltZW5zaW9uXSAtIHRoaXNbYXNzb2NpYXRlZERpbWVuc2lvbl07XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IGNsYW1wKG5ld1ZhbHVlLCAwLCBtYXhBbGxvd2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY2xhbXBNaW4obmV3VmFsdWUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzW3ByaXZhdGVQcm9wXSA9IHRoaXMub3V0ZXJbc291cmNlXSA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25EZXNjcmlwdG9yKGRpbWVuKVxue1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ18nICsgZGltZW5dO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZmFsbHNCZXR3ZWVuKHBvaW50LCBzdGFydCwgZW5kKVxue1xuICAgIHJldHVybiBwb2ludCA+PSBzdGFydCAmJiBwb2ludCA8PSBlbmQ7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heClcbntcbiAgICByZXR1cm4gY2xhbXBNaW4oY2xhbXBNYXgodmFsdWUsIG1heCksIG1pbik7XG59XG5cbmZ1bmN0aW9uIGNsYW1wTWluKHZhbHVlLCBtaW4pXG57XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjbGFtcE1heCh2YWx1ZSwgbWF4KVxue1xuICAgIHJldHVybiBNYXRoLm1pbih2YWx1ZSwgbWF4KTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvdmlld3BvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcblxuQ2FudmFzIHBsdWdpbiBmb3IgZGl2YS5qc1xuQWRkcyBhbiBhZGp1c3RtZW50IGljb24gbmV4dCB0byBlYWNoIGltYWdlXG5cbiovXG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi4vZGl2YScpO1xuXG5yZXF1aXJlKCcuLi91dGlscy9qcXVlcnktZXh0ZW5zaW9ucycpO1xuXG4oZnVuY3Rpb24gKCQpXG57XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjYW52YXMgPSB7fSxcbiAgICAgICAgICAgIG1hcCA9IHt9LFxuICAgICAgICAgICAgc2V0dGluZ3MgPSB7fSxcbiAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgc2xpZGVycyxcbiAgICAgICAgICAgIHNsaWRlck1vZGU7XG5cbiAgICAgICAgLy8gU2V0IHVwIHNvbWUgZGVmYXVsdCBzZXR0aW5ncyAoY2FuIGJlIG92ZXJyaWRkZW4gdGhlIG5vcm1hbCB3YXkpXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGJyaWdodG5lc3NNYXg6IDE1MCxcbiAgICAgICAgICAgIGJyaWdodG5lc3NNaW46IC0xMDAsXG4gICAgICAgICAgICBicmlnaHRuZXNzU3RlcDogMSxcbiAgICAgICAgICAgIGNvbnRyYXN0TWF4OiAzLFxuICAgICAgICAgICAgY29udHJhc3RNaW46IC0xLFxuICAgICAgICAgICAgY29udHJhc3RTdGVwOiAwLjA1LFxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlUHJlZml4OiAnY2FudmFzLScsXG4gICAgICAgICAgICBtb2JpbGVXZWJraXRNYXhab29tOiAyLFxuICAgICAgICAgICAgcmdiTWF4OiA1MCxcbiAgICAgICAgICAgIHJnYk1pbjogLTUwLFxuICAgICAgICAgICAgdGhyb2JiZXJGYWRlU3BlZWQ6IDIwMCxcbiAgICAgICAgICAgIHRocm9iYmVyVGltZW91dDogMTAwLFxuICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICAgICdjb250cmFzdCcsXG4gICAgICAgICAgICAgICAgJ2JyaWdodG5lc3MnLFxuICAgICAgICAgICAgICAgICdyb3RhdGlvbicsXG4gICAgICAgICAgICAgICAgJ3pvb20nXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29udmVydCBhbiBhbmdsZSBmcm9tIGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgICAgICB2YXIgdG9SYWRpYW5zID0gZnVuY3Rpb24gKGFuZ2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgbmV3IGNlbnRlciBvZiB0aGUgcGFnZSBhZnRlciByb3RhdGluZyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAgICAgICAgdmFyIGdldE5ld0NlbnRlciA9IGZ1bmN0aW9uIChjdXJyZW50Q2VudGVyLCBhbmdsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHggPSBjdXJyZW50Q2VudGVyLnggLSBjYW52YXMuY2VudGVyWDtcbiAgICAgICAgICAgIC8vIFRha2UgdGhlIG5lZ2F0aXZlIGJlY2F1c2UgdGhlIHJvdGF0aW9uIGlzIGNvdW50ZXJjbG9ja3dpc2VcbiAgICAgICAgICAgIHZhciB5ID0gLShjdXJyZW50Q2VudGVyLnkgLSBjYW52YXMuY2VudGVyWSk7XG5cbiAgICAgICAgICAgIHZhciB0aGV0YSA9IHRvUmFkaWFucyhzbGlkZXJzLnJvdGF0aW9uLnByZXZpb3VzIC0gYW5nbGUpO1xuICAgICAgICAgICAgdmFyIG5ld1ggPSBNYXRoLmNvcyh0aGV0YSkgKiB4IC0gTWF0aC5zaW4odGhldGEpICogeSArIGNhbnZhcy5jZW50ZXJYO1xuICAgICAgICAgICAgdmFyIG5ld1kgPSAtKE1hdGguc2luKHRoZXRhKSAqIHggKyBNYXRoLmNvcyh0aGV0YSkgKiB5KSArIGNhbnZhcy5jZW50ZXJZO1xuXG4gICAgICAgICAgICByZXR1cm4geyd4JzogbmV3WCwgJ3knOiBuZXdZfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSb3RhdGVzIHRoZSBpbWFnZSBvbiB0aGUgZ2l2ZW4gY2FudmFzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICAgICAgICB2YXIgcm90YXRlQ2FudmFzID0gZnVuY3Rpb24gKGFDYW52YXMsIGFuZ2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGFDYW52YXMuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBhQ2FudmFzLnNpemUgLyAyO1xuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IC0oYUNhbnZhcy53aWR0aCAvIDIpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IC0oYUNhbnZhcy5oZWlnaHQgLyAyKTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBzbyB0aGF0IHJlbW5hbnRzIG9mIHRoZSBvbGQgaW1hZ2UgZG9uJ3Qgc2hvd1xuICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgYUNhbnZhcy5zaXplLCBhQ2FudmFzLnNpemUpO1xuXG4gICAgICAgICAgICAvLyBEbyB0aGUgcm90YXRpb25cbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUodG9SYWRpYW5zKGFuZ2xlKSk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgc3RhcnRYLCBzdGFydFksIGFDYW52YXMud2lkdGgsIGFDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBuZXcgcGl4ZWwgZGF0YSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBhZGp1c3RlZCBpbiBhZGp1c3RMZXZlbHNcbiAgICAgICAgICAgIGFDYW52YXMuZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGFDYW52YXMuc2l6ZSwgYUNhbnZhcy5zaXplKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGxhcmdlIGNhbnZhc1xuICAgICAgICB2YXIgc2hvdWxkQWRqdXN0TGV2ZWxzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNsaWRlcjtcblxuICAgICAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHNvbWV0aGluZyBoYXMgYmVlbiBjaGFuZ2VkXG4gICAgICAgICAgICBmb3IgKHNsaWRlciBpbiBzbGlkZXJzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChzbGlkZXJzW3NsaWRlcl0uY3VycmVudCAhPT0gc2xpZGVyc1tzbGlkZXJdLnByZXZpb3VzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgXCJwcmV2aW91c1wiIHZhbHVlIHRvIHRoZSBcImN1cnJlbnRcIiB2YWx1ZSBmb3IgZXZlcnkgc2xpZGVyXG4gICAgICAgIHZhciB1cGRhdGVQcmV2aW91c0xldmVscyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzbGlkZXI7XG5cbiAgICAgICAgICAgIGZvciAoc2xpZGVyIGluIHNsaWRlcnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2xpZGVyc1tzbGlkZXJdLnByZXZpb3VzID0gc2xpZGVyc1tzbGlkZXJdLmN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB0aHVtYm5haWwgcHJldmlldyAoY2FsbGVkIHdoZW4gYSBzbGlkZXIgaXMgbW92ZWQvcmVzZXQpXG4gICAgICAgIHZhciB1cGRhdGVNYXAgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByb3RhdGVDYW52YXMobWFwLCBzbGlkZXJzLnJvdGF0aW9uLmN1cnJlbnQpO1xuICAgICAgICAgICAgYWRqdXN0TGV2ZWxzKG1hcCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXJnZSBjYW52YXMgKHJvdGF0aW9uLCB6b29taW5nLCBzY3JvbGxpbmcsIHBpeGVsIG1hbmlwdWxhdGlvbilcbiAgICAgICAgdmFyIHVwZGF0ZUNhbnZhcyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHNsaWRlcnMucm90YXRpb24uY3VycmVudDtcbiAgICAgICAgICAgIHZhciBvbGRBbmdsZSA9IHNsaWRlcnMucm90YXRpb24ucHJldmlvdXM7XG4gICAgICAgICAgICB2YXIgem9vbUxldmVsID0gc2xpZGVycy56b29tLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgb2xkWm9vbUxldmVsID0gc2xpZGVycy56b29tLnByZXZpb3VzO1xuXG4gICAgICAgICAgICAvLyBTY3JvbGwgdGhlIHVzZXIgdG8gdGhlIGRlc2lyZWQgbG9jYXRpb25cbiAgICAgICAgICAgIGlmIChhbmdsZSAhPT0gb2xkQW5nbGUgfHwgem9vbUxldmVsICE9PSBvbGRab29tTGV2ZWwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgZmlndXJlIG91dCB0aGUgY3VycmVudCBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRTY3JvbGwgPSAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wU2Nyb2xsID0gJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdE9mZnNldCA9IHNldHRpbmdzLnZpZXdwb3J0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gc2V0dGluZ3Mudmlld3BvcnQuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gZGV0ZXJtaW5lIHRoZSBuZXcgY2VudGVyICh0aGUgc2FtZSBwYXJ0IG9mIHRoZSBpbWFnZSlcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2VudGVyID0gZ2V0TmV3Q2VudGVyKHt4OiBsZWZ0U2Nyb2xsICsgbGVmdE9mZnNldCwgeTogdG9wU2Nyb2xsICsgdG9wT2Zmc2V0fSwgYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5jb3Jwb3JhdGUgdGhlIHpvb20gY2hhbmdlIHJhdGlvICh3b3VsZCBiZSAxIGlmIG5vIGNoYW5nZSlcbiAgICAgICAgICAgICAgICB2YXIgem9vbUNoYW5nZSA9IE1hdGgucG93KDIsIHpvb21MZXZlbCAtIG9sZFpvb21MZXZlbCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvTGVmdFNjcm9sbCA9IHpvb21DaGFuZ2UgKiBuZXdDZW50ZXIueCAtIGxlZnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvVG9wU2Nyb2xsID0gem9vbUNoYW5nZSAqIG5ld0NlbnRlci55IC0gdG9wT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gUm90YXRlIHRoZSBsYXJnZSBjYW52YXNcbiAgICAgICAgICAgICAgICByb3RhdGVDYW52YXMoY2FudmFzLCBhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gdGhlIG5ldyBjZW50ZXJcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQodG9MZWZ0U2Nyb2xsKTtcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcCh0b1RvcFNjcm9sbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgY2FsbCBhZGp1c3RMZXZlbHMgYWdhaW4gaWYgd2UgcmVhbGx5IG5lZWQgdG8gKGV4cGVuc2l2ZSlcbiAgICAgICAgICAgIGlmIChzaG91bGRBZGp1c3RMZXZlbHMoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RMZXZlbHMoY2FudmFzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQcmV2aW91c0xldmVscygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvcGllcyB0aGUgY2FudmFzJyBwaXhlbCBhcnJheSBhbmQgcmV0dXJucyB0aGUgY29weVxuICAgICAgICB2YXIgY29weUltYWdlRGF0YSA9IGZ1bmN0aW9uIChhQ2FudmFzKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb2xkSW1hZ2VEYXRhID0gYUNhbnZhcy5kYXRhO1xuICAgICAgICAgICAgdmFyIG5ld0ltYWdlRGF0YSA9IGFDYW52YXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEob2xkSW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHZhciBwaXhlbEFycmF5ID0gbmV3SW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICB2YXIgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBwaXhlbEFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBpeGVsQXJyYXlbaV0gPSBvbGRJbWFnZURhdGEuZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ld0ltYWdlRGF0YTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gYWRqdXN0IHRoaXMgbGV2ZWwgLSB2ZXJ5IHNpbXBsZVxuICAgICAgICB2YXIgc2hvdWxkQWRqdXN0ID0gZnVuY3Rpb24gKG1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0aGlzQ2hhbmdlZCA9IHNsaWRlcnNbbW9kZV0uY3VycmVudCAhPT0gc2xpZGVyc1ttb2RlXS5wcmV2aW91cztcbiAgICAgICAgICAgIHZhciB0aGlzTm90RGVmYXVsdCA9IHNsaWRlcnNbbW9kZV0uY3VycmVudCAhPT0gc2xpZGVyc1ttb2RlXS5pbml0aWFsO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpc0NoYW5nZWQgfHwgdGhpc05vdERlZmF1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFkanVzdExldmVscyA9IGZ1bmN0aW9uIChhQ2FudmFzKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBwaXhlbCBhcnJheSB0byBhdm9pZCBkZXN0cnVjdGl2ZWx5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBjb3B5SW1hZ2VEYXRhKGFDYW52YXMpO1xuICAgICAgICAgICAgdmFyIHBpeGVsQXJyYXkgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgYW5kIGNhbGN1bGF0ZSBzb21lIHNjYWxlIGZhY3RvcnMgYW5kIG9mZnNldHNcbiAgICAgICAgICAgIHZhciBicmlnaHRuZXNzID0gc2xpZGVycy5icmlnaHRuZXNzLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgY29udHJhc3QgPSBzbGlkZXJzLmNvbnRyYXN0LmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIHZhciBicmlnaHRNdWwgPSAxICsgTWF0aC5taW4oc2V0dGluZ3MuYnJpZ2h0bmVzc01heCwgTWF0aC5tYXgoc2V0dGluZ3MuYnJpZ2h0bmVzc01pbiwgYnJpZ2h0bmVzcykpIC8gc2V0dGluZ3MuYnJpZ2h0bmVzc01heDtcbiAgICAgICAgICAgIHZhciBicmlnaHRUaW1lc0NvbnRyYXN0ID0gYnJpZ2h0TXVsICogY29udHJhc3Q7XG4gICAgICAgICAgICB2YXIgY29udHJhc3RPZmZzZXQgPSAxMjggLSAoY29udHJhc3QgKiAxMjgpO1xuXG4gICAgICAgICAgICB2YXIgcmVkT2Zmc2V0ID0gc2xpZGVycy5yZWQuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBncmVlbk9mZnNldCA9IHNsaWRlcnMuZ3JlZW4uY3VycmVudDtcbiAgICAgICAgICAgIHZhciBibHVlT2Zmc2V0ID0gc2xpZGVycy5ibHVlLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIGFkanVzdCBjZXJ0YWluIHRoaW5nc1xuICAgICAgICAgICAgdmFyIGFkanVzdFJlZCA9IHNob3VsZEFkanVzdCgncmVkJyk7XG4gICAgICAgICAgICB2YXIgYWRqdXN0R3JlZW4gPSBzaG91bGRBZGp1c3QoJ2dyZWVuJyk7XG4gICAgICAgICAgICB2YXIgYWRqdXN0Qmx1ZSA9IHNob3VsZEFkanVzdCgnYmx1ZScpO1xuXG4gICAgICAgICAgICB2YXIgYWRqdXN0QnJpZ2h0bmVzcyA9IHNob3VsZEFkanVzdCgnYnJpZ2h0bmVzcycpO1xuICAgICAgICAgICAgdmFyIGFkanVzdENvbnRyYXN0ID0gc2hvdWxkQWRqdXN0KCdjb250cmFzdCcpO1xuICAgICAgICAgICAgdmFyIGFkanVzdE90aGVycyA9IGFkanVzdEJyaWdodG5lc3MgfHwgYWRqdXN0Q29udHJhc3Q7XG5cbiAgICAgICAgICAgIHZhciB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvZmZzZXQsIHIsIGcsIGI7XG5cbiAgICAgICAgICAgIGZvciAoeCA9IDAsIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoOyB4IDwgd2lkdGg7IHgrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKHkgPSAwLCBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0OyB5IDwgaGVpZ2h0OyB5KyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAoeSAqIHdpZHRoICsgeCkgKiA0O1xuXG4gICAgICAgICAgICAgICAgICAgIHIgPSBwaXhlbEFycmF5W29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIGcgPSBwaXhlbEFycmF5W29mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBiID0gcGl4ZWxBcnJheVtvZmZzZXQgKyAyXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiB0aGUgcGl4ZWwgaXMgbm90IGJsYWNrIG9yaWdpbmFsbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgKyBnICsgYiA+IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRqdXN0IGluZGl2aWR1YWwgY29sb3VyIGNoYW5uZWxzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdFJlZCAmJiByKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gcmVkT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0R3JlZW4gJiYgZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnICs9IGdyZWVuT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0Qmx1ZSAmJiBiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgKz0gYmx1ZU9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgbmVlZCB0byBhZGp1c3QgYnJpZ2h0bmVzcyBhbmQvb3IgY29udHJhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGp1c3RPdGhlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByICogYnJpZ2h0VGltZXNDb250cmFzdCArIGNvbnRyYXN0T2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBnICogYnJpZ2h0VGltZXNDb250cmFzdCArIGNvbnRyYXN0T2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiICogYnJpZ2h0VGltZXNDb250cmFzdCArIGNvbnRyYXN0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbEFycmF5W29mZnNldF0gPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxBcnJheVtvZmZzZXQgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbEFycmF5W29mZnNldCArIDJdID0gYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYUNhbnZhcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGFDYW52YXMuY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGJveCBpbiB0aGUgcHJldmlldyBzaG93aW5nIHdoZXJlIHlvdSBjdXJyZW50bHkgYXJlXG4gICAgICAgIHZhciB1cGRhdGVWaWV3Ym94ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB0b3AgbGVmdCBjb3JuZXIgY29vcmRpbmF0ZXMgYmFzZWQgb24gb3VyIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBjb3JuZXJYID0gJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0KCkgKiBtYXAuc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICB2YXIgY29ybmVyWSA9ICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wKCkgKiBtYXAuc2NhbGVGYWN0b3I7XG5cbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IDQgdG8gY29tcGVuc2F0ZSBmb3IgdGhlIGJvcmRlcnNcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLnJvdW5kKHNldHRpbmdzLnZpZXdwb3J0LmhlaWdodCAqIG1hcC5zY2FsZUZhY3RvciksIHNldHRpbmdzLm1hcFNpemUpIC0gNDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGgubWluKE1hdGgucm91bmQoc2V0dGluZ3Mudmlld3BvcnQud2lkdGggKiBtYXAuc2NhbGVGYWN0b3IpLCBzZXR0aW5ncy5tYXBTaXplKSAtIDQ7XG5cbiAgICAgICAgICAgICQoJyNkaXZhLW1hcC12aWV3Ym94JykuaGVpZ2h0KGhlaWdodCkud2lkdGgod2lkdGgpLmNzcyh7dG9wOiBjb3JuZXJZLCBsZWZ0OiBjb3JuZXJYfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgdGh1bWJuYWlsIHByZXZpZXcgaW4gdGhlIHRvb2xiYXJcbiAgICAgICAgdmFyIGxvYWRNYXAgPSBmdW5jdGlvbiAoaW1hZ2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1hcC5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2YS1jYW52YXMtbWluaW1hcCcpO1xuICAgICAgICAgICAgbWFwLnNpemUgPSBzZXR0aW5ncy5tYXBTaXplO1xuICAgICAgICAgICAgbWFwLmNhbnZhcy53aWR0aCA9IG1hcC5zaXplO1xuICAgICAgICAgICAgbWFwLmNhbnZhcy5oZWlnaHQgPSBtYXAuc2l6ZTtcblxuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIGJsYWNrIGJhY2tncm91bmRcbiAgICAgICAgICAgIG1hcC5jb250ZXh0ID0gbWFwLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgbWFwLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgbWFwLnNpemUsIG1hcC5zaXplKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb29yZGluYXRlcy9kaW1lbnNpb25zIG9mIHRoZSBwcmV2aWV3XG4gICAgICAgICAgICBtYXAuc2NhbGVGYWN0b3IgPSBzZXR0aW5ncy5tYXBTaXplIC8gY2FudmFzLnNpemU7XG4gICAgICAgICAgICBtYXAuY29ybmVyWCA9IGNhbnZhcy5jb3JuZXJYICogbWFwLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgbWFwLmNvcm5lclkgPSBjYW52YXMuY29ybmVyWSAqIG1hcC5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgIG1hcC53aWR0aCA9IGltYWdlLndpZHRoICogbWFwLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgbWFwLmhlaWdodCA9IGltYWdlLmhlaWdodCAqIG1hcC5zY2FsZUZhY3RvcjtcblxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgaW1hZ2Ugd2l0aGluIHRoZSBtYXAgKG5vIGFkanVzdG1lbnRzKSBhbmQgc2F2ZSB0aGUgcGl4ZWwgYXJyYXlcbiAgICAgICAgICAgIG1hcC5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgbWFwLmNvcm5lclgsIG1hcC5jb3JuZXJZLCBtYXAud2lkdGgsIG1hcC5oZWlnaHQpO1xuICAgICAgICAgICAgbWFwLmRhdGEgPSBtYXAuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgc2V0dGluZ3MubWFwU2l6ZSwgc2V0dGluZ3MubWFwU2l6ZSk7XG5cbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHZpZXdib3gsIG1ha2UgaXQgcmVmbGVjdCB3aGVyZSB3ZSBjdXJyZW50bHkgYXJlXG4gICAgICAgICAgICAkKCcjZGl2YS1tYXAtdmlld2JveCcpLnNob3coKTtcbiAgICAgICAgICAgIHVwZGF0ZVZpZXdib3goKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBMb2FkIHRoZSBpbWFnZSB3aXRoaW4gdGhlIGxhcmdlIGFuZCBzbWFsbCBjYW52YXNlc1xuICAgICAgICB2YXIgbG9hZENhbnZhcyA9IGZ1bmN0aW9uIChpbWFnZVVSTCwgY2FsbGJhY2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG5cbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSAoc3F1YXJlKSBjYW52YXMgYmFzZWQgb24gdGhlIGh5cG90ZW5ldXNlXG4gICAgICAgICAgICAgICAgY2FudmFzLnNpemUgPSBNYXRoLnNxcnQoaW1hZ2Uud2lkdGggKiBpbWFnZS53aWR0aCArIGltYWdlLmhlaWdodCAqIGltYWdlLmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNpemUgdGhlIGNhbnZhcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBjYW52YXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpdmEtY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgY2FudmFzLmNhbnZhcy53aWR0aCA9IGNhbnZhcy5zaXplO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jYW52YXMuaGVpZ2h0ID0gY2FudmFzLnNpemU7XG4gICAgICAgICAgICAgICAgY2FudmFzLmNvcm5lclggPSAoY2FudmFzLnNpemUgLSBpbWFnZS53aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jb3JuZXJZID0gKGNhbnZhcy5zaXplIC0gaW1hZ2UuaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBjYW52YXMuY2VudGVyWCA9IGNhbnZhcy5zaXplIC8gMjtcbiAgICAgICAgICAgICAgICBjYW52YXMuY2VudGVyWSA9IGNhbnZhcy5zaXplIC8gMjtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGltYWdlIHRvIHRoZSBsYXJnZSBjYW52YXMsIGFuZCBzYXZlIHRoZSBwaXhlbCBhcnJheVxuICAgICAgICAgICAgICAgIGNhbnZhcy5jb250ZXh0ID0gY2FudmFzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgY2FudmFzLmNvcm5lclgsIGNhbnZhcy5jb3JuZXJZLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmRhdGEgPSBjYW52YXMuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLnNpemUsIGNhbnZhcy5zaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhc0Vycm9yID0gJzxkaXYgaWQ9XCJkaXZhLWVycm9yXCIgY2xhc3M9XCJkaXZhLWVycm9yXCI+PHA+PHN0cm9uZz5FcnJvcjwvc3Ryb25nPjwvcD48cD4nICsgZXJyb3IubWVzc2FnZSArICc8L3A+JztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNFcnJvciArPSAnPHA+WW91IG1heSBuZWVkIHRvIHVwZGF0ZSB5b3VyIHNlcnZlciBjb25maWd1cmF0aW9uIGluIG9yZGVyIHRvIHVzZSB0aGUgaW1hZ2UgbWFuaXB1bGF0aW9uIHRvb2xzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdGb3IgaGVscCwgc2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL0RETUFML2RpdmEuanMvd2lraS9UaGUtQVBJLWFuZC1QbHVnaW5zI2Etbm90ZS1hYm91dC0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW52YXMtYW5kLWNyb3NzLXNpdGUtZGF0YVwiIHRhcmdldD1cIl9ibGFua1wiPmNhbnZhcyBjcm9zcy1zaXRlIGRhdGEgZG9jdW1lbnRhdGlvbjwvYT4uPC9wPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0Vycm9yICs9ICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYmFja2Ryb3AnKS5hcHBlbmQoY2FudmFzRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlVGhyb2JiZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGxvYWQgdGhlIG1hcCB0aGUgZmlyc3QgdGltZSAod2hlbiB0aGVyZSBpcyBubyBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkTWFwKGltYWdlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcCBhbmQgdGhlIGNhbnZhcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB1cGRhdGVNYXAoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYW52YXMoY2FudmFzKTtcblxuICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRocm9iYmVyIGlmIGl0IGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGlzdHMsIGV4ZWN1dGUgaXQgKGZvciB6b29taW5nKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VVUkw7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgbG9hZCBldmVudCBmaXJlcyBmb3IgY2FjaGVkIGltYWdlcyB0b29cbiAgICAgICAgICAgIGlmICggaW1hZ2UuY29tcGxldGUgfHwgaW1hZ2UuY29tcGxldGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veXdBQUFBQUFRQUJBQUFDQVV3QU93PT1cIjtcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVVSTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlU2xpZGVyTGFiZWwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdGhpc1NsaWRlciA9IHNsaWRlcnNbc2xpZGVyTW9kZV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzU2xpZGVyLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSAodGhpc1NsaWRlci50cmFuc2Zvcm0pID8gdGhpc1NsaWRlci50cmFuc2Zvcm0odmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtdmFsdWUnKS5odG1sKHN0cmluZ1ZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlU2xpZGVyVmFsdWUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtc2xpZGVyJykudmFsKHNsaWRlcnNbc2xpZGVyTW9kZV0uY3VycmVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgVVJMIGZvciB0aGUgaW1hZ2UgYXQgdGhlIHNwZWNpZmllZCB6b29tIGxldmVsXG4gICAgICAgIHZhciBnZXRJbWFnZVVSTCA9IGZ1bmN0aW9uICh6b29tTGV2ZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNldHRpbmdzLnpvb21XaWR0aFJhdGlvICogTWF0aC5wb3coMiwgem9vbUxldmVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmRpdmFJbnN0YW5jZS5nZXRQYWdlSW1hZ2VVUkwoc2V0dGluZ3Muc2VsZWN0ZWRQYWdlSW5kZXgsIHsgd2lkdGg6IHdpZHRoIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzaG93VGhyb2JiZXIgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBPbmx5IHNob3cgdGhlIHRocm9iYmVyIGlmIGl0IHdpbGwgdGFrZSBhIGxvbmcgdGltZVxuICAgICAgICAgICAgaWYgKHNsaWRlcnMuem9vbS5jdXJyZW50ID4gMCB8fCBzZXR0aW5ncy5tb2JpbGVXZWJraXQpXG4gICAgICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICd0aHJvYmJlcicpLmFkZENsYXNzKCdjYW52YXMtdGhyb2JiZXInKS5zaG93KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSGlkZXMgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIGljb25cbiAgICAgICAgdmFyIGhpZGVUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAndGhyb2JiZXInKS5yZW1vdmVDbGFzcygnY2FudmFzLXRocm9iYmVyJykuaGlkZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIElmIGFueSBtb2RpZmljYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkLCBzYXZlIHRoZW0gdG8gbG9jYWxTdG9yYWdlXG4gICAgICAgIHZhciBzYXZlU2V0dGluZ3MgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2xpZGVyU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZUtleSA9IHNldHRpbmdzLmxvY2FsU3RvcmFnZVByZWZpeCArIHNldHRpbmdzLmZpbGVuYW1lO1xuICAgICAgICAgICAgdmFyIHNsaWRlcjtcblxuICAgICAgICAgICAgZm9yIChzbGlkZXIgaW4gc2xpZGVycylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVyc1tzbGlkZXJdLnByZXZpb3VzICE9PSBzbGlkZXJzW3NsaWRlcl0uaW5pdGlhbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlclNldHRpbmdzW3NsaWRlcl0gPSBzbGlkZXJzW3NsaWRlcl0ucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbW9kaWZpY2F0aW9ucyBuZWVkIHRvIGJlIHNhdmVkLCB1cGRhdGUgdGhlIGNhbnZhcyBwbHVnaW4gaWNvblxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucGx1Z2luSWNvbi5hZGRDbGFzcygnbmV3Jyk7XG4gICAgICAgICAgICAgICAgc3RvcmVPYmplY3Qoc3RvcmFnZUtleSwgc2xpZGVyU2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbkljb24ucmVtb3ZlQ2xhc3MoJ25ldycpO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEhhbmRsZXMgem9vbWluZyBpbiB3aGVuIHRoZSB6b29tIHNsaWRlciBpcyBjaGFuZ2VkIGFuZCB0aGUgY2hhbmdlIGlzIGFwcGxpZWRcbiAgICAgICAgdmFyIHVwZGF0ZVpvb20gPSBmdW5jdGlvbiAobmV3Wm9vbUxldmVsLCBjYWxsYmFjaylcbiAgICAgICAge1xuICAgICAgICAgICAgc2V0dGluZ3Muem9vbUxldmVsID0gbmV3Wm9vbUxldmVsO1xuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBVUkwgZm9yIHRoZSBpbWFnZSBhdCB0aGlzIG5ldyB6b29tIGxldmVsXG4gICAgICAgICAgICB2YXIgaW1hZ2VVUkwgPSBnZXRJbWFnZVVSTChuZXdab29tTGV2ZWwpO1xuXG4gICAgICAgICAgICBsb2FkQ2FudmFzKGltYWdlVVJMLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbmV3IHNjYWxlIGZhY3RvciBhbmQgdXBkYXRlIHRoZSB2aWV3Ym94XG4gICAgICAgICAgICAgICAgbWFwLnNjYWxlRmFjdG9yID0gbWFwLnNpemUgLyBjYW52YXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVWaWV3Ym94KCk7XG5cbiAgICAgICAgICAgICAgICBzYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBiaW5kQ2FudmFzS2V5RXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdXBBcnJvd0tleSA9IDM4LFxuICAgICAgICAgICAgICAgIGRvd25BcnJvd0tleSA9IDQwLFxuICAgICAgICAgICAgICAgIGxlZnRBcnJvd0tleSA9IDM3LFxuICAgICAgICAgICAgICAgIHJpZ2h0QXJyb3dLZXkgPSAzOTtcblxuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhc2UgdXBBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVXAgYXJyb3cgLSBzY3JvbGwgdXBcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AgLSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNhc2UgZG93bkFycm93S2V5OlxuICAgICAgICAgICAgICAgICAgICAvLyBEb3duIGFycm93IC0gc2Nyb2xsIGRvd25cbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AgKyBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNhc2UgbGVmdEFycm93S2V5OlxuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IGFycm93IC0gc2Nyb2xsIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdCAtIHNldHRpbmdzLmFycm93U2Nyb2xsQW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY2FzZSByaWdodEFycm93S2V5OlxuICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCBhcnJvdyAtIHNjcm9sbCByaWdodFxuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0ICsgc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGFuIG9iamVjdCB0byBKU09OIGFuZCBzYXZlIGl0IGluIGxvY2FsU3RvcmFnZVxuICAgICAgICB2YXIgc3RvcmVPYmplY3QgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIExvYWQgYW5kIGRlc2VyaWFsaXplIGEgbG9jYWxTdG9yYWdlIG9iamVjdFxuICAgICAgICB2YXIgbG9hZFN0b3JlZE9iamVjdCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGNhbnZhcywgZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIC8vIEFuZCwgZGlzYWJsZSB0aGlzIHBsdWdpblxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNTdXBwb3J0ZWQgPSAhIXdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbnZhc1N1cHBvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgYWxsIHRoZSBjb25maWd1cmFibGUgc2V0dGluZ3MgZGVmaW5lZCB1bmRlciBjYW52YXNQbHVnaW5cbiAgICAgICAgICAgICAgICAkLmV4dGVuZChzZXR0aW5ncywgZGVmYXVsdHMsIGRpdmFTZXR0aW5ncy5jYW52YXNQbHVnaW4pO1xuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGl2YUluc3RhbmNlID0gZGl2YUluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmluQ2FudmFzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaWlwU2VydmVyVVJMID0gZGl2YVNldHRpbmdzLmlpcFNlcnZlclVSTDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5pbWFnZURpciA9IGRpdmFTZXR0aW5ncy5pbWFnZURpcjtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zZWxlY3RvciA9IGRpdmFTZXR0aW5ncy5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tb2JpbGVXZWJraXQgPSBkaXZhU2V0dGluZ3MubW9iaWxlV2Via2l0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFycm93U2Nyb2xsQW1vdW50ID0gZGl2YVNldHRpbmdzLmFycm93U2Nyb2xsQW1vdW50O1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBzZXR0aW5ncyBmb3IgdGhlIHNsaWRlcnMvaWNvbnNcbiAgICAgICAgICAgICAgICBzbGlkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAnY29udHJhc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogc2V0dGluZ3MuY29udHJhc3RNaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4Jzogc2V0dGluZ3MuY29udHJhc3RNYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RlcCc6IHNldHRpbmdzLmNvbnRyYXN0U3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9GaXhlZCgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiAnQ2hhbmdlIHRoZSBjb250cmFzdCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2JyaWdodG5lc3MnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogc2V0dGluZ3MuYnJpZ2h0bmVzc01pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBzZXR0aW5ncy5icmlnaHRuZXNzTWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ZXAnOiBzZXR0aW5ncy5icmlnaHRuZXNzU3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdBZGp1c3QgdGhlIGJyaWdodG5lc3MnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdyb3RhdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0aWFsJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IDM1OSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGVwJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAnJmRlZzsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdSb3RhdGUgdGhlIGltYWdlJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnem9vbSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQsIG1pbiBhbmQgbWF4IHZhbHVlcyB1cGRhdGVkIHdpdGhpbiBzZXR1cEhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0aWFsJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RlcCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiAnQWRqdXN0IHRoZSB6b29tIGxldmVsJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncmVkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHNldHRpbmdzLnJnYk1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBzZXR0aW5ncy5yZ2JNYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RlcCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiAnQWRqdXN0IHRoZSByZWQgY2hhbm5lbCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2dyZWVuJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHNldHRpbmdzLnJnYk1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBzZXR0aW5ncy5yZ2JNYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RlcCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiAnQWRqdXN0IHRoZSBncmVlbiBjaGFubmVsJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnYmx1ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0aWFsJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBzZXR0aW5ncy5yZ2JNaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4Jzogc2V0dGluZ3MucmdiTWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ZXAnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogJ0FkanVzdCB0aGUgYmx1ZSBjaGFubmVsJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIFwiZGVmYXVsdFwiIHZhbHVlIGludG8gXCJ2YWx1ZVwiIGFuZCBcInByZXZpb3VzXCIgZm9yIGVhY2ggc2xpZGVyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2V0U2xpZGVycyA9IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlLCB0aGlzU2xpZGVyLCBzbGlkZXI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoc2xpZGVyIGluIHNsaWRlcnMpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTbGlkZXIgPSBzbGlkZXJzW3NsaWRlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzU2xpZGVyLmluaXRpYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2xpZGVyLmN1cnJlbnQgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2xpZGVyLnByZXZpb3VzID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlc2V0U2xpZGVycygpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBET00gZWxlbWVudHMgaWYgdGhleSBoYXZlbid0IGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgaWYgKCQoJyNkaXZhLWNhbnZhcy1iYWNrZHJvcCcpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0cnVlIHRvIGtlZXAgdGhlIHBsdWdpbiBlbmFibGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNCdXR0b25zTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBidXR0b25IVE1MLCBidXR0b24sIGJ1dHRvblRpdGxlLCBpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIHNldHRpbmdzLmJ1dHRvbnMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSBzZXR0aW5ncy5idXR0b25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBidXR0b25UaXRsZSA9IHNsaWRlcnNbYnV0dG9uXS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uSFRNTCA9ICc8ZGl2IGNsYXNzPVwiJyArIGJ1dHRvbiArICdcIiB0aXRsZT1cIicgKyBidXR0b25UaXRsZSArICdcIj48L2Rpdj4nO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNCdXR0b25zTGlzdC5wdXNoKGJ1dHRvbkhUTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzQnV0dG9ucyA9IGNhbnZhc0J1dHRvbnNMaXN0LmpvaW4oJycpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc1Rvb2xzID0gJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy10b29sc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImRpdmEtY2FudmFzLXRvb2xiYXJcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtY2xvc2VcIiB0aXRsZT1cIlJldHVybiB0byB0aGUgZG9jdW1lbnQgdmlld2VyXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImRpdmEtY2FudmFzLW1pbmltaXNlXCIgdGl0bGU9XCJNaW5pbWlzZSB0aGUgdG9vbGJhclwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGlkPVwiZGl2YS1jYW52YXMtaW5mb1wiPlRlc3Q8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy10b29sd2luZG93XCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImRpdmEtbWFwLXZpZXdib3hcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8Y2FudmFzIGlkPVwiZGl2YS1jYW52YXMtbWluaW1hcFwiPjwvY2FudmFzPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy1idXR0b25zXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQnV0dG9ucyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImRpdmEtY2FudmFzLXBhbmVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHAgaWQ9XCJkaXZhLWNhbnZhcy10b29sdGlwXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBpZD1cImRpdmEtY2FudmFzLW1vZGVcIj5jb250cmFzdDwvc3Bhbj46ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gaWQ9XCJkaXZhLWNhbnZhcy12YWx1ZVwiPjA8L3NwYW4+ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gaWQ9XCJkaXZhLWNhbnZhcy1yZXNldFwiIGNsYXNzPVwibGlua1wiPihSZXNldCk8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvcD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJyYW5nZVwiIGlkPVwiZGl2YS1jYW52YXMtc2xpZGVyXCI+PC9pbnB1dD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8YnIgLz4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYWN0aW9uLWJ1dHRvbnNcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBpZD1cImRpdmEtY2FudmFzLXJlc2V0LWFsbFwiPlJlc2V0IGFsbDwvYT4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBpZD1cImRpdmEtY2FudmFzLWFwcGx5XCI+QXBwbHk8L2E+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzV3JhcHBlciA9ICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtd3JhcHBlclwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGNhbnZhcyBpZD1cImRpdmEtY2FudmFzXCI+PC9jYW52YXM+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc1N0cmluZyA9ICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtYmFja2Ryb3BcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzVG9vbHMgK1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNXcmFwcGVyICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcblxuICAgICAgICAgICAgICAgICQoJ2JvZHknKS5hcHBlbmQoY2FudmFzU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHNpemUgb2YgdGhlIG1hcCwgYXMgZGVmaW5lZCBpbiB0aGUgQ1NTXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubWFwU2l6ZSA9ICQoJyNkaXZhLWNhbnZhcy1taW5pbWFwJykud2lkdGgoKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgc2xpZGVyIHdoZW4gc29tZXRoaW5nIGlzIGNsaWNrZWQsIGFuZCBtYWtlIHRoYXQgdGhlIGN1cnJlbnQgbW9kZVxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1idXR0b25zIGRpdicpLmNsaWNrKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYnV0dG9ucyAuY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdjbGlja2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlcigkKHRoaXMpLmF0dHIoJ2NsYXNzJykpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVNsaWRlciA9IGZ1bmN0aW9uIChuZXdNb2RlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyTW9kZSA9IG5ld01vZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGlkZXJEYXRhID0gc2xpZGVyc1tzbGlkZXJNb2RlXTtcblxuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYnV0dG9ucyAuJyArIHNsaWRlck1vZGUpLmFkZENsYXNzKCdjbGlja2VkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLW1vZGUnKS50ZXh0KHNsaWRlck1vZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHNsaWRlckRhdGEuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlU3RyaW5nID0gKHNsaWRlckRhdGEudHJhbnNmb3JtKSA/IHNsaWRlckRhdGEudHJhbnNmb3JtKG5ld1ZhbHVlKSA6IG5ld1ZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGlkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2YS1jYW52YXMtc2xpZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlci5taW4gPSBzbGlkZXJEYXRhLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyLm1heCA9IHNsaWRlckRhdGEubWF4O1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXIuc3RlcCA9IHNsaWRlckRhdGEuc3RlcDtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXNsaWRlcicpLnZhbChuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy12YWx1ZScpLmh0bWwobmV3VmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXIoJ2NvbnRyYXN0Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1zbGlkZXInKS5vbignaW5wdXQnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyc1tzbGlkZXJNb2RlXS5jdXJyZW50ID0gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyTGFiZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTWFwKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgdGhlIHNsaWRlcnMgdG8gdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtcmVzZXQtYWxsJykuY2xpY2soZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGlkZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChzbGlkZXIgaW4gc2xpZGVycylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyc1tzbGlkZXJdLmN1cnJlbnQgPSBzbGlkZXJzW3NsaWRlcl0uaW5pdGlhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlckxhYmVsKCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlclZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmV2aWV3XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1hcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGN1cnJlbnQgc2xpZGVyIHRvIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXJlc2V0JykuY2xpY2soZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICBzbGlkZXJzW3NsaWRlck1vZGVdLmN1cnJlbnQgPSBzbGlkZXJzW3NsaWRlck1vZGVdLmluaXRpYWw7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlckxhYmVsKCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlclZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmV2aWV3XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1hcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXJnZSBjYW52YXMgd2hlbiB0aGUgYXBwbHkgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYXBwbHknKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEFkanVzdExldmVscygpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93VGhyb2JiZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZXJzLnpvb20uY3VycmVudCAhPT0gc2xpZGVycy56b29tLnByZXZpb3VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlWm9vbShzbGlkZXJzLnpvb20uY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNhbnZhcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIG1vZGlmaWNhdGlvbnMgdG8gbG9jYWxTZXR0aW5ncyAoYWxzbyBkb25lIGluIHVwZGF0ZVpvb20gY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNldHRpbmdzLnRocm9iYmVyVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBleGl0aW5nIGNhbnZhcyBtb2RlXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWNsb3NlJykuY2xpY2soZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnb3ZlcmZsb3ctaGlkZGVuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhc2VzIGFuZCBoaWRlIHRoaW5nc1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGltcHJvdmVkIC0gbm90IGRvbmUgcHJvcGVybHk/XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMuc2l6ZSwgY2FudmFzLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICBtYXAuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgbWFwLnNpemUsIG1hcC5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AoMCkuc2Nyb2xsTGVmdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJhY2tkcm9wJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1tYXAtdmlld2JveCcpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZVRocm9iYmVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtZW5hYmxlIHNjcm9sbGluZyBvZiBkaXZhIHdoZW4gaXQgaXMgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmVuYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCdrZXlkb3duJywgYmluZENhbnZhc0tleUV2ZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICByZXNldFNsaWRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyTGFiZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJ1dHRvbnMgLmNsaWNrZWQnKS5yZW1vdmVDbGFzcygnY2xpY2tlZCcpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXIoJ2NvbnRyYXN0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMucHVibGlzaChcIkNhbnZhc1ZpZXdEaWRIaWRlXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSGlkZSB0aGUgdG9vbGJhciB3aGVuIHRoZSBtaW5pbWlzZSBpY29uIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtbWluaW1pc2UnKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXRvb2x3aW5kb3cnKS5zbGlkZVRvZ2dsZSgnZmFzdCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBzaXplIG9mIHRoZSBjYW52YXMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgcmVzaXplZFxuICAgICAgICAgICAgICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnZpZXdwb3J0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBkaXZhU2V0dGluZ3Muc2Nyb2xsYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGggLSBkaXZhU2V0dGluZ3Muc2Nyb2xsYmFyV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBzZXR0aW5ncyBidXQgb25seSByZWRyYXcgaWYgaW4gY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkNhbnZhcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdib3goKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdmlld2JveCB3aGVuIHRoZSBsYXJnZSBjYW52YXMgaXMgc2Nyb2xsZWRcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbChmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmluQ2FudmFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlld2JveCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNsaWNraW5nL2RyYWdnaW5nIG9mIHRoZSB2aWV3Ym94IChzaG91bGQgc2Nyb2xsIHRoZSBsYXJnZSBjYW52YXMpXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLW1pbmltYXAsICNkaXZhLW1hcC12aWV3Ym94JykubW91c2V1cChmdW5jdGlvbiAoZXZlbnQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBjYWNoaW5nIHRoaXMgZXZlbnR1YWxseSAoY2FuJ3QgYmUgZG9uZSBpbiBpbml0IHRob3VnaClcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9ICQoJyNkaXZhLWNhbnZhcy1taW5pbWFwJykub2Zmc2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZFggPSAoZXZlbnQucGFnZVggLSBvZmZzZXQubGVmdCkgLyBtYXAuc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZWRZID0gKGV2ZW50LnBhZ2VZIC0gb2Zmc2V0LnRvcCkgLyBtYXAuc2NhbGVGYWN0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3Aoc2NhbGVkWSAtIHNldHRpbmdzLnZpZXdwb3J0LmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQoc2NhbGVkWCAtIHNldHRpbmdzLnZpZXdwb3J0LndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbmFibGUgZHJhZyBzY3JvbGxcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMnKS5tb3VzZWRvd24oZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2dyYWJiaW5nJyk7XG4gICAgICAgICAgICAgICAgfSkubW91c2V1cChmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnZ3JhYmJpbmcnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHRvdWNoIGV2ZW50c1xuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykua2luZXRpYygpO1xuXG4gICAgICAgICAgICAgICAgLy8gbW91c2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5kcmFnc2Nyb2xsYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdFByb3BhZ2F0ZWRFdmVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdPYmplY3REaWRMb2FkJywgdGhpcy5zZXR1cEhvb2ssIGRpdmFTZXR0aW5ncy5JRCk7XG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJEaWRUZXJtaW5hdGUnLCB0aGlzLmRlc3Ryb3ksIGRpdmFTZXR0aW5ncy5JRCk7XG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdQYWdlRGlkTG9hZCcsIHRoaXMub25QYWdlTG9hZCwgZGl2YVNldHRpbmdzLklEKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ2NhbnZhcycsXG5cbiAgICAgICAgICAgIHRpdGxlVGV4dDogJ1ZpZXcgdGhlIGltYWdlIG9uIGEgY2FudmFzIGFuZCBhZGp1c3QgdmFyaW91cyBzZXR0aW5ncycsXG5cbiAgICAgICAgICAgIHNldHVwSG9vazogZnVuY3Rpb24oZGl2YVNldHRpbmdzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnZpZXdwb3J0ID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAtIGRpdmFTZXR0aW5ncy5zY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC0gZGl2YVNldHRpbmdzLnNjcm9sbGJhcldpZHRoXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIG1pbiBhbmQgbWF4IHpvb20gbGV2ZWwsIGFuZCB1cGRhdGUgdGhlIHpvb20gc2xpZGVyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubWluWm9vbUxldmVsID0gZGl2YVNldHRpbmdzLm1pblpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tYXhab29tTGV2ZWwgPSBkaXZhU2V0dGluZ3MubWF4Wm9vbUxldmVsO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgb24gdGhlIGlQYWQsIGxpbWl0IHRoZSBtYXggem9vbSBsZXZlbCB0byAyXG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgZG8gY2FudmFzIGVsZW1lbnRzIHRoYXQgYXJlID4gNSBtZWdhcGl4ZWxzIChpc3N1ZSAjMTEyKVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5tb2JpbGVXZWJraXQpXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1heFpvb21MZXZlbCA9IE1hdGgubWluKHNldHRpbmdzLm1heFpvb21MZXZlbCwgc2V0dGluZ3MubW9iaWxlV2Via2l0TWF4Wm9vbSk7XG5cbiAgICAgICAgICAgICAgICBzbGlkZXJzLnpvb20ubWluID0gc2V0dGluZ3MubWluWm9vbUxldmVsO1xuICAgICAgICAgICAgICAgIHNsaWRlcnMuem9vbS5tYXggPSBzZXR0aW5ncy5tYXhab29tTGV2ZWw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZXZlbnQsIGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlLCBzZWxlY3RlZFBhZ2VJbmRleClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBsb2FkQ2FudmFzKCkgY2FsbHMgYWxsIHRoZSBvdGhlciBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIGxvYWRcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBkaXZhSW5zdGFuY2UuZ2V0RmlsZW5hbWVzKClbc2VsZWN0ZWRQYWdlSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSByYXRpb25hbGUgZm9yIC0xIGZyb20gV2lraSAoVExEUiBhbiBvbGQgSUlQIGJ1ZylcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkaXZhSW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgLmdldFBhZ2VEaW1lbnNpb25zKHNlbGVjdGVkUGFnZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAud2lkdGggLSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHpvb21MZXZlbCA9IGRpdmFTZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlcjtcblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnpvb21XaWR0aFJhdGlvID0gd2lkdGggLyBNYXRoLnBvdygyLCB6b29tTGV2ZWwpO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbkljb24gPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubWFuaWZlc3QgPSBkaXZhU2V0dGluZ3MubWFuaWZlc3Q7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2VsZWN0ZWRQYWdlSW5kZXggPSBzZWxlY3RlZFBhZ2VJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIExpbWl0IHRoZSBtYXggem9vbSBsZXZlbCBpZiB3ZSdyZSBvbiB0aGUgaVBhZFxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5tb2JpbGVXZWJraXQpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsID0gTWF0aC5taW4oc2V0dGluZ3MubWF4Wm9vbUxldmVsLCB6b29tTGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgc2xpZGVycy56b29tLmluaXRpYWwgPSB6b29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgc2xpZGVycy56b29tLmN1cnJlbnQgPSB6b29tTGV2ZWw7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBzZXR0aW5ncyBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlLCBpZiB0aGV5IGV4aXN0XG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlclNldHRpbmdzID0gbG9hZFN0b3JlZE9iamVjdChzZXR0aW5ncy5sb2NhbFN0b3JhZ2VQcmVmaXggKyBzZXR0aW5ncy5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlclNldHRpbmdzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzbGlkZXIgaW4gc2xpZGVyU2V0dGluZ3MpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlcnNbc2xpZGVyXS5jdXJyZW50ID0gc2xpZGVyU2V0dGluZ3Nbc2xpZGVyXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgc2xpZGVyJ3MgdmFsdWUgaGFzIGNoYW5nZWQsIHVwZGF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlciA9PT0gc2xpZGVyTW9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlclZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZXIgPT09ICd6b29tJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSBzbGlkZXJTZXR0aW5nc1tzbGlkZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2xpZGVycy56b29tLnByZXZpb3VzID0gem9vbUxldmVsO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGwgaW4gYm9keSwgYW5kIHNob3cgdGhlIGNhbnZhcyBiYWNrZHJvcFxuICAgICAgICAgICAgICAgICQoJ2JvZHknKS5hZGRDbGFzcygnb3ZlcmZsb3ctaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJhY2tkcm9wJykuc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBzY3JvbGxpbmcgb24gbWFpbiBkaXZhIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmRpc2FibGVTY3JvbGxhYmxlKCk7XG4gICAgICAgICAgICAgICAgLy8gRW5hYmxlIGNhbnZhcyBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5rZXlkb3duKGJpbmRDYW52YXNLZXlFdmVudHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSBzbyBldmVudHMgY2FuIGJlIGNhcHR1cmVkXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaW5DYW52YXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlVVJMID0gZ2V0SW1hZ2VVUkwoem9vbUxldmVsKTtcblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgdGl0bGUgb2YgdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogVGhpcyBpcyBsZWdhY3kgYmVoYXZpb3VyLiBTaG91bGQgdGhpcyBiZSBhIGZpbGVuYW1lL2xhYmVsP1xuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1pbmZvJykudGV4dCgnUGFnZSAnICsgKHNlbGVjdGVkUGFnZUluZGV4ICsgMSkpO1xuXG4gICAgICAgICAgICAgICAgc2hvd1Rocm9iYmVyKCk7XG5cbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5wdWJsaXNoKCdDYW52YXNWaWV3RGlkQWN0aXZhdGUnLCBbc2VsZWN0ZWRQYWdlSW5kZXhdKTtcblxuICAgICAgICAgICAgICAgIGxvYWRDYW52YXMoaW1hZ2VVUkwpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25QYWdlTG9hZDogZnVuY3Rpb24ocGFnZUluZGV4LCBmaWxlbmFtZSwgc2VsZWN0b3IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGV4aXN0cyBmb3IgdGhpcyBwYWdlIGluIGxvY2FsU3RvcmFnZSwgdGhlbiBjaGFuZ2UgaWNvbiBjb2xvclxuICAgICAgICAgICAgICAgIHZhciBzdG9yYWdlS2V5ID0gc2V0dGluZ3MubG9jYWxTdG9yYWdlUHJlZml4ICsgZmlsZW5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkgIT09IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKHNlbGVjdG9yKS5maW5kKCcuZGl2YS1jYW52YXMtaWNvbicpLmFkZENsYXNzKCduZXcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbihkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYmFja2Ryb3AnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aGlzIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYWxsIG9mIHRoZSBuZWNlc3NhcnkgaG9va3MgYW5kIGNhbGxiYWNrc1xuICAgICAgICAvLyBlbWJlZGRlZC5cbiAgICAgICAgcmV0dXJuIHJldHZhbDtcblxuICAgIH0pKCk7XG59KShqUXVlcnkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9wbHVnaW5zL2NhbnZhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuRG93bmxvYWQgcGx1Z2luIGZvciBkaXZhLmpzXG5BbGxvd3MgeW91IHRvIGRvd25sb2FkIGltYWdlcyBzZXJ2ZWQgYnkgSUlQSW1hZ2Ugb3IgSUlJRiBjb21wYXRpYmxlIGltYWdlIHNlcnZlcnNcbiovXG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuKGZ1bmN0aW9uICgkKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgICAgICB2YXIgcmV0dmFsID1cbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGl2YUluc3RhbmNlID0gZGl2YUluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsdWdpbk5hbWU6ICdkb3dubG9hZCcsXG4gICAgICAgICAgICB0aXRsZVRleHQ6ICdEb3dubG9hZCBpbWFnZSBhdCB0aGUgZ2l2ZW4gem9vbSBsZXZlbCcsXG4gICAgICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZXZlbnQsIGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlLCBwYWdlSW5kZXgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSByYXRpb25hbGUgZm9yIC0xIGZyb20gV2lraSAoVExEUiBhbiBvbGQgSUlQIGJ1ZylcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkaXZhSW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2lkdGggLSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gc2V0dGluZ3MuZGl2YUluc3RhbmNlLmdldFBhZ2VJbWFnZVVSTChwYWdlSW5kZXgsIHsgd2lkdGg6IHdpZHRoIH0pO1xuXG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfSkoKTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2pzL3BsdWdpbnMvZG93bmxvYWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbkhpZ2hsaWdodCBwbHVnaW4gZm9yIGRpdmEuanNcbkFsbG93cyB5b3UgdG8gaGlnaGxpZ2h0IHJlZ2lvbnMgb2YgYSBwYWdlIGltYWdlXG4qL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgZWx0ID0gcmVxdWlyZSgnLi4vdXRpbHMvZWx0Jyk7XG52YXIgZGl2YSA9IHJlcXVpcmUoJy4uL2RpdmEnKTtcblxuKGZ1bmN0aW9uICgkKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciByZXR2YWwgPVxuICAgICAgICB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0TWFuYWdlciA9IG5ldyBIaWdobGlnaHRNYW5hZ2VyKGRpdmFJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnBhcmVudE9iamVjdC5kYXRhKCdoaWdobGlnaHRNYW5hZ2VyJywgaGlnaGxpZ2h0TWFuYWdlcik7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEhpZ2hsaWdodDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFJlc2V0IHRoZSBoaWdobGlnaHRzIG9iamVjdCBhbmQgcmVtb3ZlcyBhbGwgaGlnaGxpZ2h0cyBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5yZXNldEhpZ2hsaWdodHMgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRNYW5hZ2VyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFJlc2V0cyB0aGUgaGlnaGxpZ2h0cyBmb3IgYSBzaW5nbGUgcGFnZS5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5yZW1vdmVIaWdobGlnaHRzT25QYWdlID0gZnVuY3Rpb24ocGFnZUlkeClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIucmVtb3ZlSGlnaGxpZ2h0c09uUGFnZShwYWdlSWR4KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSGlnaGxpZ2h0cyByZWdpb25zIG9uIG11bHRpcGxlIHBhZ2VzLlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gcGFnZUlkeHMgQW4gYXJyYXkgb2YgcGFnZSBpbmRleCBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSByZWdpb25zICBBbiBhcnJheSBvZiByZWdpb25zXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBjb2xvdXIgICAob3B0aW9uYWwpIEEgY29sb3VyIGZvciB0aGUgaGlnaGxpZ2h0aW5nLCBzcGVjaWZpZWQgaW4gUkdCQSBDU1MgZm9ybWF0XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlnaGxpZ2h0T25QYWdlcyA9IGZ1bmN0aW9uKHBhZ2VJZHhzLCByZWdpb25zLCBjb2xvdXIsIGRpdkNsYXNzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBwYWdlSWR4cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2UocGFnZUlkeHNbal0sIHJlZ2lvbnNbal0sIGNvbG91ciwgZGl2Q2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEhpZ2hsaWdodHMgcmVnaW9ucyBvbiBhIHBhZ2UuXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBwYWdlSWR4ICBBIHBhZ2UgaW5kZXggbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSByZWdpb25zICBBbiBhcnJheSBvZiByZWdpb25zLiBVc2Ugeyd3aWR0aCc6aSwgJ2hlaWdodCc6aSwgJ3VseCc6aSwgJ3VseSc6IGksICdkaXZJRCc6IHN0cn0gZm9yIGVhY2ggcmVnaW9uLlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gY29sb3VyICAgKG9wdGlvbmFsKSBBIGNvbG91ciBmb3IgdGhlIGhpZ2hsaWdodGluZywgc3BlY2lmaWVkIGluIFJHQkEgQ1NTIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gZGl2Q2xhc3MgKG9wdGlvbmFsKSBBIGNsYXNzIHRvIGlkZW50aWZ5IGEgZ3JvdXAgb2YgaGlnaGxpZ2h0ZWQgcmVnaW9ucyBvbiBhIHNwZWNpZmljIHBhZ2UgYnlcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2UgPSBmdW5jdGlvbihwYWdlSWR4LCByZWdpb25zLCBjb2xvdXIsIGRpdkNsYXNzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG91ciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXIgPSAncmdiYSgyNTUsIDAsIDAsIDAuMiknO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdkNsYXNzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzID0gZGl2YVNldHRpbmdzLklEICsgJ2hpZ2hsaWdodCBkaXZhLWhpZ2hsaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZDbGFzcyA9IGRpdmFTZXR0aW5ncy5JRCArICdoaWdobGlnaHQgZGl2YS1oaWdobGlnaHQgJyArIGRpdkNsYXNzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFuYWdlci5hZGRIaWdobGlnaHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZUlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnM6IHJlZ2lvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6IGNvbG91cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzOiBkaXZDbGFzc1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSnVtcHMgdG8gYSBoaWdobGlnaHQgc29tZXdoZXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIGRpdklEIFRoZSBJRCBvZiB0aGUgZGl2IHRvIGp1bXAgdG8uIFRoaXMgSUQgbXVzdCBiZSBhdHRhY2hlZCB0byB0aGUgZGl2IHVzaW5nIC5oaWdobGlnaHRPblBhZ2UocykgYXMgdGhlIGhpZ2hsaWdodCBtYXkgbm90IGJlIGN1cnJlbnRseSBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9IaWdobGlnaHQgPSBmdW5jdGlvbihkaXZJRClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodEJ5UmVnaW9uSWQoZGl2SUQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ290b0RpdihyZXN1bHQuaGlnaGxpZ2h0LnBhZ2UsIHJlc3VsdC5yZWdpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRpdmEganVzdCB0cmllZCB0byBmaW5kIGEgaGlnaGxpZ2h0IHRoYXQgZG9lc24ndCBleGlzdC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBNb3ZlcyB0aGUgZGl2YSBwYW5lIHRvIChwYWdlKSBhbmQgbWFrZXMgYSBkYXJrZXIgYm9yZGVyIG9uICh0aGlzRGl2KVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGdvdG9EaXYgPSBmdW5jdGlvbihwYWdlLCB0aGlzRGl2KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy9nZXRzIGNlbnRlciBvZiB0aGUgZGl2XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJZT2ZEaXYgPSBwYXJzZUZsb2F0KHRoaXNEaXYudWx5KSArIHBhcnNlRmxvYXQodGhpc0Rpdi5oZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlclhPZkRpdiA9IHBhcnNlRmxvYXQodGhpc0Rpdi51bHgpICsgcGFyc2VGbG9hdCh0aGlzRGl2LndpZHRoKSAvIDI7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2lyZWRZID0gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwoY2VudGVyWU9mRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2lyZWRYID0gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwoY2VudGVyWE9mRGl2KTtcblxuICAgICAgICAgICAgICAgICAgICAvL25hdmlnYXRlcyB0byB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICBwYWdlID0gcGFyc2VJbnQocGFnZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ290b1BhZ2VCeUluZGV4KHBhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRPYmplY3QgPSBkaXZhSW5zdGFuY2UuZ2V0U2V0dGluZ3MoKS52aWV3cG9ydE9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb3AgPSB2aWV3cG9ydE9iamVjdC5zY3JvbGxUb3AoKSArIGRlc2lyZWRZIC0gKHZpZXdwb3J0T2JqZWN0LmhlaWdodCgpIC8gMikgKyBkaXZhU2V0dGluZ3MudmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudExlZnQgPSB2aWV3cG9ydE9iamVjdC5zY3JvbGxMZWZ0KCkgKyBkZXNpcmVkWCAtICh2aWV3cG9ydE9iamVjdC53aWR0aCgpIC8gMikgKyBkaXZhU2V0dGluZ3MuaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2VzIHRoZSBzY3JvbGwgbG9jYXRpb24gdG8gY2VudGVyIG9uIHRoZSBkaXYgYXMgbXVjaCBhcyBpcyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydE9iamVjdC5zY3JvbGxUb3AoY3VycmVudFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoY3VycmVudExlZnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIaWdobGlnaHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb246IHRoaXNEaXYsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMucHVibGlzaChcIlNlbGVjdGVkSGlnaGxpZ2h0Q2hhbmdlZFwiLCBbdGhpc0Rpdi5pZCwgY3VycmVudEhpZ2hsaWdodC5wYWdlXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZWxlY3RzIHRoZSBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ3VycmVudEhpZ2hsaWdodChkaXZhSW5zdGFuY2UsIGN1cnJlbnRIaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0Rpdi5pZDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldERpdkNlbnRlciA9IGZ1bmN0aW9uKHRoaXNEaXYpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCkgcmV0dXJuIGRpdmFJbnN0YW5jZS50cmFuc2xhdGVGcm9tTWF4Wm9vbUxldmVsKHBhcnNlRmxvYXQodGhpc0Rpdi51bHkpICsgcGFyc2VGbG9hdCh0aGlzRGl2LmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwocGFyc2VGbG9hdCh0aGlzRGl2LnVseCkgKyBwYXJzZUZsb2F0KHRoaXNEaXYud2lkdGgpIC8gMik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEp1bXBzIHRvIHRoZSBuZXh0IGhpZ2hsaWdodCBhbG9uZyB0aGUgcHJpbWFyeSBheGlzIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBmaW5kQWRqYWNlbnRIaWdobGlnaHQgPSBmdW5jdGlvbihmb3J3YXJkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlck9mVGFyZ2V0RGl2O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlck9mQ3VycmVudERpdjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQYWdlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uQXJyLCBhcnJJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VEaW1zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyT2ZEaXYsIHRhcmdldERpdjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0RpdjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBGdW5jdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjdXJyZW50SGlnaGxpZ2h0IGRvZXMgbm90IGFscmVhZHkgZXhpc3RzLFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHByZXRlbmQgd2UncmUgc3RhcnRpbmcgYXQgdGhlIG5vcnRod2VzdCBjb3JuZXIgb2YgZGl2YS1pbm5lclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRIaWdobGlnaHQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck9mQ3VycmVudERpdiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZSA9IGN1cnJlbnRIaWdobGlnaHQucGFnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBjZW50ZXIgb2YgdGhlIGN1cnJlbnQgZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJPZkN1cnJlbnREaXYgPSBnZXREaXZDZW50ZXIoY3VycmVudEhpZ2hsaWdodC5yZWdpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBkbyBoYXZlIGEgY3VycmVudCBoaWdobGlnaHQsIHRyeSB0byBmaW5kIHRoZSBuZXh0IG9uZSBpbiB0aGUgc2FtZSBwYWdlXG5cbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uQXJyID0gaGlnaGxpZ2h0TWFuYWdlci5nZXRIaWdobGlnaHRSZWdpb25zKGN1cnJlbnRQYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYXJySW5kZXggPSByZWdpb25BcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwYWdlRGltcyA9IGRpdmFJbnN0YW5jZS5nZXRQYWdlRGltZW5zaW9uc0F0Wm9vbUxldmVsKGN1cnJlbnRQYWdlLCBkaXZhSW5zdGFuY2UuZ2V0Wm9vbUxldmVsKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSB0aGUgY2VudGVyIG9mIHRoZSBkaXYgdG8gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZCkgY2VudGVyT2ZUYXJnZXREaXYgPSAoZGl2YVNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCkgPyBwYWdlRGltcy5oZWlnaHQgOiBwYWdlRGltcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjZW50ZXJPZlRhcmdldERpdiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcEZ1bmN0aW9uID0gZnVuY3Rpb24odGhpc0MsIGN1ckMsIHRhcmdldEMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzQyA+IGN1ckMgJiYgdGhpc0MgPCB0YXJnZXRDKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wRnVuY3Rpb24gPSBmdW5jdGlvbih0aGlzQywgY3VyQywgdGFyZ2V0QylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXNDIDwgY3VyQyAmJiB0aGlzQyA+IHRhcmdldEMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGFyckluZGV4LS0pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEaXYgPSByZWdpb25BcnJbYXJySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyT2ZEaXYgPSBnZXREaXZDZW50ZXIodGhpc0Rpdik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBkaXYgaXMgZmFydGhlciBhbG9uZyB0aGUgbWFpbiBheGlzIGJ1dCBjbG9zZXIgdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcEZ1bmN0aW9uKGNlbnRlck9mRGl2LCBjZW50ZXJPZkN1cnJlbnREaXYsIGNlbnRlck9mVGFyZ2V0RGl2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSB0YXJnZXREaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyT2ZUYXJnZXREaXYgPSBjZW50ZXJPZkRpdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXREaXYgPSB0aGlzRGl2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiBhIGhpZ2hsaWdodCB3YXMgZm91bmQgb24gdGhlIGN1cnJlbnQgcGFnZSB0aGF0IHdhcyBuZXh0OyB0aGlzIGNhbiBnZXQgb3ZlcndyaXR0ZW4gYnV0IHdlJ3JlIHN0aWxsIGdvb2RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodEZvdW5kKSByZXR1cm4gZ290b0RpdihjdXJyZW50UGFnZSwgdGFyZ2V0RGl2KTtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCB3YXNuJ3QgZm91bmQsIGNvbnRpbnVlIG9uLi4uXG5cbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBtaW5pbXVtIGRpdiBvbiB0aGUgbmV4dCBwYWdlIHdpdGggaGlnaGxpZ2h0cyBhbmQgbG9vcCBhcm91bmQgaWYgbmVjZXNzYXJ5XG5cbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBuZXh0IHBhZ2UgaW4gdGhlIHBhZ2VBcnI7IHRoaXMgd2lsbCBiZSBpbiBvcmRlclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZUFyciA9IGhpZ2hsaWdodE1hbmFnZXIuZ2V0SGlnaGxpZ2h0ZWRQYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VySWR4ID0gcGFnZUFyci5pbmRleE9mKGN1cnJlbnRQYWdlLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghdGFyZ2V0UGFnZSB8fCAhZGl2YUluc3RhbmNlLmlzUGFnZUluZGV4VmFsaWQgKHRhcmdldFBhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVmYXVsdCB0byBmaXJzdCBwYWdlLCBtb3ZlIHRvIG5leHQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VySWR4ID09IHBhZ2VBcnIubGVuZ3RoIC0gMSkgdGFyZ2V0UGFnZSA9IHBhZ2VBcnJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0YXJnZXRQYWdlID0gcGFnZUFyclsrK2N1cklkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghdGFyZ2V0UGFnZSB8fCAhZGl2YUluc3RhbmNlLmlzUGFnZUluZGV4VmFsaWQgKHRhcmdldFBhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVmYXVsdCB0byBsYXN0IHBhZ2UsIG1vdmUgdG8gcHJldmlvdXMgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VySWR4ID09PSAwKSB0YXJnZXRQYWdlID0gcGFnZUFycltwYWdlQXJyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGFyZ2V0UGFnZSA9IHBhZ2VBcnJbLS1jdXJJZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9yZXNldCByZWdpb25BcnIgYW5kIGNlbnRlck9mVGFyZ2V0RGl2IGZvciB0aGUgbmV3IHBhZ2Ugd2UncmUgdGVzdGluZ1xuICAgICAgICAgICAgICAgICAgICByZWdpb25BcnIgPSBoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodFJlZ2lvbnModGFyZ2V0UGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIGFyckluZGV4ID0gcmVnaW9uQXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcGFnZURpbXMgPSBkaXZhSW5zdGFuY2UuZ2V0UGFnZURpbWVuc2lvbnNBdFpvb21MZXZlbCh0YXJnZXRQYWdlLCBkaXZhSW5zdGFuY2UuZ2V0TWF4Wm9vbUxldmVsKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGZvcndhcmQpIGNlbnRlck9mVGFyZ2V0RGl2ID0gKGRpdmFTZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQpID8gcGFnZURpbXMuaGVpZ2h0IDogcGFnZURpbXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY2VudGVyT2ZUYXJnZXREaXYgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgbWluaW11bSB0aGlzIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcEZ1bmN0aW9uID0gZnVuY3Rpb24odGhpc0MsIHRhcmdldEMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzQyA8IHRhcmdldEMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBGdW5jdGlvbiA9IGZ1bmN0aW9uKHRoaXNDLCB0YXJnZXRDKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpc0MgPiB0YXJnZXRDKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZShhcnJJbmRleC0tKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRGl2ID0gcmVnaW9uQXJyW2FyckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck9mRGl2ID0gZ2V0RGl2Q2VudGVyKHRoaXNEaXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBGdW5jdGlvbihjZW50ZXJPZkRpdiwgY2VudGVyT2ZUYXJnZXREaXYpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJPZlRhcmdldERpdiA9IGNlbnRlck9mRGl2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldERpdiA9IHRoaXNEaXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL3dlJ3ZlIGZvdW5kIGl0IHRoaXMgdGltZSwgYXMgdGhlcmUnbGwgYmUgYSByZWdpb24gaW4gdGhlIGZ1bGwgcmVnaW9uQXJyIHRvIGJlIHRoZSBtaW5pbXVtXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnb3RvRGl2KHRhcmdldFBhZ2UsIHRhcmdldERpdik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEp1bXBzIHRvIHRoZSBuZXh0IGhpZ2hsaWdodCBhbG9uZyB0aGUgcHJpbWFyeSBheGlzIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5nb3RvTmV4dEhpZ2hsaWdodCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodENvdW50KCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRBZGphY2VudEhpZ2hsaWdodCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBKdW1wcyB0byB0aGUgcHJldmlvdXMgaGlnaGxpZ2h0IGFsb25nIHRoZSBwcmltYXJ5IGF4aXMgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9QcmV2aW91c0hpZ2hsaWdodCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodENvdW50KCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRBZGphY2VudEhpZ2hsaWdodChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJXaWxsVGVybWluYXRlJywgdGhpcy5kZXN0cm95LCBkaXZhU2V0dGluZ3MuSUQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGRpdmFTZXR0aW5ncylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0TWFuYWdlciA9IGRpdmFTZXR0aW5ncy5wYXJlbnRPYmplY3QuZGF0YSgnaGlnaGxpZ2h0TWFuYWdlcicpO1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFyZW50T2JqZWN0LnJlbW92ZURhdGEoJ2hpZ2hsaWdodE1hbmFnZXInKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnaGlnaGxpZ2h0JyxcbiAgICAgICAgICAgIHRpdGxlVGV4dDogJ0hpZ2hsaWdodCByZWdpb25zIG9mIHBhZ2VzJyxcblxuICAgICAgICAgICAgLy8gRXhwb3NlZCBleHBvcnRcbiAgICAgICAgICAgIEhpZ2hsaWdodE1hbmFnZXI6IEhpZ2hsaWdodE1hbmFnZXJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9KSgpO1xufSkoalF1ZXJ5KTtcblxuLyoqIE1hbmFnZXMgdGhlIGFkZGl0aW9uIGFuZCByZW1vdmFsIG9mIHRoZSBwYWdlIG92ZXJsYXlzIHdoaWNoIGRpc3BsYXkgdGhlIGhpZ2hsaWdodHMgKi9cbmZ1bmN0aW9uIEhpZ2hsaWdodE1hbmFnZXIoZGl2YUluc3RhbmNlLCBnZXRDdXJyZW50SGlnaGxpZ2h0KVxue1xuICAgIHRoaXMuX2RpdmFJbnN0YW5jZSA9IGRpdmFJbnN0YW5jZTtcbiAgICB0aGlzLl9vdmVybGF5cyA9IHt9O1xuICAgIHRoaXMuX2dldEN1cnJlbnRIaWdobGlnaHQgPSBnZXRDdXJyZW50SGlnaGxpZ2h0O1xufVxuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5nZXRIaWdobGlnaHRDb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9vdmVybGF5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgY291bnQgKz0gdGhpcy5fb3ZlcmxheXNba2V5XS5oaWdobGlnaHQucmVnaW9ucy5sZW5ndGg7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gY291bnQ7XG59O1xuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5nZXRIaWdobGlnaHRSZWdpb25zID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbntcbiAgICBpZiAoIXRoaXMuX292ZXJsYXlzW3BhZ2VJbmRleF0pXG4gICAgICAgIHJldHVybiBbXTtcblxuICAgIHJldHVybiB0aGlzLl9vdmVybGF5c1twYWdlSW5kZXhdLmhpZ2hsaWdodC5yZWdpb25zO1xufTtcblxuSGlnaGxpZ2h0TWFuYWdlci5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0ZWRQYWdlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gRklYTUU6IENvbmNlcHR1YWxseSBhd2t3YXJkIHRoYXQgdGhlc2UgYXJlIHN0cmluZ3NcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fb3ZlcmxheXMpO1xufTtcblxuSGlnaGxpZ2h0TWFuYWdlci5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0QnlSZWdpb25JZCA9IGZ1bmN0aW9uIChpZClcbntcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX292ZXJsYXlzKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShpKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciByZWdpb25zID0gdGhpcy5fb3ZlcmxheXNbaV0uaGlnaGxpZ2h0LnJlZ2lvbnM7XG4gICAgICAgIGZvciAodmFyIGogaW4gcmVnaW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFyZWdpb25zLmhhc093blByb3BlcnR5KGopKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAocmVnaW9uc1tqXS5kaXZJRCA9PT0gaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0OiB0aGlzLl9vdmVybGF5c1tpXS5oaWdobGlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uc1tqXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkhpZ2hsaWdodE1hbmFnZXIucHJvdG90eXBlLmFkZEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChoaWdobGlnaHQpXG57XG4gICAgdmFyIGV4aXN0aW5nT3ZlcmxheSA9IHRoaXMuX292ZXJsYXlzW2hpZ2hsaWdodC5wYWdlXTtcblxuICAgIGlmIChleGlzdGluZ092ZXJsYXkpXG4gICAgICAgIHRoaXMuX2RpdmFJbnN0YW5jZS5fX3JlbW92ZVBhZ2VPdmVybGF5KGV4aXN0aW5nT3ZlcmxheSk7XG5cbiAgICB2YXIgb3ZlcmxheSA9IG5ldyBIaWdobGlnaHRQYWdlT3ZlcmxheShoaWdobGlnaHQsIHRoaXMuX2RpdmFJbnN0YW5jZSwgdGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodCk7XG4gICAgdGhpcy5fb3ZlcmxheXNbaGlnaGxpZ2h0LnBhZ2VdID0gb3ZlcmxheTtcbiAgICB0aGlzLl9kaXZhSW5zdGFuY2UuX19hZGRQYWdlT3ZlcmxheShvdmVybGF5KTtcbn07XG5cbkhpZ2hsaWdodE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUhpZ2hsaWdodHNPblBhZ2UgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxue1xuICAgIGlmICghdGhpcy5fb3ZlcmxheXNbcGFnZUluZGV4XSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5fZGl2YUluc3RhbmNlLl9fcmVtb3ZlUGFnZU92ZXJsYXkodGhpcy5fb3ZlcmxheXNbcGFnZUluZGV4XSk7XG4gICAgZGVsZXRlIHRoaXMuX292ZXJsYXlzW3BhZ2VJbmRleF07XG59O1xuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9vdmVybGF5cylcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheXMuaGFzT3duUHJvcGVydHkoaSkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB0aGlzLl9kaXZhSW5zdGFuY2UuX19yZW1vdmVQYWdlT3ZlcmxheSh0aGlzLl9vdmVybGF5c1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3ZlcmxheXMgPSB7fTtcbn07XG5cbi8qKlxuIFdoZW4gYSBuZXcgcGFnZSBpcyBsb2FkZWQsIHRoaXMgb3ZlcmxheSB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuIHBhZ2UgaW5kZXggZm9yIHRoZSBwYWdlLiBJdCBsb29rcyBhdCB0aGUgJ2hpZ2hsaWdodHMnIGRhdGEgb2JqZWN0XG4gc2V0IG9uIHRoZSBkaXZhIHBhcmVudCBlbGVtZW50LCBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gaGlnaGxpZ2h0cyBleGlzdCBmb3IgdGhhdCBwYWdlLlxuXG4gSWYgc28sIHRoZSBvdmVybGF5IHdpbGwgY3JlYXRlIGFuZCByZW5kZXIgZWxlbWVudHMgZm9yIGV2ZXJ5XG4gaGlnaGxpZ2h0ZWQgYm94LlxuXG4gQHBhcmFtIGhpZ2hsaWdodFxuIEBwYXJhbSBkaXZhSW5zdGFuY2VcbiBAcGFyYW0gZ2V0Q3VycmVudEhpZ2hsaWdodCAob3B0aW9uYWwpXG4gKi9cbmZ1bmN0aW9uIEhpZ2hsaWdodFBhZ2VPdmVybGF5KGhpZ2hsaWdodCwgZGl2YUluc3RhbmNlLCBnZXRDdXJyZW50SGlnaGxpZ2h0KVxue1xuICAgIHRoaXMucGFnZSA9IGhpZ2hsaWdodC5wYWdlO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgIHRoaXMuX2hpZ2hsaWdodFJlZ2lvbnMgPSBbXTtcbiAgICB0aGlzLl9kaXZhSW5zdGFuY2UgPSBkaXZhSW5zdGFuY2U7XG4gICAgdGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodCA9IGdldEN1cnJlbnRIaWdobGlnaHQ7XG59XG5cbkhpZ2hsaWdodFBhZ2VPdmVybGF5LnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGRpdmFTZXR0aW5ncyA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRTZXR0aW5ncygpO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IHRoaXMuaGlnaGxpZ2h0O1xuICAgIHZhciByZWdpb25zID0gaGlnaGxpZ2h0LnJlZ2lvbnM7XG4gICAgdmFyIGNvbG91ciA9IGhpZ2hsaWdodC5jb2xvdXI7XG4gICAgdmFyIGRpdkNsYXNzID0gaGlnaGxpZ2h0LmRpdkNsYXNzO1xuXG4gICAgdmFyIGogPSByZWdpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoai0tKVxuICAgIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbnNbal07XG5cbiAgICAgICAgLy8gRklYTUU6IFVzZSBDU1MgY2xhc3MgaW5zdGVhZCBvZiBpbmxpbmUgc3R5bGVcbiAgICAgICAgdmFyIGJveCA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgY2xhc3M6IGRpdkNsYXNzLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvdXIsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjNTU1XCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVnaW9uLmRpdklEICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaGlnaGxpZ2h0LWlkJywgcmVnaW9uLmRpdklEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZWQgYnkgSUlJRkhpZ2hsaWdodFxuICAgICAgICBpZiAocmVnaW9uLm5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJywgcmVnaW9uLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGlnaGxpZ2h0UmVnaW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGJveCxcbiAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdGhpcy5faGlnaGxpZ2h0UmVnaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChoaWdobGlnaHQpXG4gICAge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGhpZ2hsaWdodC5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIGRpdmFTZXR0aW5ncy5pbm5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZyk7XG5cbiAgICBpZiAodGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodClcbiAgICAgICAgdXBkYXRlQ3VycmVudEhpZ2hsaWdodCh0aGlzLl9kaXZhSW5zdGFuY2UsIHRoaXMuX2dldEN1cnJlbnRIaWdobGlnaHQoKSk7XG5cbiAgICBkaXZhLkV2ZW50cy5wdWJsaXNoKFwiSGlnaGxpZ2h0Q29tcGxldGVkXCIsIFt0aGlzLnBhZ2UsIHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRGaWxlbmFtZXMoKVt0aGlzLnBhZ2VdXSk7XG59O1xuXG5IaWdobGlnaHRQYWdlT3ZlcmxheS5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGlubmVyRWxlbWVudCA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRTZXR0aW5ncygpLmlubmVyRWxlbWVudDtcblxuICAgIHRoaXMuX2hpZ2hsaWdodFJlZ2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaGlnaGxpZ2h0KVxuICAgIHtcbiAgICAgICAgaW5uZXJFbGVtZW50LnJlbW92ZUNoaWxkKGhpZ2hsaWdodC5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2hpZ2hsaWdodFJlZ2lvbnMgPSBbXTtcbn07XG5cbi8vIEZJWE1FOiBVcGRhdGluZyBhIGJveCBwZXIgaGlnaGxpZ2h0IHJlZ2lvbiBtaWdodCBiZSB0b28gZXhwZW5zaXZlXG4vLyBNYXliZSBzdGljayBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY29udGFpbmVyIGFuZCB0aGVuIHNjYWxlIGl0IHVzaW5nIENTUyB0cmFuc2Zvcm1zP1xuSGlnaGxpZ2h0UGFnZU92ZXJsYXkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBtYXhab29tID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldE1heFpvb21MZXZlbCgpO1xuXG4gICAgdmFyIG1heFpvb21XaWR0aCA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRQYWdlRGltZW5zaW9uc0F0Wm9vbUxldmVsKHRoaXMucGFnZSwgbWF4Wm9vbSkud2lkdGg7XG4gICAgdmFyIGN1cnJlbnRXaWR0aCA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRQYWdlRGltZW5zaW9ucyh0aGlzLnBhZ2UpLndpZHRoO1xuICAgIHZhciB6b29tRGlmZmVyZW5jZSA9IE1hdGgubG9nKG1heFpvb21XaWR0aCAvIGN1cnJlbnRXaWR0aCkgLyBNYXRoLmxvZygyKTtcblxuICAgIHZhciBwYWdlT2Zmc2V0ID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldFBhZ2VPZmZzZXQodGhpcy5wYWdlLCB7XG4gICAgICAgIGV4Y2x1ZGVQYWRkaW5nOiB0cnVlLFxuICAgICAgICBpbmNvcnBvcmF0ZVZpZXdwb3J0OiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLl9oaWdobGlnaHRSZWdpb25zLmZvckVhY2goZnVuY3Rpb24gKGhpZ2hsaWdodClcbiAgICB7XG4gICAgICAgIHZhciByZWdpb24gPSBoaWdobGlnaHQucmVnaW9uO1xuXG4gICAgICAgIGVsdC5zZXRBdHRyaWJ1dGVzKGhpZ2hsaWdodC5lbGVtZW50LCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBpbmNvcnBvcmF0ZVpvb20ocmVnaW9uLndpZHRoLCB6b29tRGlmZmVyZW5jZSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpbmNvcnBvcmF0ZVpvb20ocmVnaW9uLmhlaWdodCwgem9vbURpZmZlcmVuY2UpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIHRvcDogcGFnZU9mZnNldC50b3AgKyBpbmNvcnBvcmF0ZVpvb20ocmVnaW9uLnVseSwgem9vbURpZmZlcmVuY2UpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBhZ2VPZmZzZXQubGVmdCArIGluY29ycG9yYXRlWm9vbShyZWdpb24udWx4LCB6b29tRGlmZmVyZW5jZSkgKyBcInB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBpbmNvcnBvcmF0ZVpvb20ocG9zaXRpb24sIHpvb21EaWZmZXJlbmNlKVxue1xuICAgIHJldHVybiBwb3NpdGlvbiAvIE1hdGgucG93KDIsIHpvb21EaWZmZXJlbmNlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3VycmVudEhpZ2hsaWdodChkaXZhSW5zdGFuY2UsIGN1cnJlbnRIaWdobGlnaHQpXG57XG4gICAgdmFyIGNsYXNzU3RyaW5nID0gZGl2YUluc3RhbmNlLmdldEluc3RhbmNlSWQoKSArIFwic2VsZWN0ZWQtaGlnaGxpZ2h0XCI7XG4gICAgdmFyIGNsYXNzRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NTdHJpbmcpO1xuICAgIHZhciBpZHg7XG4gICAgdmFyIGJveDtcbiAgICB2YXIgYm94ZXM7XG5cbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGNsYXNzRWxlbS5sZW5ndGg7IGlkeCsrKVxuICAgIHtcbiAgICAgICAgYm94ID0gY2xhc3NFbGVtW2lkeF07XG4gICAgICAgIGlmIChib3guaWQgIT09IGN1cnJlbnRIaWdobGlnaHQuaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJveC5jbGFzc05hbWUgPSBib3guY2xhc3NOYW1lLnJlcGxhY2UoJyAnK2NsYXNzU3RyaW5nLCAnJyk7XG4gICAgICAgICAgICBib3guc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgIzU1NVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpdmFJbnN0YW5jZS5pc1BhZ2VJblZpZXdwb3J0KGN1cnJlbnRIaWdobGlnaHQucGFnZSkpXG4gICAge1xuICAgICAgICBib3hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2RhdGEtaGlnaGxpZ2h0LWlkPVwiICsgY3VycmVudEhpZ2hsaWdodC5pZCArIFwiXVwiKTtcbiAgICAgICAgZm9yKGlkeCA9IDA7IGlkeCA8IGJveGVzLmxlbmd0aDsgaWR4KyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJveCA9IGJveGVzW2lkeF07XG4gICAgICAgICAgICBib3guY2xhc3NOYW1lID0gYm94LmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NTdHJpbmc7XG4gICAgICAgICAgICBib3guc3R5bGUuYm9yZGVyID0gXCIycHggc29saWQgIzAwMFwiO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9wbHVnaW5zL2hpZ2hsaWdodC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuSUlJRiBIaWdobGlnaHQgcGx1Z2luIGZvciBkaXZhLmpzXG5BbGxvd3MgeW91IHRvIGhpZ2hsaWdodCByZWdpb25zIG9mIGEgcGFnZSBpbWFnZSBiYXNlZCBvZmYgb2YgYW5ub3RhdGlvbnMgaW4gYSBJSUlGIE1hbmlmZXN0XG4qL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgZGl2YSA9IHJlcXVpcmUoJy4uL2RpdmEnKTtcbnZhciBIaWdobGlnaHRNYW5hZ2VyID0gcmVxdWlyZSgnLi9oaWdobGlnaHQnKS5IaWdobGlnaHRNYW5hZ2VyO1xuXG4oZnVuY3Rpb24gKCQpXG57XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge307XG4gICAgICAgIHZhciByZXR2YWwgPVxuICAgICAgICB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0TWFuYWdlciA9IG5ldyBIaWdobGlnaHRNYW5hZ2VyKGRpdmFJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnBhcmVudE9iamVjdC5kYXRhKCdoaWdobGlnaHRNYW5hZ2VyJywgaGlnaGxpZ2h0TWFuYWdlcik7XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5oaWdobGlnaHRlZFBhZ2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBSZXNldCB0aGUgaGlnaGxpZ2h0cyBvYmplY3QgYW5kIHJlbW92ZXMgYWxsIGhpZ2hsaWdodHMgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UucmVzZXRIaWdobGlnaHRzID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFuYWdlci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBSZXNldHMgdGhlIGhpZ2hsaWdodHMgZm9yIGEgc2luZ2xlIHBhZ2UuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UucmVtb3ZlSGlnaGxpZ2h0c09uUGFnZSA9IGZ1bmN0aW9uKHBhZ2VJZHgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRNYW5hZ2VyLnJlbW92ZUhpZ2hsaWdodHNPblBhZ2UocGFnZUlkeCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWRlSGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhpZ2hsaWdodHNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLmlubmVyRWxlbWVudCkuYWRkQ2xhc3MoJ2Fubm90YXRpb25zLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2Uuc2hvd0hpZ2hsaWdodHMgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oaWdobGlnaHRzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLmlubmVyRWxlbWVudCkucmVtb3ZlQ2xhc3MoJ2Fubm90YXRpb25zLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBIaWdobGlnaHRzIHJlZ2lvbnMgb24gbXVsdGlwbGUgcGFnZXMuXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBwYWdlSWR4cyBBbiBhcnJheSBvZiBwYWdlIGluZGV4IG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIHJlZ2lvbnMgIEFuIGFycmF5IG9mIHJlZ2lvbnNcbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIGNvbG91ciAgIChvcHRpb25hbCkgQSBjb2xvdXIgZm9yIHRoZSBoaWdobGlnaHRpbmcsIHNwZWNpZmllZCBpbiBSR0JBIENTUyBmb3JtYXRcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2VzID0gZnVuY3Rpb24ocGFnZUlkeHMsIHJlZ2lvbnMsIGNvbG91ciwgZGl2Q2xhc3MpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IHBhZ2VJZHhzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGotLSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZ2hsaWdodE9uUGFnZShwYWdlSWR4c1tqXSwgcmVnaW9uc1tqXSwgY29sb3VyLCBkaXZDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSGlnaGxpZ2h0cyByZWdpb25zIG9uIGEgcGFnZS5cbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIHBhZ2VJZHggIEEgcGFnZSBpbmRleCBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIHJlZ2lvbnMgIEFuIGFycmF5IG9mIHJlZ2lvbnMuIFVzZSB7J3dpZHRoJzppLCAnaGVpZ2h0JzppLCAndWx4JzppLCAndWx5JzogaSwgJ2RpdklEJzogc3RyfSBmb3IgZWFjaCByZWdpb24uXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBjb2xvdXIgICAob3B0aW9uYWwpIEEgY29sb3VyIGZvciB0aGUgaGlnaGxpZ2h0aW5nLCBzcGVjaWZpZWQgaW4gUkdCQSBDU1MgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBkaXZDbGFzcyAob3B0aW9uYWwpIEEgY2xhc3MgdG8gaWRlbnRpZnkgYSBncm91cCBvZiBoaWdobGlnaHRlZCByZWdpb25zIG9uIGEgc3BlY2lmaWMgcGFnZSBieVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZ2hsaWdodE9uUGFnZSA9IGZ1bmN0aW9uKHBhZ2VJZHgsIHJlZ2lvbnMsIGNvbG91ciwgZGl2Q2xhc3MpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3VyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91ciA9ICdyZ2JhKDI1NSwgMCwgMCwgMC4yKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2Q2xhc3MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2Q2xhc3MgPSBkaXZhU2V0dGluZ3MuSUQgKyAnaGlnaGxpZ2h0IGRpdmEtaGlnaGxpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzID0gZGl2YVNldHRpbmdzLklEICsgJ2hpZ2hsaWdodCBkaXZhLWhpZ2hsaWdodCAnICsgZGl2Q2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRNYW5hZ2VyLmFkZEhpZ2hsaWdodCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlSWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uczogcmVnaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogY29sb3VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2Q2xhc3M6IGRpdkNsYXNzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSnVtcHMgdG8gYSBoaWdobGlnaHQgc29tZXdoZXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIGRpdklEIFRoZSBJRCBvZiB0aGUgZGl2IHRvIGp1bXAgdG8uIFRoaXMgSUQgbXVzdCBiZSBhdHRhY2hlZCB0byB0aGUgZGl2IHVzaW5nIC5oaWdobGlnaHRPblBhZ2UocykgYXMgdGhlIGhpZ2hsaWdodCBtYXkgbm90IGJlIGFwcGVuZGVkIHRvIHRoZSBET00uXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ290b0hpZ2hsaWdodCA9IGZ1bmN0aW9uKGRpdklEKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhpZ2hsaWdodE1hbmFnZXIuZ2V0SGlnaGxpZ2h0QnlSZWdpb25JZChkaXZJRCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnb3RvRGl2KHJlc3VsdC5oaWdobGlnaHQucGFnZSwgcmVzdWx0LnJlZ2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGl2YSBqdXN0IHRyaWVkIHRvIGZpbmQgYSBoaWdobGlnaHQgdGhhdCBkb2Vzbid0IGV4aXN0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBNb3ZlcyB0aGUgZGl2YSBwYW5lIHRvIChwYWdlKVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBnb3RvRGl2ID0gZnVuY3Rpb24ocGFnZSwgdGhpc0RpdilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0cyBjZW50ZXIgb2YgdGhlIGRpdlxuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyWU9mRGl2ID0gcGFyc2VGbG9hdCh0aGlzRGl2LnVseSkgKyBwYXJzZUZsb2F0KHRoaXNEaXYuaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJYT2ZEaXYgPSBwYXJzZUZsb2F0KHRoaXNEaXYudWx4KSArIHBhcnNlRmxvYXQodGhpc0Rpdi53aWR0aCkgLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNpcmVkWSA9IGRpdmFJbnN0YW5jZS50cmFuc2xhdGVGcm9tTWF4Wm9vbUxldmVsKGNlbnRlcllPZkRpdik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNpcmVkWCA9IGRpdmFJbnN0YW5jZS50cmFuc2xhdGVGcm9tTWF4Wm9vbUxldmVsKGNlbnRlclhPZkRpdik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9uYXZpZ2F0ZXMgdG8gdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgcGFnZSA9IHBhcnNlSW50KHBhZ2UsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9QYWdlQnlJbmRleChwYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0T2JqZWN0ID0gZGl2YUluc3RhbmNlLmdldFNldHRpbmdzKCkudmlld3BvcnRPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VG9wID0gdmlld3BvcnRPYmplY3Quc2Nyb2xsVG9wKCkgKyBkZXNpcmVkWSAtICh2aWV3cG9ydE9iamVjdC5oZWlnaHQoKSAvIDIpICsgZGl2YVNldHRpbmdzLnZlcnRpY2FsUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRMZWZ0ID0gdmlld3BvcnRPYmplY3Quc2Nyb2xsTGVmdCgpICsgZGVzaXJlZFggLSAodmlld3BvcnRPYmplY3Qud2lkdGgoKSAvIDIpICsgZGl2YVNldHRpbmdzLmhvcml6b250YWxQYWRkaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hhbmdlcyB0aGUgc2Nyb2xsIGxvY2F0aW9uIHRvIGNlbnRlciBvbiB0aGUgZGl2IGFzIG11Y2ggYXMgaXMgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRPYmplY3Quc2Nyb2xsVG9wKGN1cnJlbnRUb3ApO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydE9iamVjdC5zY3JvbGxMZWZ0KGN1cnJlbnRMZWZ0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHNob3dBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKGNhbnZhc0luZGV4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywganFYSFIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNBbm5vdGF0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQW5ub3RhdGlvbnMgPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IGFubm90YXRpb25zIGluIGFubm90YXRpb25zIG9iamVjdCB0byBkaXZhIGhpZ2hsaWdodCBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9ucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvb3Agb3ZlciBhbm5vdGF0aW9ucyBpbiBhIHNpbmdsZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbnVtQW5ub3RhdGlvbnM7IGsrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEFubm90YXRpb24gPSBjYW52YXNBbm5vdGF0aW9uc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGV4dCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBjdXJyZW50QW5ub3RhdGlvbi5yZXNvdXJjZS5jaGFycztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB4LHksdyxoIChzbGljZSBzdHJpbmcgZnJvbSAnI3h5d2g9JyB0byBlbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uU3RyaW5nID0gY3VycmVudEFubm90YXRpb24ub247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkU3RyaW5nID0gb25TdHJpbmcuc2xpY2Uob25TdHJpbmcuaW5kZXhPZignI3h5d2g9JykgKyA2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBjb29yZFN0cmluZy5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWx4OiBwYXJzZUludChjb29yZGluYXRlc1swXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bHk6IHBhcnNlSW50KGNvb3JkaW5hdGVzWzFdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUludChjb29yZGluYXRlc1syXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGNvb3JkaW5hdGVzWzNdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9ucy5wdXNoKHJlZ2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2UoY2FudmFzSW5kZXgsIHJlZ2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9mbGFnIHRoaXMgcGFnZSdzIGFubm90YXRpb25zIGFzIGhhdmluZyBiZWVuIHJldHJpZXZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlnaGxpZ2h0ZWRQYWdlcy5wdXNoKGNhbnZhc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldEFubm90YXRpb25zTGlzdCA9IGZ1bmN0aW9uKHBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgcGFnZSBoYXMgYW5ub3RhdGlvbkxpc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhc2VzID0gc2V0dGluZ3MubWFuaWZlc3Quc2VxdWVuY2VzWzBdLmNhbnZhc2VzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXNlc1twYWdlSW5kZXhdLmhhc093blByb3BlcnR5KCdvdGhlckNvbnRlbnQnKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyQ29udGVudCA9IGNhbnZhc2VzW3BhZ2VJbmRleF0ub3RoZXJDb250ZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyQ29udGVudC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDb250ZW50W2pdWydAdHlwZSddID09PSAnc2M6QW5ub3RhdGlvbkxpc3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FudmFzIGhhcyBhbm5vdGF0aW9ucy4gZ2V0IHRoZSBhbm5vdGF0aW9uczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogb3RoZXJDb250ZW50W2pdWydAaWQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHNob3dBbm5vdGF0aW9ucyhwYWdlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgc2V0TWFuaWZlc3QgPSBmdW5jdGlvbihtYW5pZmVzdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnTWFuaWZlc3REaWRMb2FkJywgc2V0TWFuaWZlc3QsIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1BhZ2VXaWxsTG9hZCcsIGZ1bmN0aW9uKHBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaGlnaGxpZ2h0c1Zpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaGlnaGxpZ2h0cyBmb3IgdGhpcyBwYWdlIGhhdmUgYWxyZWFkeSBiZWVuIGNoZWNrZWQvbG9hZGVkLCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXR0aW5ncy5oaWdobGlnaHRlZFBhZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaGlnaGxpZ2h0ZWRQYWdlc1tpXSA9PT0gcGFnZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGdldEFubm90YXRpb25zTGlzdChwYWdlSW5kZXgsIHNldHRpbmdzLm1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB9LCBkaXZhU2V0dGluZ3MuSUQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZU92ZXJsYXlzID0gW107XG5cbiAgICAgICAgICAgICAgICAvL29uIG1vdXNlb3Zlciwgc2hvdyB0aGUgYW5ub3RhdGlvbiB0ZXh0XG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmlubmVyT2JqZWN0Lm9uKCdtb3VzZWVudGVyJywgJy4nICsgZGl2YVNldHRpbmdzLklEICsgJ2hpZ2hsaWdodCcsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBhbm5vdGF0aW9uRWxlbWVudC5kYXRhc2V0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0T3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnN0eWxlLnRvcCA9IChhbm5vdGF0aW9uRWxlbWVudC5vZmZzZXRUb3AgKyBhbm5vdGF0aW9uRWxlbWVudC5vZmZzZXRIZWlnaHQgLSAxKSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnN0eWxlLmxlZnQgPSBhbm5vdGF0aW9uRWxlbWVudC5zdHlsZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5zdHlsZS5iYWNrZ3JvdW5kID0gJyNmZmYnO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICM1NTUnO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnN0eWxlLnpJbmRleCA9IDEwMTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkuY2xhc3NOYW1lID0gJ2Fubm90YXRpb24tb3ZlcmxheSc7XG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnRleHRDb250ZW50ID0gbmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uRWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRleHRPdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlT3ZlcmxheXMucHVzaCh0ZXh0T3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuaW5uZXJPYmplY3Qub24oJ21vdXNlbGVhdmUnLCAnLicgKyBkaXZhU2V0dGluZ3MuSUQgKyAnaGlnaGxpZ2h0JywgZnVuY3Rpb24oZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhY3RpdmVPdmVybGF5cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0T3ZlcmxheSA9IGFjdGl2ZU92ZXJsYXlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXh0T3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkTG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIC8vYnV0dG9uIHRvIHRvZ2dsZSBhbm5vdGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAkKCcjJyArIGRpdmFTZXR0aW5ncy5JRCArICdwYWdlLW5hdicpLmJlZm9yZSgnPGRpdiBpZD1cIicgKyBkaXZhU2V0dGluZ3MuSUQgKyAnYW5ub3RhdGlvbnMtaWNvblwiIGNsYXNzPVwiZGl2YS1idXR0b24gZGl2YS1hbm5vdGF0aW9ucy1pY29uXCIgdGl0bGU9XCJUdXJuIGFubm90YXRpb25zIG9uIG9yIG9mZlwiPjwvZGl2PicpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLnNlbGVjdG9yICsgJ2Fubm90YXRpb25zLWljb24nKS5hZGRDbGFzcygnYW5ub3RhdGlvbnMtaWNvbi1hY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgICAgICAkKCcjJyArIGRpdmFTZXR0aW5ncy5JRCArICdhbm5vdGF0aW9ucy1pY29uJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2dnbGUgdmlzaWJpbGl0eSBvZiBhbm5vdGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhpZ2hsaWdodHNWaXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWRlSGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLnNlbGVjdG9yICsgJ2Fubm90YXRpb25zLWljb24nKS5yZW1vdmVDbGFzcygnYW5ub3RhdGlvbnMtaWNvbi1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2Uuc2hvd0hpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICdhbm5vdGF0aW9ucy1pY29uJykuYWRkQ2xhc3MoJ2Fubm90YXRpb25zLWljb24tYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICAvL2VuYWJsZSBhbm5vdGF0aW9ucyBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlnaGxpZ2h0c1Zpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5wYXJlbnRPYmplY3QucmVtb3ZlRGF0YSgnaGlnaGxpZ2h0cycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsdWdpbk5hbWU6ICdJSUlGSGlnaGxpZ2h0JyxcbiAgICAgICAgICAgIHRpdGxlVGV4dDogJ0hpZ2hsaWdodCByZWdpb25zIG9mIHBhZ2VzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH0pKCk7XG59KShqUXVlcnkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtaGlnaGxpZ2h0LmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIElJSUYgTWV0YWRhdGEgcGx1Z2luIGZvciBkaXZhLmpzXG4vLyBEaXNwbGF5cyBvYmplY3QgbWV0YWRhdGEgZnJvbSBhIElJSUYgbWFuaWZlc3RcblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIGRpdmEgPSByZXF1aXJlKCcuLi9kaXZhJyk7XG5cbihmdW5jdGlvbiAoJClcbntcbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgcmV0dmFsID1cbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9kaXNwbGF5TWV0YWRhdGEgPSBmdW5jdGlvbihtYW5pZmVzdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG93TWV0YWRhdGEgPSBmdW5jdGlvbihsYWJlbCwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFByb3BlciA9IGxhYmVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbGFiZWwuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxGb3JtYXR0ZWQgPSBsYWJlbFByb3Blci5yZXBsYWNlKCdfJywgJyAnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzxhIGhyZWY9XCInICsgdmFsdWUgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JyArIHZhbHVlICsgJzwvYT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJtZXRhZGF0YS1yb3dcIj48c3BhbiBjbGFzcz1cIm1ldGFkYXRhLWxhYmVsXCI+JyArIGxhYmVsRm9ybWF0dGVkICsgJzo8L3NwYW4+IDxzcGFuIGNsYXNzPVwibWV0YWRhdGEtdmFsdWVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgKyAnPC9zcGFuPjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldERhdGFGb3JMYW5ndWFnZSA9IGZ1bmN0aW9uKGRhdGEsIGxhbmd1YWdlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaV1bJ0BsYW5ndWFnZSddID09PSBsYW5ndWFnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2ldWydAdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFNob3dzIG1ldGFkYXRhIGZyb20gbGFiZWwgbmFtZXMgKGlmIHRoZSBtZXRhZGF0YSBleGlzdHMpLlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbmFtZXMge0FycmF5fSAtIEFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIGZpZWxkIG5hbWVzIHRvIGRpc3BsYXkuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvd01ldGFkYXRhRnJvbUxhYmVsTmFtZXMgPSBmdW5jdGlvbihuYW1lcylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gbmFtZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFuaWZlc3QuaGFzT3duUHJvcGVydHkoZmllbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmlmZXN0W2ZpZWxkXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbXVsdGlwbGUgbGFuZ3VhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxpemVkRGF0YSA9IGdldERhdGFGb3JMYW5ndWFnZShtYW5pZmVzdFtmaWVsZF0sICdlbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgKz0gc2hvd01ldGFkYXRhKGZpZWxkLCBsb2NhbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzICs9IHNob3dNZXRhZGF0YShmaWVsZCwgbWFuaWZlc3RbZmllbGRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YUVsZW1lbnQgPSAnPGRpdiBpZD1cIicgKyBkaXZhU2V0dGluZ3MuSUQgKyAnbWV0YWRhdGFcIiBjbGFzcz1cImRpdmEtbW9kYWxcIj4nO1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVsZW1lbnQgKz0gc2hvd01ldGFkYXRhRnJvbUxhYmVsTmFtZXMoWydsYWJlbCddKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWFuaWZlc3QuaGFzT3duUHJvcGVydHkoJ21ldGFkYXRhJykpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YUZpZWxkID0gbWFuaWZlc3QubWV0YWRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YWRhdGFGaWVsZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFGaWVsZFtpXS52YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2Fub25pY2FsRGF0YSA9IGdldERhdGFGb3JMYW5ndWFnZShtZXRhZGF0YUZpZWxkW2ldLnZhbHVlLCAnZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFFbGVtZW50ICs9IHNob3dNZXRhZGF0YShtZXRhZGF0YUZpZWxkW2ldLmxhYmVsLCBjYW5vbmljYWxEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFFbGVtZW50ICs9IHNob3dNZXRhZGF0YShtZXRhZGF0YUZpZWxkW2ldLmxhYmVsLCBtZXRhZGF0YUZpZWxkW2ldLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVsZW1lbnQgKz0gc2hvd01ldGFkYXRhRnJvbUxhYmVsTmFtZXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlZV9hbHNvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaWNlbnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdHRyaWJ1dGlvbidcbiAgICAgICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFFbGVtZW50ICs9ICc8L2Rpdj4nO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5wYXJlbnRPYmplY3QucHJlcGVuZChtZXRhZGF0YUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICdtZXRhZGF0YScpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy9zdWJzY3JpYmUgdG8gTWFuaWZlc3REaWRMb2FkIGV2ZW50LCBnZXQgdGhlIG1hbmlmZXN0XG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdNYW5pZmVzdERpZExvYWQnLCBfZGlzcGxheU1ldGFkYXRhLCBkaXZhU2V0dGluZ3MuSUQpO1xuXG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnBhcmVudE9iamVjdC5wcmVwZW5kKCc8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBjbGVhcjogYm90aFwiPjxhIGhyZWY9XCIjXCIgaWQ9XCInICsgZGl2YVNldHRpbmdzLklEICsgJ21ldGFkYXRhLWxpbmtcIiBjbGFzcz1cImRpdmEtbWV0YWRhdGEtbGlua1wiPkRldGFpbHM8L2E+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgLy8gJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAndGl0bGUnKS5hcHBlbmQoJzxkaXY+PGEgaHJlZj1cIiNcIiBpZD1cIicgKyBkaXZhU2V0dGluZ3MuSUQgKyAnbWV0YWRhdGEtbGlua1wiIGNsYXNzPVwiZGl2YS1tZXRhZGF0YS1saW5rXCI+RGV0YWlsczwvYT48L2Rpdj4nKTtcblxuICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLnNlbGVjdG9yICsgJ21ldGFkYXRhLWxpbmsnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAnbWV0YWRhdGEnKS5mYWRlVG9nZ2xlKCdmYXN0Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ0lJSUZNZXRhZGF0YScsXG4gICAgICAgICAgICB0aXRsZVRleHQ6ICdTaG93IG1ldGFkYXRhIGZyb20gYSBJSUlGIG1hbmlmZXN0J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH0pKCk7XG59KShqUXVlcnkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbkRpdmEuSlMgcGFnZWFsaWFzIHBsdWdpblxuQXV0aG9yOiBBbmRyZXcgSG9yd2l0elxuXG5MZXRzIHBhZ2VzIGJlIHNldCB1cCB3aXRoIGN1c3RvbSBhbGlhc2VzIHRvIGFsbG93IGZvciBzZWN0aW9ucyB3aXRoIGRpZmZlcmVudCBcbm51bWJlcmluZyBzY2hlbWFzLlxuXG5EaXZhIG5lZWRzIHRvIGJlIGluc3RhbnRpYXRlZCB3aXRoIG9uZSBvciBib3RoIG9mIHRoZSBmb2xsb3dpbmcgc2V0dGluZ3M6XG5cbjEpIGEgcGFnZUFsaWFzZXMgZGljdGlvbmFyeSBhdHRyaWJ1dGUsIHN0cnVjdHVyZWQgYXMgeygwLWluZGV4ZWQgcGFnZSBpbmRleCk6IFxuKGFsaWFzZWQgcGFnZSBpbmRleCl9LiBGb3IgZXhhbXBsZSwgYSBkb2N1bWVudCB3aXRoIHRocmVlIGZvcndhcmQgcGFnZXMgbWF5IGJlIFxuY29uc3RydWN0ZWQgYXM6XG5cbiAgICB7MDogJ2knLCAxOiAnaWknLCAyOiAnaWlpJ31cblxuVGhpcyBvYmplY3QgZG9lcyBub3QgbmVlZCB0byBoYXZlIGEgY29tcGxldGUgbGlzdCBvZiBwb3NzaWJsZSBwYWdlIGluZGljZXMuIFxuXG4yKSBhIHBhZ2VBbGlhc0Z1bmN0aW9uIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gYSAwLWluZGV4ZWQgaW50ZWdlciB2YWx1ZSAodGhlIFxub3JpZ2luYWwgcGFnZSBpbmRleCkgYW5kIHJldHVybnMgZWl0aGVyIHRoZSBhbGlhc2VkIHBhZ2UgaW5kZXggb3IgdGhlIGJvb2xlYW5cbnZhbHVlIFwiZmFsc2VcIi4gRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IG1hcHBpbmcgZnJvbSAwLWluZGV4IHRvIDEtaW5kZXggbWF5IGJlIFxuY29uc3RydWN0ZWQgYXM6XG5cbiAgICBwYWdlQWxpYXNGdW5jdGlvbjogZnVuY3Rpb24ob3JpZ2luYWxQYWdlSW5kZXgpXG4gICAge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxQYWdlSW5kZXggKyAxO1xuICAgIH1cblxuXG5UaGlzIHBsdWdpbiBpcyBzb2xlbHkgZm9yIGNvc21ldGljIHB1cnBvc2VzOyBpdCB3aWxsIHJlcGxhY2UgdGhlIFwiUGFnZSBfIG9mIFhYXCIgXG5jb3VudGVyIGFuZCBhZGQgZnVuY3Rpb25zIHRoYXQgcnVuIGluIHBhcmFsbGVsIHdpdGggdGhlaXIgbm9uLWFsaWFzZWQgXG5lcXVpdmFsZW50cyBpbnN0ZWFkIG9mIHJlcGxhY2luZyB0aGVtLiBXaGVuIG9uZSBvZiB0aGUgYWxpYXNlZCBmdW5jdGlvbnMgaXMgXG5jYWxsZWQsIHRoZSAgcGx1Z2luIHdpbGwgZmlyc3QgdHJ5IHRvIGZpbmQgdGhlIHBhZ2UgYWxpYXMgaW4gdGhlIHBhZ2VBbGlhc2VzIFxuYXR0cmlidXRlLiBJZiB0aGlzIGZhaWxzLCB0aGUgcGx1Z2luIHdpbGwgdGhlbiBwYXNzIHRoZSBvcmlnaW5hbCBwYWdlIGluZGV4IGludG9cbnRoZSBwYWdlQWxpYXNGdW5jdGlvbiBmdW5jdGlvbi4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYm9vbGVhbiBcImZhbHNlXCIgKE5PVCBcbmEgbnVtYmVyIDAgb3IgYW4gdW5kZWZpbmVkKSwgdGhlIHBsdWdpbiB3aWxsIHJldmVydCB0byB0aGUgZGVmYXVsdCBwYWdlIGluZGV4LlxuXG5UaGUgcGx1Z2luIG1heSBhbHNvIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSAnZGl2YVNldHRpbmdzLm5ld1RvdGFsUGFnZXMnIFxuYXR0cmlidXRlLCB3aGljaCB3aWxsIHJlcGxhY2UgdGhlIFwiUGFnZSAxIG9mIF9fXCIgY291bnRlci5cbiovXG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi4vZGl2YScpO1xuXG4oZnVuY3Rpb24gKCQpXG57XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MucGFnZUFsaWFzZXMgPT09IHVuZGVmaW5lZCkgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFnZUFsaWFzZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLnBhZ2VBbGlhc0Z1bmN0aW9uID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFnZUFsaWFzRnVuY3Rpb24gPSBmdW5jdGlvbigpe3JldHVybiBmYWxzZTt9O1xuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBNYWluIGZ1bmN0aW9uLiBXaWxsIHJldHVybiB0aGUgZmlyc3Qgb2YgdGhlc2UgdGhyZWUgdGhhdCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVzIHRvIGJvb2xlYW4gdHJ1ZTpcbiAgICAgICAgICAgICAgICAgICAgLUV4cGxpY2l0IGFsaWFzIGFzIGRlZmluZWQgaW4gcGFnZUFsaWFzZXNcbiAgICAgICAgICAgICAgICAgICAgLVJlc3VsdCBvZiBwYWdlQWxpYXNGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAtb3JpZ2luYWxQYWdlSW5kZXggKyAxICh0byBzaW11bGF0ZSB0aGUgb3JpZ2luYWwgbWFwcGluZylcblxuICAgICAgICAgICAgICAgICAgICBFbHNlIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZS5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5nZXRBbGlhc0ZvclBhZ2VJbmRleCA9IGZ1bmN0aW9uKG9yaWdpbmFsUGFnZUluZGV4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmFTZXR0aW5ncy5wYWdlQWxpYXNlc1tvcmlnaW5hbFBhZ2VJbmRleF0gfHwgZGl2YVNldHRpbmdzLnBhZ2VBbGlhc0Z1bmN0aW9uKG9yaWdpbmFsUGFnZUluZGV4KSB8fCBvcmlnaW5hbFBhZ2VJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGZpcnN0IHBhZ2UgaW5kZXggZm91bmQgZm9yIGEgZ2l2ZW4gYWxpYXNlZCBudW1iZXIgb3IgZmFsc2UgaWYgbm90IGZvdW5kLlxuICAgICAgICAgICAgICAgICAgICBUaGlzIG1heSBjYXVzZSBpc3N1ZXMgaWYgYSBzcGVjaWZpYyBhbGlhcyBpcyBmb3VuZCBmb3IgbXVsdGlwbGUgcGFnZSBpbmRpY2VzOyB1c2UgZ2V0UGFnZUluZGljZXNGb3JBbGlhcyBhbmQgcmVpbXBsZW1lbnQgZnVuY3Rpb25zIGFzIG5lY2Vzc2FyeSBpZiB0aGlzIGlzIHRoZSBjYXNlLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdldFBhZ2VJbmRleEZvckFsaWFzID0gZnVuY3Rpb24oYWxpYXNlZE51bWJlcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgZGl2YVNldHRpbmdzLm51bVBhZ2VzOyBpZHgrKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGl2YUluc3RhbmNlLmdldEFsaWFzRm9yUGFnZUluZGV4KGlkeCkgPT0gYWxpYXNlZE51bWJlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy9SZXR1cm5zIGFycmF5IG9mIHBhZ2UgaW5kaWNlcyBmb3IgYSBnaXZlbiBhbGlhc2VkIG51bWJlci4gUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiBub25lIGFyZSBmb3VuZC5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ2V0UGFnZUluZGljZXNGb3JBbGlhcyA9IGZ1bmN0aW9uKGFsaWFzZWROdW1iZXIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhBcnIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCBkaXZhU2V0dGluZ3MubnVtUGFnZXM7IGlkeCsrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkaXZhSW5zdGFuY2UuZ2V0QWxpYXNGb3JQYWdlSW5kZXgoaWR4KSA9PSBhbGlhc2VkTnVtYmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QXJyLnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhBcnI7XG4gICAgICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAgICAgLy9NYXBzIHRoZSBjdXJyZW50IHBhZ2UgaW5kZXggdG8gZ2V0QWxpYXNGb3JQYWdlSW5kZXhcbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ2V0Q3VycmVudEFsaWFzZWRQYWdlSW5kZXggPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2YUluc3RhbmNlLmdldEFsaWFzRm9yUGFnZUluZGV4KGRpdmFTZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy9XcmFwcGVyIGZvciBnb3RvUGFnZUJ5SW5kZXgsIGtlZXBpbmcgdGhlIGFsaWFzZWQgbnVtYmVycyBpbiBtaW5kXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9QYWdlQnlBbGlhc2VkTnVtYmVyID0gZnVuY3Rpb24oYWxpYXNlZE51bWJlciwgeEFuY2hvciwgeUFuY2hvcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZhSW5zdGFuY2UuZ290b1BhZ2VCeUluZGV4KGRpdmFJbnN0YW5jZS5nZXRQYWdlSW5kZXhGb3JBbGlhcyhhbGlhc2VkTnVtYmVyKSwgeEFuY2hvciwgeUFuY2hvcik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBvdmVyd3JpdGVzIHVwZGF0ZUN1cnJlbnRQYWdlIGZyb20gdGhlIG1haW4gZGl2YSBmaWxlIHRvIHVwZGF0ZSBwYWdlIG51bWJlcnMgb24gVmlzaWJsZVBBZ2VEaWRDaGFuZ2VcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlQ3VycmVudEFsaWFzZWRQYWdlID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0U2V0dGluZ3MoKS5JRCArICdjdXJyZW50LXBhZ2UnKS50ZXh0Q29udGVudCA9IHRoaXMuZ2V0Q3VycmVudEFsaWFzZWRQYWdlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy92YXJpb3VzIGNoYW5nZXMgdGhhdCBuZWVkIHRvIGJlIG1hZGUgb25jZSB2aWV3ZXIgaXMgbG9hZGVkXG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxDaGFuZ2VzID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hhbmdlcyB0b3RhbCBwYWdlcyB2YWx1ZSBpbiBHVUlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBTZXR0aW5ncyA9IHRoaXMuZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RvdGFsUGFnZXMgPSB0ZW1wU2V0dGluZ3MubnVtUGFnZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wU2V0dGluZ3MubmV3VG90YWxQYWdlcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUb3RhbFBhZ2VzID0gdGVtcFNldHRpbmdzLm5ld1RvdGFsUGFnZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZW1wU2V0dGluZ3MudG90YWxQYWdlT2Zmc2V0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RvdGFsUGFnZXMgPSBuZXdUb3RhbFBhZ2VzICsgdGVtcFNldHRpbmdzLnRvdGFsUGFnZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vYWN0dWFsbHkgY2hhbmdlcyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRTZXR0aW5ncygpLklEICsgJ251bS1wYWdlcycpLnRleHRDb250ZW50ID0gbmV3VG90YWxQYWdlcztcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRTZXR0aW5ncygpLklEICsgJ2N1cnJlbnQtcGFnZScpLnRleHRDb250ZW50ID0gdGhpcy5nZXRDdXJyZW50QWxpYXNlZFBhZ2VJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9yZXN1YnNjcmliZXMgb3VyIG5ldyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMudW5zdWJzY3JpYmUoW1wiVmlzaWJsZVBhZ2VEaWRDaGFuZ2VcIiwgdGVtcFNldHRpbmdzLnRvb2xiYXIudXBkYXRlQ3VycmVudFBhZ2UsIGRpdmFTZXR0aW5ncy5JRF0pO1xuICAgICAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoXCJWaXNpYmxlUGFnZURpZENoYW5nZVwiLCB1cGRhdGVDdXJyZW50QWxpYXNlZFBhZ2UsIGRpdmFTZXR0aW5ncy5JRCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZShcIlZpZXdlckRpZExvYWRcIiwgaW5pdGlhbENoYW5nZXMsIGRpdmFTZXR0aW5ncy5JRCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ3BhZ2VhbGlhcycsXG4gICAgICAgICAgICB0aXRsZVRleHQ6ICdSZS1hbGlhc2VzIHBhZ2UgaW5kZXhlcydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9KSgpO1xufSkoalF1ZXJ5KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvanMvcGx1Z2lucy9wYWdlYWxpYXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==